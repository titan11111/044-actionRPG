<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>ã¼ã†ã‘ã‚“RPG - å‹‡è€…ã®æ—…ç«‹ã¡</title>
<style>
  :root {
    --bg: #0b0c10;
    --panel: rgba(255,255,255,0.06);
    --panel-strong: rgba(255,255,255,0.12);
    --outline: rgba(255,255,255,0.24);
    --text: #eef2f6;
    --muted: #aab2bf;
    --accent: #8bd3ff;
    --danger: #ff6b6b;
    --gold: #ffd56c;
    --btn-size: 64px;
    --font-scale: 1;
  }

  html, body { height: 100%; margin: 0; }
  body {
    font-family: ui-sans-serif, system-ui, sans-serif;
    color: var(--text);
    background: radial-gradient(1200px 800px at 50% 10%, #141720, #0b0c10 60%);
    overflow: hidden;
    -webkit-user-select: none; user-select: none;
    touch-action: none;
  }

  #root {
    position: fixed; inset: 0;
    display: grid; place-items: center;
  }

  .stage {
    position: relative;
    width: min(100vw, 100vh * 16/9);
    height: min(100vh, 100vw * 9/16);
    border-radius: 16px;
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.3));
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.08);
    overflow: hidden;
  }

  #game {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    background: #151821;
  }

  .hud { 
    position:absolute; inset:0; pointer-events:none; 
    font-size: calc(14px * var(--font-scale)); 
  }

  .hud-top { 
    position:absolute; top: 8px; left:8px; right:8px; 
    display:flex; align-items:center; justify-content:space-between; gap:8px; 
  }

  .hearts { display:flex; gap:4px; }
  .heart { 
    width:28px; height:28px; 
    background: #ff4364;
    clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    animation: heartbeat 1.5s ease-in-out infinite;
  }
  .heart.empty { 
    background: #666; 
    filter: grayscale(1) brightness(0.6);
    animation: none;
  }
  
  @keyframes heartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }

  .counter { 
    pointer-events:auto; 
    display:flex; align-items:center; gap:8px; 
    background: var(--panel); 
    border:1px solid var(--outline); 
    padding:8px 12px; border-radius: 999px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  
  .coin { 
    width:20px; height:20px; border-radius:50%; 
    background: radial-gradient(circle at 35% 35%, #fff7bf, var(--gold)); 
    border:2px solid #b8860b; 
    box-shadow: inset 0 0 4px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.2);
    animation: coinSpin 3s linear infinite;
  }
  
  @keyframes coinSpin {
    0%, 100% { transform: rotateY(0deg); }
    50% { transform: rotateY(180deg); }
  }

  .btn-ghost { 
    pointer-events:auto; 
    background: var(--panel); border:1px solid var(--outline); 
    color: var(--text); padding:8px 12px; border-radius:12px; 
    font-weight:700; box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    transition: all 0.2s ease; cursor: pointer;
  }
  .btn-ghost:active { transform: scale(0.96); }

  .hint { 
    position:absolute; left:50%; transform: translateX(-50%); 
    bottom: 68px; background: var(--panel); 
    border:1px solid var(--outline); padding:8px 12px; 
    border-radius:12px; opacity:0; transition: opacity .2s ease;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  .hint.show { opacity: 1; }

  .virtual { position:absolute; inset:0; pointer-events:none; }
  
  .stick { 
    position:absolute; left: 10px; bottom: 10px; 
    width: 160px; height: 160px; pointer-events:auto; 
  }
  .stick .base { 
    position:absolute; inset: 0; border-radius:50%; 
    background: var(--panel); border: 2px solid var(--outline);
    box-shadow: inset 0 4px 8px rgba(0,0,0,0.3), 0 4px 12px rgba(0,0,0,0.2);
  }
  .stick .knob { 
    --k: calc(var(--btn-size) * 0.75); 
    position:absolute; left: 50%; top: 50%; 
    width: var(--k); height: var(--k); 
    transform: translate(-50%,-50%); border-radius: 50%; 
    background: linear-gradient(135deg, var(--panel-strong), var(--panel)); 
    border: 2px solid var(--outline); 
    box-shadow: 0 4px 8px rgba(0,0,0,0.35);
  }

  .buttons { 
    position:absolute; right: 10px; bottom: 10px; 
    display:grid; grid-template-areas: ". x" "b a"; 
    gap: 12px; pointer-events:auto; 
  }
  
  .btn { 
    width: var(--btn-size); height: var(--btn-size); 
    border-radius: 50%; 
    background: linear-gradient(135deg, var(--panel-strong), var(--panel)); 
    border:2px solid var(--outline); 
    display:grid; place-items:center; 
    font-weight: 800; font-size: calc(16px * var(--font-scale));
    box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    transition: all 0.2s ease; cursor: pointer;
  }
  .btn:active { 
    transform: scale(0.92); 
    box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  }
  .btn.a { grid-area: a; background: linear-gradient(135deg, #ff6b6b, #e74c3c); color: white; }
  .btn.b { grid-area: b; background: linear-gradient(135deg, #4ecdc4, #45b7b8); color: white; }
  .btn.x { grid-area: x; background: linear-gradient(135deg, #f39c12, #e67e22); color: white; }

  dialog { border: none; padding: 0; background: transparent; }
  .sheet { 
    width: min(92vw, 480px); 
    background: rgba(18,20,28,0.9); backdrop-filter: blur(8px); 
    border: 1px solid var(--outline); color: var(--text); 
    border-radius: 16px; overflow: hidden;
    box-shadow: 0 20px 40px rgba(0,0,0,0.5);
  }
  .sheet header { 
    padding: 16px 20px; font-weight: 800; 
    border-bottom: 1px solid var(--outline);
    background: var(--panel); font-size: calc(18px * var(--font-scale));
  }
  .sheet .content { padding: 16px 20px; }
  .sheet .actions { 
    padding: 16px 20px; display:flex; gap: 12px; 
    justify-content:flex-end; border-top: 1px solid var(--outline);
    background: var(--panel);
  }

  .level-up {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: calc(24px * var(--font-scale));
    font-weight: 800; color: var(--gold);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    opacity: 0; pointer-events: none;
  }

  @keyframes levelUpAnim {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    80% { opacity: 1; transform: translate(-50%, -60%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
  }
</style>
</head>
<body>
  <div id="root">
    <div class="stage">
      <canvas id="game" width="320" height="180"></canvas>

      <div class="hud">
        <div class="hud-top">
          <div class="hearts" id="hearts"></div>
          <div style="display:flex; align-items:center; gap:8px;">
            <div class="counter">
              <div class="coin"></div>
              <span id="coins">0</span>
            </div>
            <div class="counter" style="background: linear-gradient(135deg, var(--panel), rgba(139,211,255,0.1));">
              <span style="color: var(--accent); font-weight: 800;">Lv</span>
              <span id="level">1</span>
            </div>
            <button class="btn-ghost" id="btnPause">âš™ï¸</button>
          </div>
        </div>
        <div class="hint" id="hint">ğŸ® ç§»å‹•ã—ã¦ã¿ã‚ˆã†</div>
        <div class="level-up" id="levelUp" style="display: none;">ğŸŒŸ LEVEL UP! ğŸŒŸ</div>
      </div>

      <div class="virtual">
        <div class="stick" id="stick">
          <div class="base"></div>
          <div class="knob" id="stickKnob"></div>
        </div>
        <div class="buttons">
          <button class="btn a" id="btnA">âš”ï¸</button>
          <button class="btn b" id="btnB">ğŸ’¬</button>
          <button class="btn x" id="btnX">ğŸ’£</button>
        </div>
      </div>

      <dialog id="tutorial">
        <div class="sheet">
          <header>ğŸ® ã¼ã†ã‘ã‚“ã®å§‹ã¾ã‚Š</header>
          <div class="content" id="tutContent">
            <p>ã‚ˆã†ã“ãã€å‹‡è€…ã•ã‚“ï¼ã¾ãšã¯æ­©ã„ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
          </div>
          <div class="actions">
            <button class="btn-ghost" id="tutSkip">ã‚¹ã‚­ãƒƒãƒ—</button>
            <button class="btn-ghost" id="tutNext">æ¬¡ã¸ â¡ï¸</button>
          </div>
        </div>
      </dialog>

      <dialog id="pause">
        <div class="sheet">
          <header>âš™ï¸ è¨­å®š</header>
          <div class="content">
            <p style="margin: 0;">âš”ï¸ = æ”»æ’ƒ / ğŸ’¬ = ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ / ğŸ’£ = çˆ†å¼¾</p>
          </div>
          <div class="actions">
            <button class="btn-ghost" id="btnClose">é–‰ã˜ã‚‹</button>
          </div>
        </div>
      </dialog>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (x1,y1,x2,y2) => { const dx = x2-x1, dy = y2-y1; return dx*dx+dy*dy; };

  // ã‚­ãƒ£ãƒ³ãƒã‚¹
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = 320, H = 180;

  // å®‰å…¨ãªå®šæ•°
  const TS = 16;
  const COLS = 20; // 320/16 = 20
  const ROWS = 11; // 180/16 = 11.25 -> 11
  const T = { GRASS:0, TREE:1, WATER:2, TALL:3, PATH:4, FLOWER:5 };

  // å®‰å…¨ãªãƒãƒƒãƒ—åˆæœŸåŒ–
  const map = [];
  for(let y = 0; y < ROWS; y++) {
    map[y] = [];
    for(let x = 0; x < COLS; x++) {
      map[y][x] = T.GRASS;
    }
  }

  // ãƒãƒƒãƒ—ç”Ÿæˆï¼ˆå®‰å…¨ãªå¢ƒç•Œãƒã‚§ãƒƒã‚¯ä»˜ãï¼‰
  for(let y = 3; y < 8 && y < ROWS; y++) {
    for(let x = 4; x < 16 && x < COLS; x++) {
      map[y][x] = T.PATH;
    }
  }

  // ãƒ©ãƒ³ãƒ€ãƒ é…ç½®ï¼ˆå®‰å…¨ï¼‰
  for(let i = 0; i < 30; i++){
    const x = Math.floor(Math.random() * COLS);
    const y = Math.floor(Math.random() * ROWS);
    if (map[y] && map[y][x] === T.GRASS) {
      map[y][x] = T.TREE;
    }
  }
  for(let i = 0; i < 10; i++){
    const x = Math.floor(Math.random() * COLS);
    const y = Math.floor(Math.random() * ROWS);
    if (map[y] && map[y][x] === T.GRASS) {
      map[y][x] = T.WATER;
    }
  }
  for(let i = 0; i < 15; i++){
    const x = Math.floor(Math.random() * COLS);
    const y = Math.floor(Math.random() * ROWS);
    if (map[y] && map[y][x] === T.GRASS) {
      map[y][x] = T.FLOWER;
    }
  }

  const isBlock = (t) => t === T.TREE || t === T.WATER;

  // ã‚µã‚¦ãƒ³ãƒ‰
  const Sound = (() => {
    let audioContext = null;
    let unlocked = false;
    
    const unlock = () => { 
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioContext.state === 'suspended') audioContext.resume(); 
        unlocked = true; 
      } catch(e) {
        console.log('Audio not supported');
      }
    };

    const playSound = (type) => {
      if (!unlocked || !audioContext) return;
      
      try {
        const beep = (f, t, waveType='square', g=0.04) => {
          const o = audioContext.createOscillator();
          const v = audioContext.createGain();
          o.type = waveType; 
          o.frequency.value = f;
          v.gain.value = g; 
          o.connect(v); 
          v.connect(audioContext.destination);
          const t0 = audioContext.currentTime;
          o.start(t0); 
          o.stop(t0 + t);
        };

        switch(type) {
          case 'sword': beep(880, 0.05); setTimeout(() => beep(660, 0.08), 50); break;
          case 'hit': beep(150, 0.15, 'sawtooth', 0.08); break;
          case 'coin': beep(659, 0.3, 'sine', 0.05); break;
          case 'chest': beep(523, 0.4, 'triangle', 0.06); break;
          case 'bomb': beep(80, 0.2, 'square', 0.12); break;
          case 'talk': beep(523, 0.2, 'triangle', 0.04); break;
          case 'level': 
            for(let i = 0; i < 5; i++) {
              setTimeout(() => beep(523 + i*100, 0.15, 'sine', 0.05), i * 100);
            }
            break;
          case 'button': beep(440, 0.05, 'square', 0.02); break;
        }
      } catch(e) {
        console.log('Audio error:', e);
      }
    };

    return { unlock, playSound, get unlocked() { return unlocked; } };
  })();

  // åˆå›ã‚¯ãƒªãƒƒã‚¯ã§ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè§£ç¦
  const unlockAudio = () => {
    Sound.unlock();
    window.removeEventListener('pointerdown', unlockAudio);
  };
  window.addEventListener('pointerdown', unlockAudio);

  // å…¥åŠ›
  const Input = {
    ax: 0, ay: 0,
    a: false, b: false, x: false,
    aDown: false, bDown: false, xDown: false,
    updateEdges() {
      this.aDown = this.a && !this._pa; this._pa = this.a;
      this.bDown = this.b && !this._pb; this._pb = this.b;
      this.xDown = this.x && !this._px; this._px = this.x;
    },
  };

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰
  window.addEventListener('keydown', (e) => {
    switch(e.key){
      case 'ArrowLeft': Input.ax = -1; break;
      case 'ArrowRight': Input.ax = 1; break;
      case 'ArrowUp': Input.ay = -1; break;
      case 'ArrowDown': Input.ay = 1; break;
      case ' ': case 'j': Input.a = true; break;
      case 'k': case 'z': Input.b = true; break;
      case 'x': Input.x = true; break;
      case 'Escape': togglePause(); break;
    }
    e.preventDefault();
  });
  
  window.addEventListener('keyup', (e) => {
    switch(e.key){
      case 'ArrowLeft': if (Input.ax<0) Input.ax = 0; break;
      case 'ArrowRight': if (Input.ax>0) Input.ax = 0; break;
      case 'ArrowUp': if (Input.ay<0) Input.ay = 0; break;
      case 'ArrowDown': if (Input.ay>0) Input.ay = 0; break;
      case ' ': case 'j': Input.a = false; break;
      case 'k': case 'z': Input.b = false; break;
      case 'x': Input.x = false; break;
    }
  });

  // ã‚¿ãƒƒãƒ
  const stick = document.getElementById('stick');
  const stickKnob = document.getElementById('stickKnob');
  let stickId = null, stickCenter = {x:0,y:0};
  const R = 56;

  const setKnob = (dx,dy) => stickKnob.style.transform = `translate(${dx}px, ${dy}px)`;

  stick.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    stickId = e.pointerId;
    stickCenter.x = e.clientX;
    stickCenter.y = e.clientY;
  });

  window.addEventListener('pointermove', (e) => {
    if (e.pointerId === stickId) {
      const dx = e.clientX - stickCenter.x;
      const dy = e.clientY - stickCenter.y;
      const len = Math.hypot(dx,dy) || 1;
      const cl = Math.min(len, R);
      const nx = dx/len, ny = dy/len;
      const kx = nx*cl, ky = ny*cl;
      setKnob(kx, ky);
      Input.ax = (cl/R)*nx;
      Input.ay = (cl/R)*ny;
      e.preventDefault();
    }
  });

  window.addEventListener('pointerup', (e) => {
    if (e.pointerId === stickId) {
      stickId = null;
      setKnob(0, 0);
      Input.ax = 0;
      Input.ay = 0;
    }
  });

  // ãƒœã‚¿ãƒ³
  const btnA = document.getElementById('btnA');
  const btnB = document.getElementById('btnB');
  const btnX = document.getElementById('btnX');

  const pressBtn = (key) => (e) => {
    e.preventDefault();
    Input[key] = true;
    Sound.playSound('button');
  };
  const releaseBtn = (key) => (e) => {
    e.preventDefault();
    Input[key] = false;
  };

  btnA.addEventListener('pointerdown', pressBtn('a'));
  btnA.addEventListener('pointerup', releaseBtn('a'));
  btnB.addEventListener('pointerdown', pressBtn('b'));
  btnB.addEventListener('pointerup', releaseBtn('b'));
  btnX.addEventListener('pointerdown', pressBtn('x'));
  btnX.addEventListener('pointerup', releaseBtn('x'));

  // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
  const state = {
    coins: 0,
    hp: 5, maxHp: 5,
    level: 1, exp: 0, expToNext: 10,
    tutorialStep: 0,
    paused: false,
    hintTimer: 0,
  };

  // HUDè¦ç´ 
  const heartEl = document.getElementById('hearts');
  const coinsEl = document.getElementById('coins');
  const levelEl = document.getElementById('level');
  const hintEl = document.getElementById('hint');
  const levelUpEl = document.getElementById('levelUp');

  function renderHUD(){
    heartEl.innerHTML = '';
    for (let i=0;i<state.maxHp;i++){
      const d = document.createElement('div');
      d.className = 'heart' + (i >= state.hp? ' empty':'');
      heartEl.appendChild(d);
    }
    coinsEl.textContent = state.coins;
    levelEl.textContent = state.level;
  }

  function showHint(txt, secs=1.5){
    state.hintTimer = secs;
    hintEl.textContent = txt;
    hintEl.classList.add('show');
  }

  function gainExp(amount) {
    state.exp += amount;
    if (state.exp >= state.expToNext) {
      state.level++;
      state.exp = 0;
      state.expToNext = Math.floor(state.expToNext * 1.2);
      state.maxHp++;
      state.hp = state.maxHp;
      Sound.playSound('level');
      showLevelUp();
      showHint(`ãƒ¬ãƒ™ãƒ« ${state.level}! HP+1`);
    }
  }

  function showLevelUp() {
    levelUpEl.style.display = 'block';
    levelUpEl.style.animation = 'none';
    setTimeout(() => {
      levelUpEl.style.animation = 'levelUpAnim 2s ease-out';
    }, 10);
    setTimeout(() => {
      levelUpEl.style.display = 'none';
    }, 2000);
  }

  // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£
  class Entity {
    constructor(x,y) {
      this.x=x; this.y=y; this.w=12; this.h=12;
      this.vx=0; this.vy=0; this.dir=1; this.hp=1; this.dead=false;
    }
  }

  class Player extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=60; this.hp=state.hp; this.maxHp=state.maxHp;
      this.inv=0; this.attackCd=0; this.swordT=0;
      this.sdx=1; this.sdy=0;
    }
  }

  class Slime extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=25; this.hp=2; this.change=0; this.bounceT=0;
    }
    update(dt) {
      this.bounceT += dt * 4;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 2 + 0.8;
        const ang = Math.random() * Math.PI * 2;
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed;
      }
    }
  }

  class Archer extends Entity {
    constructor(x,y) {
      super(x,y);
      this.hp=3; this.cd=0; this.range=180; this.alertT=0;
    }
    update(dt) {
      if (this.alertT > 0) this.alertT -= dt;
    }
  }

  class Arrow extends Entity {
    constructor(x,y,vx,vy) {
      super(x,y);
      this.vx=vx; this.vy=vy; this.w=6; this.h=2; this.life=2.5;
    }
  }

  class Bomb {
    constructor(x,y) {
      this.x=x; this.y=y; this.t=1.2; this.exploded=false;
    }
  }

  class Explosion {
    constructor(x,y) {
      this.x=x; this.y=y; this.t=0.4; this.power=2;
    }
  }

  // ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
  const player = new Player(160, 96);
  const npcs = [{
    x: 160, y: 56, r: 14, 
    text: 'ğŸ§™â€â™‚ï¸ ã‚ˆã†ã“ãã€å‹‡è€…ã‚ˆï¼\nç§ã¯æ‘ã®é­”æ³•ä½¿ã„ã§ã™ã€‚\n\nå±é™ºãªãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒå¢—ãˆã¦ã„ã¾ã™ã€‚\nå›ã®åŠ›ã§æ‘ã‚’å®ˆã£ã¦ãã‚Œï¼', 
    talked: false,
    rewardShown: false
  }];
  const chests = [{x: 208, y: 96, r: 12, opened:false}, {x: 80, y: 140, r: 12, opened:false}];
  const slimes = [new Slime(80,40), new Slime(260,120), new Slime(50,160)];
  const archers = [new Archer(56,40), new Archer(280,60)];
  const arrows = [];
  const bombs = [];
  const blasts = [];

  // å®‰å…¨ãªè¡çªåˆ¤å®š
  function getTile(x, y) {
    if (y < 0 || y >= ROWS || x < 0 || x >= COLS) return T.TREE; // å¢ƒç•Œå¤–ã¯å£
    if (!map[y] || map[y][x] === undefined) return T.TREE;
    return map[y][x];
  }

  function moveWithTile(e, dt) {
    let nx = e.x + e.vx * dt;
    let ny = e.y + e.vy * dt;
    if (!collidesTile(nx, e.y, e.w, e.h)) e.x = nx; else e.vx=0;
    if (!collidesTile(e.x, ny, e.w, e.h)) e.y = ny; else e.vy=0;
  }

  function collidesTile(cx, cy, w, h) {
    const x0 = Math.floor((cx-w/2)/TS);
    const x1 = Math.floor((cx+w/2)/TS);
    const y0 = Math.floor((cy-h/2)/TS);
    const y1 = Math.floor((cy+h/2)/TS);
    
    for(let y=y0;y<=y1;y++) {
      for(let x=x0;x<=x1;x++){
        const tile = getTile(x, y);
        if (isBlock(tile)) return true;
      }
    }
    return false;
  }

  // æ”»æ’ƒ
  function attack() {
    if (player.attackCd>0) return;
    player.attackCd = 0.3;
    
    const dirX = Math.sign(Input.ax || player.dir) || player.dir;
    const dirY = Math.sign(Input.ay || 0);
    player.sdx = dirX; player.sdy = dirY;
    player.swordT = 0.18;

    Sound.playSound('sword');

    const range = 18; const w=16, h=12;
    const ax = player.x + dirX*range;
    const ay = player.y + dirY*range;
    const hit = (e) => Math.abs(e.x-ax)<w/2 && Math.abs(e.y-ay)<h/2;
    
    let hitSomething = false;
    for (const s of slimes) {
      if (!s.dead && hit(s)) {
        s.hp--;
        hitSomething = true;
        if (s.hp<=0) {
          s.dead=true;
          state.coins+=3;
          gainExp(2);
          showHint('ğŸŸ¢ ã‚¹ãƒ©ã‚¤ãƒ æ’ƒç ´! +3ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const a of archers) {
      if (!a.dead && hit(a)) {
        a.hp--;
        a.alertT = 0.5;
        hitSomething = true;
        if (a.hp<=0) {
          a.dead=true;
          state.coins+=5;
          gainExp(3);
          showHint('ğŸ¹ ã‚¢ãƒ¼ãƒãƒ£ãƒ¼æ’ƒç ´! +5ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
  }

  function placeBomb() {
    if (bombs.length >= 3) return;
    bombs.push(new Bomb(Math.round(player.x/TS)*TS, Math.round(player.y/TS)*TS));
    Sound.playSound('button');
    showHint('ğŸ’£ çˆ†å¼¾è¨­ç½®');
  }

  function hitPlayer(dmg) {
    if (player.inv>0) return;
    player.hp = Math.max(0, player.hp - dmg);
    state.hp = player.hp;
    player.inv = 1.2;
    Sound.playSound('hit');
    showHint(`ğŸ’” -${dmg} HP`);
    if (player.hp<=0) respawn();
  }

  function respawn() {
    state.coins = Math.max(0, Math.floor(state.coins/2));
    player.x=160; player.y=96;
    player.hp=player.maxHp;
    state.hp=player.hp;
    showHint('ğŸ  æ‘ã«æˆ»ã‚Šã¾ã—ãŸ');
    Sound.playSound('talk');
  }

  function hasLineOfSight(x0,y0,x1,y1) {
    const steps = 40;
    for(let i=1;i<steps;i++) {
      const t=i/steps;
      const x=x0+(x1-x0)*t, y=y0+(y1-y0)*t;
      const tx=Math.floor(x/TS), ty=Math.floor(y/TS);
      const tile = getTile(tx, ty);
      if (isBlock(tile)) return false;
    }
    return true;
  }

  // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æç”»
  function drawCharacter(x, y, type, entity = null) {
    ctx.save();
    
    switch(type) {
      case 'player':
        if (entity && entity.inv > 0) {
          ctx.globalAlpha = 0.6 + 0.4 * Math.sin(performance.now() * 0.02);
        }
        
        // ä½“ï¼ˆé’ã„æœï¼‰
        ctx.fillStyle = '#4a90e2';
        ctx.fillRect(x-6, y-8, 12, 16);
        
        // é ­ï¼ˆè‚Œè‰²ï¼‰
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-5, y-12, 10, 8);
        
        // é«ªï¼ˆèŒ¶è‰²ï¼‰
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(x-6, y-14, 12, 4);
        
        // ç›®
        ctx.fillStyle = '#000';
        ctx.fillRect(x-3, y-10, 2, 1);
        ctx.fillRect(x+1, y-10, 2, 1);
        
        // è…•
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-8, y-6, 3, 8);
        ctx.fillRect(x+5, y-6, 3, 8);
        
        // è¶³ï¼ˆé´ï¼‰
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(x-6, y+6, 5, 4);
        ctx.fillRect(x+1, y+6, 5, 4);
        break;
        
      case 'slime':
        const bounce = entity ? Math.sin(entity.bounceT) * 1 : 0;
        ctx.fillStyle = '#6cf07a';
        ctx.beginPath();
        ctx.ellipse(x, y + bounce, 8, 6 - bounce * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        ctx.fillStyle = '#a8ffa8';
        ctx.beginPath();
        ctx.ellipse(x - 2, y - 1 + bounce, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ç›®
        ctx.fillStyle = '#000';
        ctx.fillRect(x-3, y-1, 2, 2);
        ctx.fillRect(x+1, y-1, 2, 2);
        break;
        
      case 'archer':
        const alert = entity && entity.alertT > 0;
        if (alert) {
          ctx.globalAlpha = 0.8 + 0.2 * Math.sin(performance.now() * 0.01);
        }
        
        // ä½“
        ctx.fillStyle = alert ? '#ff6b6b' : '#b7a1f0';
        ctx.fillRect(x-5, y-6, 10, 12);
        
        // é ­
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-4, y-10, 8, 6);
        
        // ãƒ•ãƒ¼ãƒ‰
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x-5, y-12, 10, 4);
        
        // å¼“
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x + 6, y, 8, -Math.PI/3, Math.PI/3);
        ctx.stroke();
        
        // ç›®
        ctx.fillStyle = alert ? '#ff0000' : '#000';
        ctx.fillRect(x-2, y-8, 1, 1);
        ctx.fillRect(x+1, y-8, 1, 1);
        break;
        
      case 'npc':
        // é­”æ³•ä½¿ã„é¢¨NPC
        ctx.fillStyle = '#8b4b9c';
        ctx.fillRect(x-6, y-8, 12, 16);
        
        // é ­
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-4, y-10, 8, 6);
        
        // å¸½å­
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x-5, y-14, 10, 6);
        ctx.fillRect(x+3, y-16, 3, 3);
        
        // ã²ã’
        ctx.fillStyle = '#ddd';
        ctx.fillRect(x-3, y-6, 6, 3);
        
        // æ–
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + 8, y + 8);
        ctx.lineTo(x + 8, y - 10);
        ctx.stroke();
        
        // æ–ã®å…ˆï¼ˆæ˜Ÿï¼‰
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(x + 7, y - 12, 3, 3);
        break;
    }
    
    ctx.restore();
  }

  // æç”»
  function draw() {
    ctx.clearRect(0,0,W,H);

    // ã‚¿ã‚¤ãƒ«
    for(let y=0;y<ROWS;y++) {
      for(let x=0;x<COLS;x++){
        const t = getTile(x, y);
        const px = x*TS, py=y*TS;
        
        switch(t){
          case T.GRASS: 
            ctx.fillStyle='#2d5016'; 
            ctx.fillRect(px,py,TS,TS);
            // è‰ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£
            ctx.fillStyle='#3a6b1f';
            for(let i=0;i<3;i++) {
              const gx = px + (i*5) + 2;
              const gy = py + 8 + (i%2)*3;
              ctx.fillRect(gx, gy, 1, 4);
            }
            break;
            
          case T.PATH: 
            ctx.fillStyle='#8b7355'; 
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#756347';
            ctx.fillRect(px+2, py+2, 5, 5);
            ctx.fillRect(px+9, py+9, 5, 5);
            break;
            
          case T.TREE: 
            ctx.fillStyle='#2d5016';
            ctx.fillRect(px,py,TS,TS);
            // å¹¹
            ctx.fillStyle='#8b4513';
            ctx.fillRect(px+6, py+8, 4, 8);
            // è‘‰
            ctx.fillStyle='#228b22';
            ctx.fillRect(px+2, py+2, 12, 10);
            ctx.fillStyle='#32cd32';
            ctx.fillRect(px+4, py+4, 8, 6);
            break;
            
          case T.WATER: 
            ctx.fillStyle='#1e3a8a'; 
            ctx.fillRect(px,py,TS,TS);
            const waveTime = performance.now() * 0.005;
            const wave = Math.sin(waveTime + x + y) * 0.3;
            ctx.fillStyle=`rgba(100,149,237,${0.3 + wave})`;
            ctx.fillRect(px,py,TS,TS*0.5);
            break;
            
          case T.FLOWER:
            ctx.fillStyle='#2d5016'; 
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#ff69b4';
            ctx.fillRect(px+6, py+6, 4, 4);
            ctx.fillStyle='#ffd700';
            ctx.fillRect(px+7, py+7, 2, 2);
            break;
        }
      }
    }

    // NPC
    for (const n of npcs){
      drawCharacter(n.x, n.y, 'npc');
      if (!n.talked) {
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(n.x-1, n.y-20, 2, 6);
        ctx.fillRect(n.x-1, n.y-12, 2, 2);
      }
    }
    
    // å®ç®±
    for (const c of chests){ 
      const chestColor = c.opened? '#8e6b3f' : '#d4af37';
      ctx.fillStyle = chestColor;
      ctx.fillRect(c.x-8,c.y-6,16,12);
      
      if (!c.opened) {
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(c.x-6, c.y-4, 12, 2);
        ctx.fillRect(c.x-2, c.y-2, 4, 4);
        const sparkleTime = performance.now() * 0.01;
        const sparkle = Math.sin(sparkleTime) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255,255,255,${sparkle})`;
        ctx.fillRect(c.x-10, c.y-8, 2, 2);
        ctx.fillRect(c.x+8, c.y-8, 2, 2);
        ctx.fillRect(c.x, c.y-10, 2, 2);
      }
    }

    // çˆ†å¼¾
    for (const b of bombs){ 
      const pulseTime = performance.now() * 0.01;
      const bombColor = b.t < 0.3 ? '#ff0000' : '#333';
      ctx.fillStyle = bombColor;
      ctx.fillRect(b.x-4, b.y-4, 8, 8);
      
      ctx.fillStyle = '#ff4500';
      ctx.fillRect(b.x-1, b.y-8, 2, 4);
      
      if (b.t < 0.3) {
        const pulse = Math.sin(pulseTime * 10) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255,255,255,${pulse})`;
        ctx.fillRect(b.x-5, b.y-5, 10, 10);
      }
    }
    
    // çˆ†ç™º
    for (const ex of blasts){ 
      const intensity = ex.t / 0.4;
      ctx.save();
      ctx.globalAlpha = intensity;
      
      ctx.fillStyle='#ffaa00';
      ctx.fillRect(ex.x-TS*2, ex.y-4, TS*4, 8);
      ctx.fillRect(ex.x-4, ex.y-TS*2, 8, TS*4);
      
      ctx.fillStyle='#ff6600';
      ctx.fillRect(ex.x-TS, ex.y-2, TS*2, 4);
      ctx.fillRect(ex.x-2, ex.y-TS, 4, TS*2);
      
      ctx.fillStyle='#ffffff';
      ctx.fillRect(ex.x-8, ex.y-1, 16, 2);
      ctx.fillRect(ex.x-1, ex.y-8, 2, 16);
      
      ctx.restore();
    }

    // çŸ¢
    for (const ar of arrows){ 
      ctx.save();
      const angle = Math.atan2(ar.vy, ar.vx);
      ctx.translate(ar.x, ar.y);
      ctx.rotate(angle);
      
      ctx.fillStyle='#8b4513';
      ctx.fillRect(-6, -1, 8, 2);
      ctx.fillStyle='#ddd';
      ctx.fillRect(2, -2, 4, 4);
      
      ctx.restore();
    }

    // æ•µ
    for (const s of slimes){ 
      if (s.dead) continue; 
      drawCharacter(s.x, s.y, 'slime', s);
    }
    for (const a of archers){ 
      if (a.dead) continue; 
      drawCharacter(a.x, a.y, 'archer', a);
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    drawCharacter(player.x, player.y, 'player', player);

    // å‰£
    if (player.swordT > 0){
      const alpha = clamp(player.swordT / 0.18, 0, 1);
      ctx.save();
      ctx.globalAlpha = alpha;
      
      const dx = player.sdx, dy = player.sdy;
      const swordLength = 16;
      const swordWidth = 4;
      
      ctx.translate(player.x, player.y);
      ctx.rotate(Math.atan2(dy, dx));
      
      // å‰£èº«
      ctx.fillStyle = '#e8e8e8';
      ctx.fillRect(8, -swordWidth/2, swordLength, swordWidth);
      
      // å‰£å…ˆ
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(8 + swordLength - 2, -1, 2, 2);
      
      // æŸ„
      ctx.fillStyle = '#8b4513';
      ctx.fillRect(4, -2, 6, 4);
      
      // ãƒ„ãƒ
      ctx.fillStyle = '#666';
      ctx.fillRect(8, -3, 2, 6);
      
      ctx.restore();
    }
  }

  // æ›´æ–°
  function update(dt) {
    // å…¥åŠ›
    const speed = player.speed;
    player.vx = Input.ax * speed; 
    player.vy = Input.ay * speed;
    if (Math.abs(Input.ax) > 0.1) player.dir = Math.sign(Input.ax);

    // æ”»æ’ƒãƒ»çˆ†å¼¾
    if (Input.aDown) attack();
    if (Input.xDown) placeBomb();

    if (player.attackCd>0) player.attackCd-=dt;
    if (player.inv>0) player.inv-=dt;
    if (player.swordT>0) player.swordT-=dt;

    moveWithTile(player, dt);

    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
    let canTalk = false, canOpen = false;
    const near = (o,r) => dist2(player.x,player.y,o.x,o.y) < (r*r);
    
    for (const n of npcs){ 
      if (near(n, 20)) canTalk = true; 
    }
    for (const c of chests){ 
      if (!c.opened && near(c, 20)) canOpen = true; 
    }
    
    if (canTalk) showHint('ğŸ’¬ Bã§è©±ã™'); 
    else if (canOpen) showHint('ğŸ“¦ Bã§é–‹ã‘ã‚‹');
    
    if (Input.bDown){
      if (canTalk){ 
        const npc = npcs.find(n => near(n, 20));
        if (npc) {
          Sound.playSound('talk'); 
          showHint(npc.text);
          if (!npc.talked) {
            npc.talked = true;
            state.coins += 5;
            gainExp(1);
            showHint('ğŸ§™â€â™‚ï¸ é­”æ³•ä½¿ã„ã‹ã‚‰+5ğŸ’°');
          }
        }
      }
      else if (canOpen){ 
        const chest = chests.find(c=>!c.opened && near(c,20)); 
        if (chest){ 
          chest.opened = true; 
          const reward = 10 + state.level * 2;
          state.coins += reward; 
          gainExp(3);
          Sound.playSound('chest'); 
          showHint(`ğŸ“¦ å®ç®±ã‹ã‚‰+${reward}ğŸ’°`); 
        }
      }
    }

    // ã‚¹ãƒ©ã‚¤ãƒ 
    for (const s of slimes){ 
      if (s.dead) continue; 
      s.update(dt); 
      moveWithTile(s, dt); 
      if (dist2(s.x,s.y,player.x,player.y) < 15*15) hitPlayer(1); 
    }

    // ã‚¢ãƒ¼ãƒãƒ£ãƒ¼
    for (const a of archers){ 
      if (a.dead) continue; 
      a.update(dt);
      if ((a.cd-=dt)<=0){
        const playerDist = Math.hypot(a.x - player.x, a.y - player.y);
        if (playerDist < a.range) {
          if (Math.abs(a.y-player.y)<12 && hasLineOfSight(a.x,a.y,player.x,player.y)) { 
            const vx = Math.sign(player.x-a.x)*120; 
            arrows.push(new Arrow(a.x, a.y, vx, 0)); 
            a.cd=1.5; 
            a.alertT = 0.5;
            Sound.playSound('button');
          } 
          else if (Math.abs(a.x-player.x)<12 && hasLineOfSight(a.x,a.y,player.x,player.y)) { 
            const vy = Math.sign(player.y-a.y)*120; 
            arrows.push(new Arrow(a.x, a.y, 0, vy)); 
            a.cd=1.5; 
            a.alertT = 0.5;
            Sound.playSound('button');
          } 
          else a.cd=0.4;
        } else {
          a.cd = 0.3;
        }
      } 
    }

    // çŸ¢
    for (const ar of arrows){ 
      ar.x += ar.vx*dt; 
      ar.y += ar.vy*dt; 
      ar.life-=dt; 
      if (collidesTile(ar.x,ar.y,6,2)) ar.life=0; 
      if (ar.life<=0) ar.dead=true; 
      if (dist2(ar.x,ar.y,player.x,player.y)<12*12){ 
        ar.dead=true; 
        hitPlayer(1);
      } 
    }

    // çˆ†å¼¾
    for (const b of bombs){ 
      b.t-=dt; 
      if (!b.exploded && b.t<=0){ 
        b.exploded = true; 
        blasts.push(new Explosion(b.x,b.y)); 
        Sound.playSound('bomb');
        
        const hitRect = (e) => Math.abs(e.x-b.x)<TS*1.5 && Math.abs(e.y-b.y)<8 || Math.abs(e.y-b.y)<TS*1.5 && Math.abs(e.x-b.x)<8;
        for (const s of slimes){ 
          if (!s.dead && hitRect(s)){ 
            s.dead=true; 
            state.coins+=3; 
            gainExp(2);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚¹ãƒ©ã‚¤ãƒ æ’ƒç ´!'); 
          } 
        }
        for (const a of archers){ 
          if (!a.dead && hitRect(a)){ 
            a.dead=true; 
            state.coins+=5; 
            gainExp(3);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚¢ãƒ¼ãƒãƒ£ãƒ¼æ’ƒç ´!'); 
          } 
        }
        if (hitRect(player)) hitPlayer(2);
      } 
    }
    
    // å¾Œç‰‡ä»˜ã‘
    for (let i=bombs.length-1;i>=0;i--){ 
      if (bombs[i].exploded && bombs[i].t<=-0.3) bombs.splice(i,1); 
    }
    for (const ex of blasts){ ex.t-=dt; }
    for (let i=arrows.length-1;i>=0;i--) if (arrows[i].dead) arrows.splice(i,1);
    for (let i=blasts.length-1;i>=0;i--) if (blasts[i].t<=0) blasts.splice(i,1);

    // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«
    tutorialTick(dt, { 
      moved: (Math.abs(Input.ax)+Math.abs(Input.ay))>0.5, 
      attacked: Input.aDown, 
      opened: (Input.bDown && canOpen), 
      talked: (Input.bDown && canTalk)
    });

    // UIæ›´æ–°
    renderHUD(); 
    if (state.hintTimer > 0) {
      state.hintTimer -= dt;
      if (state.hintTimer <= 0) hintEl.classList.remove('show');
    }
  }

  // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
  let acc = 0; 
  const FIXED = 1/60; 
  let last = performance.now();
  
  function loop(){
    const t = performance.now(); 
    let dt = (t - last)/1000; 
    last = t; 
    dt = Math.min(dt, 0.05);

    if (!state.paused){
      acc += dt; 
      while (acc >= FIXED){ 
        Input.updateEdges(); 
        update(FIXED); 
        acc -= FIXED; 
        Input.aDown=Input.bDown=Input.xDown=false; 
      }
      draw();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«
  const tut = document.getElementById('tutorial');
  const tutContent = document.getElementById('tutContent');
  const tutNext = document.getElementById('tutNext');
  const tutSkip = document.getElementById('tutSkip');
  
  const steps = [
    { text: 'ğŸ® å·¦ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‹çŸ¢å°ã‚­ãƒ¼ã§æ­©ã„ã¦ã¿ã¾ã—ã‚‡ã†ï¼', check: s=> s.moved },
    { text: 'âš”ï¸ âš”ï¸ãƒœã‚¿ãƒ³ã§æ”»æ’ƒï¼ã‚¹ãƒ©ã‚¤ãƒ ã‚’å€’ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚', check: s=> s.attacked },
    { text: 'ğŸ’¬ ğŸ’¬ãƒœã‚¿ãƒ³ã§å®ç®±ã‚’é–‹ã‘ãŸã‚Šã€é­”æ³•ä½¿ã„ã¨è©±ã—ãŸã‚Šã§ãã¾ã™ã€‚', check: s=> s.opened || s.talked },
    { text: 'ğŸ’£ ğŸ’£ãƒœã‚¿ãƒ³ã§çˆ†å¼¾ã‚’è¨­ç½®ï¼æ•µã‚’ã¾ã¨ã‚ã¦å€’ã›ã¾ã™ã€‚ã•ã‚å†’é™ºã—ã‚ˆã†ï¼', check: s=> true },
  ];
  
  function tutorialOpen(){ 
    state.tutorialStep = 0; 
    tut.showModal(); 
    renderStep(); 
  }
  
  function renderStep(){ 
    tutContent.innerHTML = `<p>${steps[state.tutorialStep].text}</p>`; 
  }
  
  function tutorialTick(dt, flags){
    const st = steps[state.tutorialStep]; 
    if (!st) return; 
    if (st.check(flags)) nextStep();
  }
  
  function nextStep(){ 
    state.tutorialStep++; 
    if (state.tutorialStep >= steps.length){ 
      tut.close(); 
      showHint('ğŸŒŸ å†’é™ºã‚’æ¥½ã—ã‚“ã§ã­ï¼', 4.0); 
      Sound.playSound('level');
    } else { 
      renderStep(); 
    } 
  }
  
  tutNext.addEventListener('click', ()=> { nextStep(); Sound.playSound('button'); });
  tutSkip.addEventListener('click', ()=> { tut.close(); Sound.playSound('button'); });
  setTimeout(tutorialOpen, 800);

  // ãƒãƒ¼ã‚º
  const pause = document.getElementById('pause');
  const btnPause = document.getElementById('btnPause');
  const btnClose = document.getElementById('btnClose');

  function togglePause(){
    state.paused = !state.paused;
    if (state.paused){ pause.showModal(); } else { pause.close(); }
  }

  btnPause.addEventListener('click', ()=> { togglePause(); Sound.playSound('button'); });
  btnClose.addEventListener('click', ()=> { togglePause(); Sound.playSound('button'); });

  // åˆæœŸåŒ–
  renderHUD();
  showHint('ğŸ® ç§»å‹•ã—ã¦ã¿ã‚ˆã†', 3);

})();
</script>
</body>
</html>
