<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>ã¼ã†ã‘ã‚“RPG - å‹‡è€…ã®æ—…ç«‹ã¡</title>
<style>
  :root {
    --bg: #0b0c10;
    --panel: rgba(255,255,255,0.06);
    --panel-strong: rgba(255,255,255,0.12);
    --outline: rgba(255,255,255,0.24);
    --text: #eef2f6;
    --muted: #aab2bf;
    --accent: #8bd3ff;
    --danger: #ff6b6b;
    --gold: #ffd56c;
    --btn-size: 64px;
    --font-scale: 1;
  }

  html, body { height: 100%; margin: 0; }
  body {
    font-family: ui-sans-serif, system-ui, sans-serif;
    color: var(--text);
    background: radial-gradient(1200px 800px at 50% 10%, #141720, #0b0c10 60%);
    overflow: hidden;
    -webkit-user-select: none; user-select: none;
    touch-action: none;
  }

  #root {
    position: fixed; inset: 0;
    display: grid; place-items: center;
  }

  .stage {
    position: relative;
    width: min(100vw, 100vh * 16/9);
    height: min(100vh, 100vw * 9/16);
    border-radius: 16px;
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.3));
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.08);
    overflow: hidden;
  }

  #game {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    background: #151821;
  }

  .hud { 
    position:absolute; inset:0; pointer-events:none; 
    font-size: calc(14px * var(--font-scale)); 
  }

  .hud-top { 
    position:absolute; top: 8px; left:8px; right:8px; 
    display:flex; align-items:flex-start; justify-content:space-between; gap:8px; 
  }

  .hud-right {
    position: absolute;
    top: 8px;
    right: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: flex-end;
  }

  .hearts { 
    display:flex; 
    gap:4px; 
    background: var(--panel); 
    border:1px solid var(--outline); 
    padding:8px 12px; 
    border-radius:12px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  .heart { 
    width:24px; height:24px; 
    background: #ff4364;
    clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    animation: heartbeat 1.5s ease-in-out infinite;
  }
  .heart.empty { 
    background: #666; 
    filter: grayscale(1) brightness(0.6);
    animation: none;
  }
  
  @keyframes heartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }

  .counter { 
    pointer-events:auto; 
    display:flex; align-items:center; gap:8px; 
    background: var(--panel); 
    border:1px solid var(--outline); 
    padding:8px 12px; border-radius: 999px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  
  .coin { 
    width:20px; height:20px; border-radius:50%; 
    background: radial-gradient(circle at 35% 35%, #fff7bf, var(--gold)); 
    border:2px solid #b8860b; 
    box-shadow: inset 0 0 4px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.2);
    animation: coinSpin 3s linear infinite;
  }
  
  @keyframes coinSpin {
    0%, 100% { transform: rotateY(0deg); }
    50% { transform: rotateY(180deg); }
  }

  .btn-ghost { 
    pointer-events:auto; 
    background: var(--panel); border:1px solid var(--outline); 
    color: var(--text); padding:8px 12px; border-radius:12px; 
    font-weight:700; box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    transition: all 0.2s ease; cursor: pointer;
  }
  .btn-ghost:active { transform: scale(0.96); }

  .hint { 
    position:absolute; left:50%; transform: translateX(-50%); 
    bottom: 68px; background: var(--panel); 
    border:1px solid var(--outline); padding:8px 12px; 
    border-radius:12px; opacity:0; transition: opacity .2s ease;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  .hint.show { opacity: 1; }

  .virtual { position:absolute; inset:0; pointer-events:none; }
  
  .stick { 
    position:absolute; left: 10px; bottom: 10px; 
    width: 160px; height: 160px; pointer-events:auto; 
  }
  .stick .base { 
    position:absolute; inset: 0; border-radius:50%; 
    background: var(--panel); border: 2px solid var(--outline);
    box-shadow: inset 0 4px 8px rgba(0,0,0,0.3), 0 4px 12px rgba(0,0,0,0.2);
  }
  .stick .knob { 
    --k: calc(var(--btn-size) * 0.75); 
    position:absolute; left: 50%; top: 50%; 
    width: var(--k); height: var(--k); 
    transform: translate(-50%,-50%); border-radius: 50%; 
    background: linear-gradient(135deg, var(--panel-strong), var(--panel)); 
    border: 2px solid var(--outline); 
    box-shadow: 0 4px 8px rgba(0,0,0,0.35);
  }

  .buttons { 
    position:absolute; right: 10px; bottom: 10px; 
    display:grid; grid-template-areas: ". x" "b a"; 
    gap: 12px; pointer-events:auto; 
  }
  
  .btn { 
    width: var(--btn-size); height: var(--btn-size); 
    border-radius: 50%; 
    background: linear-gradient(135deg, var(--panel-strong), var(--panel)); 
    border:2px solid var(--outline); 
    display:grid; place-items:center; 
    font-weight: 800; font-size: calc(16px * var(--font-scale));
    box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    transition: all 0.2s ease; cursor: pointer;
  }
  .btn:active { 
    transform: scale(0.92); 
    box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  }
  .btn.a { grid-area: a; background: linear-gradient(135deg, #ff6b6b, #e74c3c); color: white; }
  .btn.b { grid-area: b; background: linear-gradient(135deg, #4ecdc4, #45b7b8); color: white; }
  .btn.x { grid-area: x; background: linear-gradient(135deg, #f39c12, #e67e22); color: white; }

  dialog { border: none; padding: 0; background: transparent; }
  .sheet { 
    width: min(92vw, 480px); 
    background: rgba(18,20,28,0.9); backdrop-filter: blur(8px); 
    border: 1px solid var(--outline); color: var(--text); 
    border-radius: 16px; overflow: hidden;
    box-shadow: 0 20px 40px rgba(0,0,0,0.5);
  }
  .sheet header { 
    padding: 16px 20px; font-weight: 800; 
    border-bottom: 1px solid var(--outline);
    background: var(--panel); font-size: calc(18px * var(--font-scale));
  }
  .sheet .content { padding: 16px 20px; }
  .sheet .actions { 
    padding: 16px 20px; display:flex; gap: 12px; 
    justify-content:flex-end; border-top: 1px solid var(--outline);
    background: var(--panel);
  }

  .level-up {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: calc(24px * var(--font-scale));
    font-weight: 800; color: var(--gold);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    opacity: 0; pointer-events: none;
  }

  @keyframes levelUpAnim {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    80% { opacity: 1; transform: translate(-50%, -60%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
  }

  .speech-bubble {
    position: absolute;
    background: rgba(255, 255, 255, 0.95);
    color: #1a1a1a;
    padding: 18px 24px;
    border-radius: 18px;
    font-size: calc(18px * var(--font-scale));
    font-weight: 500;
    line-height: 1.4;
    max-width: 300px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    border: 2px solid rgba(0,0,0,0.1);
    pointer-events: none;
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.3s ease, transform 0.3s ease;
    z-index: 1000;
    white-space: pre-line;
    text-align: left;
  }

  .speech-bubble.show {
    opacity: 1;
    transform: translateY(0);
  }

  .speech-bubble::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 20px;
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid rgba(255, 255, 255, 0.95);
  }

  .minimap {
    position: absolute;
    top: 8px;
    left: 8px;
    width: 150px;
    height: 150px;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid var(--outline);
    border-radius: 8px;
    pointer-events: none;
    z-index: 100;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }

  .minimap canvas {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
  }
</style>
</head>
<body>
  <div id="root">
    <div class="stage">
      <canvas id="game" width="320" height="180"></canvas>

      <div class="hud">
        <div class="minimap">
          <canvas id="minimap" width="150" height="150"></canvas>
        </div>
        <div class="hud-right">
          <div class="hearts" id="hearts"></div>
          <div style="display:flex; flex-direction:column; gap:8px; align-items:flex-end;">
            <div class="counter">
              <div class="coin"></div>
              <span id="coins">0</span>
            </div>
            <div class="counter" style="background: linear-gradient(135deg, var(--panel), rgba(139,211,255,0.1));">
              <span style="color: var(--accent); font-weight: 800;">Lv</span>
              <span id="level">1</span>
            </div>
            <button class="btn-ghost" id="btnPause">âš™ï¸</button>
          </div>
        </div>
        <div class="hint" id="hint">ğŸ® ç§»å‹•ã—ã¦ã¿ã‚ˆã†</div>
        <div class="level-up" id="levelUp" style="display: none;">ğŸŒŸ LEVEL UP! ğŸŒŸ</div>
        <div class="speech-bubble" id="speechBubble"></div>
      </div>

      <div class="virtual">
        <div class="stick" id="stick">
          <div class="base"></div>
          <div class="knob" id="stickKnob"></div>
        </div>
        <div class="buttons">
          <button class="btn a" id="btnA">âš”ï¸</button>
          <button class="btn b" id="btnB">ğŸ’¬</button>
          <button class="btn x" id="btnX">ğŸ’£</button>
        </div>
      </div>

      <dialog id="tutorial">
        <div class="sheet">
          <header>ğŸ® ã¼ã†ã‘ã‚“ã®å§‹ã¾ã‚Š</header>
          <div class="content" id="tutContent">
            <p>ã‚ˆã†ã“ãã€å‹‡è€…ã•ã‚“ï¼ã¾ãšã¯æ­©ã„ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
          </div>
          <div class="actions">
            <button class="btn-ghost" id="tutSkip">ã‚¹ã‚­ãƒƒãƒ—</button>
            <button class="btn-ghost" id="tutNext">æ¬¡ã¸ â¡ï¸</button>
          </div>
        </div>
      </dialog>

      <dialog id="pause">
        <div class="sheet">
          <header>âš™ï¸ è¨­å®š</header>
          <div class="content">
            <p style="margin: 0;">âš”ï¸ = æ”»æ’ƒ / ğŸ’¬ = ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ / ğŸ’£ = çˆ†å¼¾</p>
          </div>
          <div class="actions">
            <button class="btn-ghost" id="btnClose">é–‰ã˜ã‚‹</button>
          </div>
        </div>
      </dialog>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (x1,y1,x2,y2) => { const dx = x2-x1, dy = y2-y1; return dx*dx+dy*dy; };

  // ã‚­ãƒ£ãƒ³ãƒã‚¹
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = 320, H = 180;

  // å®‰å…¨ãªå®šæ•°
  const TS = 16;
  const COLS = 20; // 320/16 = 20
  const ROWS = 11; // 180/16 = 11.25 -> 11
  const T = { GRASS:0, TREE:1, WATER:2, TALL:3, PATH:4, FLOWER:5, ROCK:6, SAND:7, CACTUS:8, SNOW:9, DESERT:10, ICE:11 };

  // ãƒãƒƒãƒ—ç”Ÿæˆé–¢æ•°
  function generateMap(type) {
    const map = [];
    for(let y = 0; y < ROWS; y++) {
      map[y] = [];
      for(let x = 0; x < COLS; x++) {
        map[y][x] = T.GRASS;
      }
    }

    switch(type) {
      case 'village': // ä¸­å¤®ï¼šæ‘ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
        // ãƒ‘ã‚¹
        for(let y = 3; y < 8 && y < ROWS; y++) {
          for(let x = 4; x < 16 && x < COLS; x++) {
            map[y][x] = T.PATH;
          }
        }
        // æœ¨
        for(let i = 0; i < 30; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        // æ°´
        for(let i = 0; i < 10; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.WATER;
          }
        }
        // èŠ±
        for(let i = 0; i < 15; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.FLOWER;
          }
        }
        break;

      case 'forest': // ä¸Šï¼šæ£®ã®ã‚¨ãƒªã‚¢
        // æœ¨ã‚’å¤šãé…ç½®
        for(let i = 0; i < 50; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        // ãƒ‘ã‚¹ã‚’å°‘ã—
        for(let y = 5; y < 6 && y < ROWS; y++) {
          for(let x = 2; x < 18 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // èŠ±ã‚’å°‘ã—
        for(let i = 0; i < 8; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.FLOWER;
          }
        }
        break;

      case 'coast': // ä¸‹ï¼šæµ·å²¸ã®ã‚¨ãƒªã‚¢
        // ä¸‹å´ã«æ°´ã‚’å¤šãé…ç½®
        for(let y = 7; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (Math.random() > 0.3) {
              map[y][x] = T.WATER;
            }
          }
        }
        // ç ‚æµœ
        for(let y = 5; y < 7 && y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.SAND;
            }
          }
        }
        // ãƒ‘ã‚¹
        for(let y = 2; y < 5 && y < ROWS; y++) {
          for(let x = 3; x < 17 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // æœ¨ã‚’å°‘ã—
        for(let i = 0; i < 15; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * 5);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        break;

      case 'cave': // å·¦ï¼šæ´çªŸã®ã‚¨ãƒªã‚¢
        // å²©ã‚’å¤šãé…ç½®
        for(let i = 0; i < 40; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.ROCK;
          }
        }
        // æ°´ï¼ˆæ´çªŸã®æ°´ãŸã¾ã‚Šï¼‰
        for(let i = 0; i < 15; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.WATER;
          }
        }
        // ãƒ‘ã‚¹
        for(let y = 4; y < 7 && y < ROWS; y++) {
          for(let x = 5; x < 15 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        break;

      case 'field': // å³ï¼šè‰åŸã®ã‚¨ãƒªã‚¢
        // èŠ±ã‚’å¤šãé…ç½®
        for(let i = 0; i < 30; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.FLOWER;
          }
        }
        // ãƒ‘ã‚¹
        for(let y = 3; y < 8 && y < ROWS; y++) {
          for(let x = 2; x < 18 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // æœ¨ã‚’å°‘ã—
        for(let i = 0; i < 10; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        break;

      case 'ruins': // åŒ—è¥¿ï¼šå»ƒå¢Ÿã®ã‚¨ãƒªã‚¢ï¼ˆæ£®ã¨æ´çªŸã®é–“ï¼‰
        // å²©ã‚’å¤šãé…ç½®ï¼ˆå»ƒå¢Ÿã®çŸ³ï¼‰
        for(let i = 0; i < 35; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.ROCK;
          }
        }
        // ä¸­å¤®ã«å¤§ããªéºè·¡ã‚¨ãƒªã‚¢
        for(let y = 4; y < 7 && y < ROWS; y++) {
          for(let x = 6; x < 14 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.ROCK;
            }
          }
        }
        // ãƒ‘ã‚¹ï¼ˆéºè·¡ã¸ã®é“ï¼‰
        for(let y = 2; y < 9 && y < ROWS; y++) {
          for(let x = 8; x < 12 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // æœ¨ã‚’å°‘ã—ï¼ˆæ£®ã®åæ®‹ï¼‰
        for(let i = 0; i < 8; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        break;

      case 'garden': // åŒ—æ±ï¼šèŠ±ç•‘ã®ã‚¨ãƒªã‚¢ï¼ˆæ£®ã¨è‰åŸã®é–“ï¼‰
        // èŠ±ã‚’å¤§é‡ã«é…ç½®
        for(let i = 0; i < 50; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.FLOWER;
          }
        }
        // ãƒ‘ã‚¹ï¼ˆèŠ±ç•‘ã®ä¸­ã®å°é“ï¼‰
        for(let y = 4; y < 7 && y < ROWS; y++) {
          for(let x = 3; x < 17 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // æœ¨ã‚’å°‘ã—ï¼ˆç¸ã«ï¼‰
        for(let i = 0; i < 5; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * 3);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        for(let i = 0; i < 5; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * 3) + 8;
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        break;

      case 'cavecoast': // å—è¥¿ï¼šæµ·å²¸æ´çªŸã®ã‚¨ãƒªã‚¢ï¼ˆæµ·å²¸ã¨æ´çªŸã®é–“ï¼‰
        // å·¦å´ã«æ´çªŸé¢¨ã€å³å´ã«æµ·å²¸é¢¨
        // å·¦å´ã«å²©ã‚’é…ç½®
        for(let i = 0; i < 25; i++){
          const x = Math.floor(Math.random() * 10);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.ROCK;
          }
        }
        // å³å´ã«æ°´ã‚’é…ç½®
        for(let i = 0; i < 15; i++){
          const x = Math.floor(Math.random() * 10) + 10;
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.WATER;
          }
        }
        // ä¸‹å´ã«ç ‚æµœ
        for(let y = 8; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.SAND;
            }
          }
        }
        // ä¸­å¤®ã«ãƒ‘ã‚¹
        for(let y = 3; y < 8 && y < ROWS; y++) {
          for(let x = 8; x < 12 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        break;

      case 'beach': // å—æ±ï¼šãƒ“ãƒ¼ãƒã®ã‚¨ãƒªã‚¢ï¼ˆæµ·å²¸ã¨è‰åŸã®é–“ï¼‰
        // ç ‚æµœã‚’å¤šãé…ç½®
        for(let y = 0; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS && Math.random() > 0.3) {
              map[y][x] = T.SAND;
            }
          }
        }
        // ä¸‹å´ã«æ°´
        for(let y = 7; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.SAND && Math.random() > 0.5) {
              map[y][x] = T.WATER;
            }
          }
        }
        // ãƒ‘ã‚¹ï¼ˆãƒ“ãƒ¼ãƒæ²¿ã„ï¼‰
        for(let y = 2; y < 6 && y < ROWS; y++) {
          for(let x = 2; x < 18 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.SAND) {
              map[y][x] = T.PATH;
            }
          }
        }
        // èŠ±ã‚’å°‘ã—ï¼ˆãƒ“ãƒ¼ãƒã®è£…é£¾ï¼‰
        for(let i = 0; i < 10; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * 6);
          if (map[y] && map[y][x] === T.SAND) {
            map[y][x] = T.FLOWER;
          }
        }
        break;

      case 'cactus': // åŒ—æ±æ–¹å‘ï¼šã‚µãƒœãƒ†ãƒ³ã€é™½æ°—ãªä¸–ç•Œ
        // ã‚µãƒœãƒ†ãƒ³ã‚’å¤šãé…ç½®
        for(let i = 0; i < 40; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.CACTUS;
          }
        }
        // ãƒ‘ã‚¹ï¼ˆé™½æ°—ãªé“ï¼‰
        for(let y = 4; y < 7 && y < ROWS; y++) {
          for(let x = 3; x < 17 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // èŠ±ã‚’å°‘ã—ï¼ˆæ˜ã‚‹ã„é›°å›²æ°—ï¼‰
        for(let i = 0; i < 20; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.FLOWER;
          }
        }
        break;

      case 'snow': // åŒ—è¥¿æ–¹å‘ï¼šé›ªã€æ£®æ—åœ°å¸¯ã€å±±
        // é›ªã‚’å¤šãé…ç½®
        for(let y = 0; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS && Math.random() > 0.2) {
              map[y][x] = T.SNOW;
            }
          }
        }
        // å±±ï¼ˆå²©ï¼‰ã‚’é…ç½®
        for(let i = 0; i < 30; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.SNOW) {
            map[y][x] = T.ROCK;
          }
        }
        // æ£®ï¼ˆæœ¨ï¼‰ã‚’é…ç½®
        for(let i = 0; i < 25; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.SNOW) {
            map[y][x] = T.TREE;
          }
        }
        // ãƒ‘ã‚¹
        for(let y = 5; y < 6 && y < ROWS; y++) {
          for(let x = 2; x < 18 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.SNOW) {
              map[y][x] = T.PATH;
            }
          }
        }
        break;

      case 'desert': // å—è¥¿æ–¹å‘ï¼šç ‚æ¼ ã¨æ´çªŸ
        // ç ‚æ¼ ã‚’å¤šãé…ç½®
        for(let y = 0; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS && Math.random() > 0.3) {
              map[y][x] = T.DESERT;
            }
          }
        }
        // æ´çªŸï¼ˆå²©ï¼‰ã‚’é…ç½®
        for(let i = 0; i < 35; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.DESERT) {
            map[y][x] = T.ROCK;
          }
        }
        // ã‚µãƒœãƒ†ãƒ³ã‚’å°‘ã—
        for(let i = 0; i < 15; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.DESERT) {
            map[y][x] = T.CACTUS;
          }
        }
        // ãƒ‘ã‚¹
        for(let y = 4; y < 7 && y < ROWS; y++) {
          for(let x = 5; x < 15 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.DESERT) {
              map[y][x] = T.PATH;
            }
          }
        }
        break;

      case 'ocean': // å—æ±æ–¹å‘ï¼šæ°´ã¨å³¶ã€æµ·æ´‹
        // æ°´ã‚’å¤šãé…ç½®
        for(let y = 0; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS && Math.random() > 0.4) {
              map[y][x] = T.WATER;
            }
          }
        }
        // å³¶ï¼ˆè‰ï¼‰ã‚’é…ç½®
        for(let i = 0; i < 8; i++){
          const islandX = Math.floor(Math.random() * (COLS - 6)) + 3;
          const islandY = Math.floor(Math.random() * (ROWS - 6)) + 3;
          for(let y = islandY - 2; y < islandY + 3 && y < ROWS; y++) {
            for(let x = islandX - 2; x < islandX + 3 && x < COLS; x++) {
              if (map[y] && map[y][x] === T.WATER && Math.random() > 0.3) {
                map[y][x] = T.GRASS;
              }
            }
          }
        }
        // å³¶ã«æœ¨ã‚’é…ç½®
        for(let i = 0; i < 15; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        // ãƒ‘ã‚¹ï¼ˆæ©‹ã®ã‚ˆã†ãªï¼‰
        for(let y = 2; y < 9 && y < ROWS; y++) {
          for(let x = 9; x < 11 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.WATER) {
              map[y][x] = T.PATH;
            }
          }
        }
        break;
    }

    return map;
  }

  // ãƒãƒƒãƒ—ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
  const maps = new Map();
  let currentMapX = 0, currentMapY = 0;
  const visitedMaps = new Set(); // è¨ªå•ã—ãŸãƒãƒƒãƒ—ã‚’è¨˜éŒ²
  
  function getMapKey(x, y) {
    return `${x},${y}`;
  }
  
  function markMapVisited(x, y) {
    visitedMaps.add(getMapKey(x, y));
  }
  
  function isMapVisited(x, y) {
    return visitedMaps.has(getMapKey(x, y));
  }
  
  function getCurrentMap() {
    const key = getMapKey(currentMapX, currentMapY);
    if (!maps.has(key)) {
      let mapType = 'village';
      // æ—¢å­˜ã®ãƒãƒƒãƒ—
      if (currentMapX === 0 && currentMapY === -1) mapType = 'forest';
      else if (currentMapX === 0 && currentMapY === 1) mapType = 'coast';
      else if (currentMapX === -1 && currentMapY === 0) mapType = 'cave';
      else if (currentMapX === 1 && currentMapY === 0) mapType = 'field';
      else if (currentMapX === -1 && currentMapY === -1) mapType = 'ruins';
      else if (currentMapX === 1 && currentMapY === -1) mapType = 'garden';
      else if (currentMapX === -1 && currentMapY === 1) mapType = 'cavecoast';
      else if (currentMapX === 1 && currentMapY === 1) mapType = 'beach';
      // æ–°ã—ã„ãƒãƒƒãƒ—ï¼šåŒ—æ±æ–¹å‘ï¼ˆã‚µãƒœãƒ†ãƒ³ã€é™½æ°—ãªä¸–ç•Œï¼‰
      else if (currentMapX >= 2 || (currentMapX > 0 && currentMapY <= -2)) mapType = 'cactus';
      // æ–°ã—ã„ãƒãƒƒãƒ—ï¼šåŒ—è¥¿æ–¹å‘ï¼ˆé›ªã€æ£®æ—åœ°å¸¯ã€å±±ï¼‰
      else if (currentMapX <= -2 || (currentMapX < 0 && currentMapY <= -2)) mapType = 'snow';
      // æ–°ã—ã„ãƒãƒƒãƒ—ï¼šå—è¥¿æ–¹å‘ï¼ˆç ‚æ¼ ã¨æ´çªŸï¼‰
      else if (currentMapX <= -2 || (currentMapX < 0 && currentMapY >= 2)) mapType = 'desert';
      // æ–°ã—ã„ãƒãƒƒãƒ—ï¼šå—æ±æ–¹å‘ï¼ˆæ°´ã¨å³¶ã€æµ·æ´‹ï¼‰
      else if (currentMapX >= 2 || (currentMapX > 0 && currentMapY >= 2)) mapType = 'ocean';
      // ãã®ä»–ã®å¢ƒç•Œã‚¨ãƒªã‚¢
      else if (currentMapY <= -2) {
        if (currentMapX < 0) mapType = 'snow';
        else mapType = 'cactus';
      } else if (currentMapY >= 2) {
        if (currentMapX < 0) mapType = 'desert';
        else mapType = 'ocean';
      } else if (currentMapX <= -2) {
        if (currentMapY < 0) mapType = 'snow';
        else mapType = 'desert';
      } else if (currentMapX >= 2) {
        if (currentMapY < 0) mapType = 'cactus';
        else mapType = 'ocean';
      }
      maps.set(key, generateMap(mapType));
    }
    return maps.get(key);
  }

  const isBlock = (t) => t === T.TREE || t === T.WATER || t === T.ROCK || t === T.CACTUS || t === T.ICE;

  // ã‚µã‚¦ãƒ³ãƒ‰
  const Sound = (() => {
    let audioContext = null;
    let unlocked = false;
    
    const unlock = () => { 
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioContext.state === 'suspended') audioContext.resume(); 
        unlocked = true; 
      } catch(e) {
        console.log('Audio not supported');
      }
    };

    const playSound = (type) => {
      if (!unlocked || !audioContext) return;
      
      try {
        const beep = (f, t, waveType='square', g=0.04) => {
          const o = audioContext.createOscillator();
          const v = audioContext.createGain();
          o.type = waveType; 
          o.frequency.value = f;
          v.gain.value = g; 
          o.connect(v); 
          v.connect(audioContext.destination);
          const t0 = audioContext.currentTime;
          o.start(t0); 
          o.stop(t0 + t);
        };

        switch(type) {
          case 'sword': beep(880, 0.05); setTimeout(() => beep(660, 0.08), 50); break;
          case 'hit': beep(150, 0.15, 'sawtooth', 0.08); break;
          case 'coin': beep(659, 0.3, 'sine', 0.05); break;
          case 'chest': beep(523, 0.4, 'triangle', 0.06); break;
          case 'bomb': beep(80, 0.2, 'square', 0.12); break;
          case 'talk': beep(523, 0.2, 'triangle', 0.04); break;
          case 'level': 
            for(let i = 0; i < 5; i++) {
              setTimeout(() => beep(523 + i*100, 0.15, 'sine', 0.05), i * 100);
            }
            break;
          case 'button': beep(440, 0.05, 'square', 0.02); break;
        }
      } catch(e) {
        console.log('Audio error:', e);
      }
    };

    return { unlock, playSound, get unlocked() { return unlocked; } };
  })();

  // åˆå›ã‚¯ãƒªãƒƒã‚¯ã§ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè§£ç¦
  const unlockAudio = () => {
    Sound.unlock();
    window.removeEventListener('pointerdown', unlockAudio);
  };
  window.addEventListener('pointerdown', unlockAudio);

  // å…¥åŠ›
  const Input = {
    ax: 0, ay: 0,
    a: false, b: false, x: false,
    aDown: false, bDown: false, xDown: false,
    updateEdges() {
      this.aDown = this.a && !this._pa; this._pa = this.a;
      this.bDown = this.b && !this._pb; this._pb = this.b;
      this.xDown = this.x && !this._px; this._px = this.x;
    },
  };

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰
  window.addEventListener('keydown', (e) => {
    switch(e.key){
      case 'ArrowLeft': Input.ax = -1; break;
      case 'ArrowRight': Input.ax = 1; break;
      case 'ArrowUp': Input.ay = -1; break;
      case 'ArrowDown': Input.ay = 1; break;
      case ' ': case 'j': Input.a = true; break;
      case 'k': case 'z': Input.b = true; break;
      case 'x': Input.x = true; break;
      case 'Escape': togglePause(); break;
    }
    e.preventDefault();
  });
  
  window.addEventListener('keyup', (e) => {
    switch(e.key){
      case 'ArrowLeft': if (Input.ax<0) Input.ax = 0; break;
      case 'ArrowRight': if (Input.ax>0) Input.ax = 0; break;
      case 'ArrowUp': if (Input.ay<0) Input.ay = 0; break;
      case 'ArrowDown': if (Input.ay>0) Input.ay = 0; break;
      case ' ': case 'j': Input.a = false; break;
      case 'k': case 'z': Input.b = false; break;
      case 'x': Input.x = false; break;
    }
  });

  // ã‚¿ãƒƒãƒ
  const stick = document.getElementById('stick');
  const stickKnob = document.getElementById('stickKnob');
  let stickId = null, stickCenter = {x:0,y:0};
  const R = 56;

  const setKnob = (dx,dy) => stickKnob.style.transform = `translate(${dx}px, ${dy}px)`;

  stick.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    stickId = e.pointerId;
    stickCenter.x = e.clientX;
    stickCenter.y = e.clientY;
  });

  window.addEventListener('pointermove', (e) => {
    if (e.pointerId === stickId) {
      const dx = e.clientX - stickCenter.x;
      const dy = e.clientY - stickCenter.y;
      const len = Math.hypot(dx,dy) || 1;
      const cl = Math.min(len, R);
      const nx = dx/len, ny = dy/len;
      const kx = nx*cl, ky = ny*cl;
      setKnob(kx, ky);
      Input.ax = (cl/R)*nx;
      Input.ay = (cl/R)*ny;
      e.preventDefault();
    }
  });

  window.addEventListener('pointerup', (e) => {
    if (e.pointerId === stickId) {
      stickId = null;
      setKnob(0, 0);
      Input.ax = 0;
      Input.ay = 0;
    }
  });

  // ãƒœã‚¿ãƒ³
  const btnA = document.getElementById('btnA');
  const btnB = document.getElementById('btnB');
  const btnX = document.getElementById('btnX');

  const pressBtn = (key) => (e) => {
    e.preventDefault();
    Input[key] = true;
    Sound.playSound('button');
  };
  const releaseBtn = (key) => (e) => {
    e.preventDefault();
    Input[key] = false;
  };

  btnA.addEventListener('pointerdown', pressBtn('a'));
  btnA.addEventListener('pointerup', releaseBtn('a'));
  btnB.addEventListener('pointerdown', pressBtn('b'));
  btnB.addEventListener('pointerup', releaseBtn('b'));
  btnX.addEventListener('pointerdown', pressBtn('x'));
  btnX.addEventListener('pointerup', releaseBtn('x'));

  // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
  const state = {
    coins: 0,
    hp: 5, maxHp: 5,
    level: 1, exp: 0, expToNext: 10,
    tutorialStep: 0,
    paused: false,
    hintTimer: 0,
  };

  // HUDè¦ç´ 
  const heartEl = document.getElementById('hearts');
  const coinsEl = document.getElementById('coins');
  const levelEl = document.getElementById('level');
  const hintEl = document.getElementById('hint');
  const levelUpEl = document.getElementById('levelUp');
  const speechBubbleEl = document.getElementById('speechBubble');
  const minimapCanvas = document.getElementById('minimap');
  const minimapCtx = minimapCanvas.getContext('2d');

  function renderHUD(){
    heartEl.innerHTML = '';
    for (let i=0;i<state.maxHp;i++){
      const d = document.createElement('div');
      d.className = 'heart' + (i >= state.hp? ' empty':'');
      heartEl.appendChild(d);
    }
    coinsEl.textContent = state.coins;
    levelEl.textContent = state.level;
  }

  function showHint(txt, secs=1.5){
    state.hintTimer = secs;
    hintEl.textContent = txt;
    hintEl.classList.add('show');
  }

  let speechBubbleTimer = 0;
  function showSpeechBubble(npc, text) {
    speechBubbleEl.textContent = text;
    speechBubbleEl.classList.add('show');
    
    // NPCã®ä½ç½®ã«å¹ãå‡ºã—ã‚’é…ç½®
    const canvasRect = canvas.getBoundingClientRect();
    const stageRect = document.querySelector('.stage').getBoundingClientRect();
    const scaleX = stageRect.width / W;
    const scaleY = stageRect.height / H;
    
    const bubbleX = (npc.x * scaleX) + stageRect.left;
    // å¹ãå‡ºã—ã®ä¸‹ã®è¾ºãŒNPCã®ã‚¢ã‚¤ã‚³ãƒ³ã®ä¸­å¤®ï¼ˆyä½ç½®ï¼‰ã«æ¥ã‚‹ã‚ˆã†ã«èª¿æ•´
    // ã¾ãšä¸€æ™‚çš„ã«é…ç½®ã—ã¦é«˜ã•ã‚’å–å¾—
    speechBubbleEl.style.left = `${bubbleX}px`;
    speechBubbleEl.style.top = '0px';
    speechBubbleEl.style.transform = 'translateX(-50%)';
    
    // å¹ãå‡ºã—ã®å®Ÿéš›ã®é«˜ã•ã‚’å–å¾—
    const bubbleHeight = speechBubbleEl.offsetHeight;
    // NPCã®yä½ç½®ï¼ˆã‚¢ã‚¤ã‚³ãƒ³ã®ä¸­å¤®ï¼‰ã«å¹ãå‡ºã—ã®ä¸‹ã®è¾ºãŒæ¥ã‚‹ã‚ˆã†ã«
    // ã•ã‚‰ã«ä¸Šã«é…ç½®ã™ã‚‹ãŸã‚ã€è¿½åŠ ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å¼•ã
    const additionalOffset = 35; // è¿½åŠ ã§ä¸Šã«35px
    const bubbleY = (npc.y * scaleY) + stageRect.top - bubbleHeight - additionalOffset;
    
    speechBubbleEl.style.top = `${bubbleY}px`;
    
    // 3ç§’å¾Œã«è‡ªå‹•çš„ã«æ¶ˆã™
    speechBubbleTimer = 3.0;
  }

  function hideSpeechBubble() {
    speechBubbleEl.classList.remove('show');
    speechBubbleTimer = 0;
  }

  // ãƒŸãƒ‹ãƒãƒƒãƒ—æç”»
  function drawMinimap() {
    minimapCtx.clearRect(0, 0, 150, 150);
    
    // èƒŒæ™¯
    minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
    minimapCtx.fillRect(0, 0, 150, 150);
    
    // ãƒãƒƒãƒ—ã®ã‚µã‚¤ã‚ºï¼ˆ5x5ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºï¼‰
    const cellSize = 12; // 5x5ã‚°ãƒªãƒƒãƒ‰ã«åã‚ã‚‹ãŸã‚å°‘ã—å°ã•ã
    const drawSize = cellSize - 1; // å®Ÿéš›ã®æç”»ã‚µã‚¤ã‚ºï¼ˆ11pxï¼‰
    
    // ä¸­å¤®ãƒãƒƒãƒ—(0,0)ã®ãƒã‚¹ã®ä¸­å¿ƒãŒãƒŸãƒ‹ãƒãƒƒãƒ—ã®ä¸­å¿ƒã«æ¥ã‚‹ã‚ˆã†ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
    // ä¸­å¤®ãƒãƒƒãƒ—ã¯(2,2)ã®ä½ç½®ï¼ˆ5x5ã‚°ãƒªãƒƒãƒ‰ã®ä¸­å¤®ï¼‰
    // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®ä¸­å¿ƒ: (150/2, 150/2) = (75, 75)
    // ãƒã‚¹ã®ä¸­å¿ƒãŒ(75, 75)ã«ãªã‚‹ã‚ˆã†ã«
    // ãƒã‚¹ã®å·¦ä¸Š = ä¸­å¿ƒ - drawSize/2
    // offsetX + 2 * cellSize + drawSize/2 = 75
    // offsetX = 75 - 2 * cellSize - drawSize/2
    const offsetX = 75 - 2 * cellSize - drawSize / 2; // 75 - 24 - 5.5 = 45.5
    const offsetY = 75 - 2 * cellSize - drawSize / 2; // 75 - 24 - 5.5 = 45.5
    
    // è¨ªå•ã—ãŸãƒãƒƒãƒ—ã‚’æç”»
    const mapTypes = {
      '0,0': { name: 'æ‘', color: '#8b7355' },
      '0,-1': { name: 'æ£®', color: '#228b22' },
      '0,1': { name: 'æµ·å²¸', color: '#1e3a8a' },
      '-1,0': { name: 'æ´çªŸ', color: '#555' },
      '1,0': { name: 'è‰åŸ', color: '#2d5016' },
      '-1,-1': { name: 'å»ƒå¢Ÿ', color: '#666' },
      '1,-1': { name: 'èŠ±ç•‘', color: '#ff69b4' },
      '-1,1': { name: 'æµ·å²¸æ´çªŸ', color: '#4a5568' },
      '1,1': { name: 'ãƒ“ãƒ¼ãƒ', color: '#d4a574' }
    };
    
    // æ–°ã—ã„ãƒãƒƒãƒ—ã‚¿ã‚¤ãƒ—ã®è‰²ã‚’å‹•çš„ã«æ±ºå®š
    const getMapColor = (x, y) => {
      const key = getMapKey(x, y);
      if (mapTypes[key]) return mapTypes[key].color;
      
      // æ–°ã—ã„ãƒãƒƒãƒ—ã‚¿ã‚¤ãƒ—ã®è‰²
      if (x >= 2 || (x > 0 && y <= -2)) return '#90EE90'; // ã‚µãƒœãƒ†ãƒ³ï¼ˆæ˜ã‚‹ã„ç·‘ï¼‰
      if (x <= -2 || (x < 0 && y <= -2)) return '#E0E0E0'; // é›ªï¼ˆç™½ï¼‰
      if (x <= -2 || (x < 0 && y >= 2)) return '#D2B48C'; // ç ‚æ¼ ï¼ˆãƒ™ãƒ¼ã‚¸ãƒ¥ï¼‰
      if (x >= 2 || (x > 0 && y >= 2)) return '#4169E1'; // æµ·æ´‹ï¼ˆé’ï¼‰
      return '#666'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    };
    
    // å„ãƒãƒƒãƒ—ä½ç½®ã‚’æç”»ï¼ˆ5x5ã‚°ãƒªãƒƒãƒ‰ã€ä¸­å¤®ãŒ(2,2)ï¼‰
    // x: -2ã‹ã‚‰2ã¾ã§ã€y: -2ã‹ã‚‰2ã¾ã§
    const mapPositions = [];
    for(let y = -2; y <= 2; y++) {
      for(let x = -2; x <= 2; x++) {
        mapPositions.push({
          key: `${x},${y}`,
          x: x + 2, // -2ã‚’0ã«ã€0ã‚’2ã«ã€2ã‚’4ã«å¤‰æ›
          y: y + 2  // -2ã‚’0ã«ã€0ã‚’2ã«ã€2ã‚’4ã«å¤‰æ›
        });
      }
    }
    
    for (const pos of mapPositions) {
      const [mx, my] = pos.key.split(',').map(Number);
      const isVisited = isMapVisited(mx, my);
      const isCurrent = (currentMapX === mx && currentMapY === my);
      
      if (isVisited || isCurrent) {
        const mapColor = mapTypes[pos.key] ? mapTypes[pos.key].color : getMapColor(mx, my);
        const px = offsetX + pos.x * cellSize;
        const py = offsetY + pos.y * cellSize;
        
        // ãƒãƒƒãƒ—ã‚»ãƒ«ã‚’æç”»
        minimapCtx.fillStyle = isCurrent ? '#ffd700' : mapColor;
        minimapCtx.fillRect(px, py, cellSize - 2, cellSize - 2);
        
        // ç¾åœ¨ä½ç½®ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        if (isCurrent) {
          minimapCtx.strokeStyle = '#fff';
          minimapCtx.lineWidth = 1.5;
          minimapCtx.strokeRect(px - 0.5, py - 0.5, cellSize - 1, cellSize - 1);
          
          // ç¾åœ¨ä½ç½®ã®ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
          minimapCtx.fillStyle = '#fff';
          minimapCtx.beginPath();
          minimapCtx.arc(px + cellSize/2, py + cellSize/2, 2, 0, Math.PI * 2);
          minimapCtx.fill();
        } else {
          // è¨ªå•æ¸ˆã¿ãƒãƒƒãƒ—ã®æ 
          minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
          minimapCtx.lineWidth = 0.5;
          minimapCtx.strokeRect(px, py, cellSize - 2, cellSize - 2);
        }
      }
    }
    
    // ã‚°ãƒªãƒƒãƒ‰ç·šï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ã€å¿…è¦ã«å¿œã˜ã¦ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆï¼‰
    // minimapCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    // minimapCtx.lineWidth = 1;
    // for (let i = 0; i <= 3; i++) {
    //   minimapCtx.beginPath();
    //   minimapCtx.moveTo(offsetX + i * cellSize, offsetY);
    //   minimapCtx.lineTo(offsetX + i * cellSize, offsetY + 3 * cellSize);
    //   minimapCtx.stroke();
    // }
    // for (let i = 0; i <= 3; i++) {
    //   minimapCtx.beginPath();
    //   minimapCtx.moveTo(offsetX, offsetY + i * cellSize);
    //   minimapCtx.lineTo(offsetX + 3 * cellSize, offsetY + i * cellSize);
    //   minimapCtx.stroke();
    // }
  }

  function gainExp(amount) {
    state.exp += amount;
    if (state.exp >= state.expToNext) {
      state.level++;
      state.exp = 0;
      state.expToNext = Math.floor(state.expToNext * 1.2);
      state.maxHp++;
      state.hp = state.maxHp;
      Sound.playSound('level');
      showLevelUp();
      showHint(`ãƒ¬ãƒ™ãƒ« ${state.level}! HP+1`);
    }
  }

  function showLevelUp() {
    levelUpEl.style.display = 'block';
    levelUpEl.style.animation = 'none';
    setTimeout(() => {
      levelUpEl.style.animation = 'levelUpAnim 2s ease-out';
    }, 10);
    setTimeout(() => {
      levelUpEl.style.display = 'none';
    }, 2000);
  }

  // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£
  class Entity {
    constructor(x,y) {
      this.x=x; this.y=y; this.w=12; this.h=12;
      this.vx=0; this.vy=0; this.dir=1; this.hp=1; this.dead=false;
    }
  }

  class Player extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=60; this.hp=state.hp; this.maxHp=state.maxHp;
      this.inv=0; this.attackCd=0; this.swordT=0;
      this.sdx=1; this.sdy=0;
    }
  }

  class Slime extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=25; this.hp=2; this.change=0; this.bounceT=0;
    }
    update(dt) {
      this.bounceT += dt * 4;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 2 + 0.8;
        const ang = Math.random() * Math.PI * 2;
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed;
      }
    }
  }

  class Archer extends Entity {
    constructor(x,y) {
      super(x,y);
      this.hp=3; this.cd=0; this.range=180; this.alertT=0;
    }
    update(dt) {
      if (this.alertT > 0) this.alertT -= dt;
    }
  }

  class CactusMonster extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=20; this.hp=3; this.change=0; this.spikeT=0;
    }
    update(dt) {
      this.spikeT += dt * 3;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 2.5 + 1.0;
        const ang = Math.random() * Math.PI * 2;
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed;
      }
    }
  }

  class SnowWolf extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=40; this.hp=2; this.change=0; this.howlT=0;
    }
    update(dt) {
      this.howlT += dt * 2;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 1.5 + 0.5;
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã£ã¦ç§»å‹•
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 0 && dist < 200) {
          this.vx = (dx / dist) * this.speed;
          this.vy = (dy / dist) * this.speed;
        } else {
          const ang = Math.random() * Math.PI * 2;
          this.vx = Math.cos(ang) * this.speed;
          this.vy = Math.sin(ang) * this.speed;
        }
      }
    }
  }

  class DesertScorpion extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=30; this.hp=4; this.change=0; this.stingT=0;
    }
    update(dt) {
      this.stingT += dt * 5;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 2 + 0.8;
        const ang = Math.random() * Math.PI * 2;
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed;
      }
    }
  }

  class OceanKraken extends Entity {
    constructor(x,y) {
      super(x,y);
      this.hp=5; this.cd=0; this.range=200; this.tentacleT=0; this.alertT=0;
    }
    update(dt) {
      this.tentacleT += dt * 2;
      if (this.alertT > 0) this.alertT -= dt;
    }
  }

  class FireSpirit extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=35; this.hp=2; this.change=0; this.flameT=0;
    }
    update(dt) {
      this.flameT += dt * 6;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 1.8 + 0.6;
        const ang = Math.random() * Math.PI * 2;
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed;
      }
    }
  }

  class Arrow extends Entity {
    constructor(x,y,vx,vy) {
      super(x,y);
      this.vx=vx; this.vy=vy; this.w=6; this.h=2; this.life=2.5;
    }
  }

  class Bomb {
    constructor(x,y) {
      this.x=x; this.y=y; this.t=1.2; this.exploded=false;
    }
  }

  class Explosion {
    constructor(x,y) {
      this.x=x; this.y=y; this.t=0.4; this.power=2;
    }
  }

  // ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆãƒãƒƒãƒ—ã”ã¨ã«ç®¡ç†ï¼‰
  const player = new Player(160, 96);
  const mapEntities = new Map(); // ãƒãƒƒãƒ—ã”ã¨ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ç®¡ç†
  
  function getMapEntities() {
    const key = getMapKey(currentMapX, currentMapY);
    if (!mapEntities.has(key)) {
      const entities = {
        npcs: [],
        chests: [],
        slimes: [],
        archers: [],
        cacti: [],
        snowwolves: [],
        scorpions: [],
        krakens: [],
        firespirits: []
      };
      
      // ãƒãƒƒãƒ—ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’é…ç½®
      if (currentMapX === 0 && currentMapY === 0) {
        // ä¸­å¤®ï¼šæ‘ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
        entities.npcs = [{
          x: 160, y: 56, r: 14, 
          texts: [
            'ã‚ˆã†ã“ãã€å‹‡è€…ã‚ˆï¼\nç§ã¯ã“ã®æ‘ã®é•·è€ã ã€‚',
            'æœ€è¿‘ã€å±é™ºãªãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒ\nå¢—ãˆã¦å›°ã£ã¦ã„ã‚‹ã‚“ã ã€‚',
            'å›ã®åŠ›ã§æ‘ã‚’å®ˆã£ã¦\nãã‚Œã‚‹ã¨ã‚ã‚ŠãŒãŸã„ã€‚',
            'âš”ï¸ãƒœã‚¿ãƒ³ã§æ”»æ’ƒã€\nğŸ’£ãƒœã‚¿ãƒ³ã§çˆ†å¼¾ãŒä½¿ãˆã‚‹ãã€‚',
            'é ‘å¼µã£ã¦ãã‚Œï¼'
          ],
          deathTexts: [
            'ãŠã„ãŠã„...ã¾ãŸæ­»ã‚“ã˜ã¾ã£ãŸã®ã‹ã€‚',
            'é ¼ã‚“ã ã®ã«ã€ã“ã‚“ãªã«\nå¼±ã„ã‚“ã˜ã‚ƒå›°ã‚‹ã‚“ã ã‚ˆã€‚',
            'æ‘ã®æœŸå¾…ã‚’è£åˆ‡ã‚‹æ°—ã‹ï¼Ÿ\nã‚‚ã£ã¨æ°—åˆã‚’å…¥ã‚Œã‚ï¼',
            'ã‚³ã‚¤ãƒ³ã‚‚åŠåˆ†ã«ãªã£ã¡ã¾ã£ãŸ...\næ¬¡ã¯æ°—ã‚’ã¤ã‘ã‚ã‚ˆã€‚',
            'ã¾ã‚ã€ç”Ÿãè¿”ã£ã¦ãã‚ŒãŸã ã‘\nãƒã‚·ã‹ã‚‚ã—ã‚Œã‚“ãŒãª...'
          ],
          currentTextIndex: 0,
          talked: false,
          rewardShown: false
        }];
        entities.chests = [{x: 208, y: 96, r: 12, opened:false}, {x: 80, y: 140, r: 12, opened:false}];
        entities.slimes = [new Slime(80,40), new Slime(260,120), new Slime(50,160)];
        entities.archers = [new Archer(56,40), new Archer(280,60)];
      } else if (currentMapX === 0 && currentMapY === -1) {
        // ä¸Šï¼šæ£®ã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
        entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,100), new Slime(260,40)];
        entities.archers = [new Archer(80,60), new Archer(240,90)];
      } else if (currentMapX === 0 && currentMapY === 1) {
        // ä¸‹ï¼šæµ·å²¸ã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 50, r: 12, opened:false}, {x: 240, y: 60, r: 12, opened:false}];
        entities.slimes = [new Slime(100,40), new Slime(220,50), new Slime(60,30)];
        entities.archers = [new Archer(120,45)];
      } else if (currentMapX === -1 && currentMapY === 0) {
        // å·¦ï¼šæ´çªŸã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 90, r: 12, opened:false}];
        entities.slimes = [new Slime(80,50), new Slime(240,70), new Slime(120,100), new Slime(200,40)];
        entities.archers = [new Archer(100,60), new Archer(220,80)];
      } else if (currentMapX === 1 && currentMapY === 0) {
        // å³ï¼šè‰åŸã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 80, y: 100, r: 12, opened:false}];
        entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,90)];
        entities.archers = [new Archer(140,60), new Archer(260,80)];
      } else if (currentMapX === -1 && currentMapY === -1) {
        // åŒ—è¥¿ï¼šå»ƒå¢Ÿã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
        entities.slimes = [new Slime(120,60), new Slime(200,80), new Slime(80,100)];
        entities.archers = [new Archer(100,70), new Archer(220,90)];
      } else if (currentMapX === 1 && currentMapY === -1) {
        // åŒ—æ±ï¼šèŠ±ç•‘ã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 240, y: 60, r: 12, opened:false}];
        entities.slimes = [new Slime(100,50), new Slime(180,70)];
        entities.archers = [new Archer(120,60)];
      } else if (currentMapX === -1 && currentMapY === 1) {
        // å—è¥¿ï¼šæµ·å²¸æ´çªŸã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 80, y: 80, r: 12, opened:false}, {x: 240, y: 100, r: 12, opened:false}];
        entities.slimes = [new Slime(60,50), new Slime(200,70), new Slime(100,120)];
        entities.archers = [new Archer(80,60), new Archer(220,80)];
      } else if (currentMapX === 1 && currentMapY === 1) {
        // å—æ±ï¼šãƒ“ãƒ¼ãƒã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 50, r: 12, opened:false}, {x: 240, y: 70, r: 12, opened:false}];
        entities.slimes = [new Slime(100,40), new Slime(220,60), new Slime(60,50)];
        entities.archers = [new Archer(140,45)];
      } else if (currentMapX >= 2 || (currentMapX > 0 && currentMapY <= -2)) {
        // åŒ—æ±æ–¹å‘ï¼šã‚µãƒœãƒ†ãƒ³ã€é™½æ°—ãªä¸–ç•Œ
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 80, y: 100, r: 12, opened:false}, {x: 240, y: 60, r: 12, opened:false}];
        entities.cacti = [new CactusMonster(100,50), new CactusMonster(220,70), new CactusMonster(60,90), new CactusMonster(260,50)];
        entities.firespirits = [new FireSpirit(140,60), new FireSpirit(180,80)];
      } else if (currentMapX <= -2 || (currentMapX < 0 && currentMapY <= -2)) {
        // åŒ—è¥¿æ–¹å‘ï¼šé›ªã€æ£®æ—åœ°å¸¯ã€å±±
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 80, y: 60, r: 12, opened:false}];
        entities.snowwolves = [new SnowWolf(100,50), new SnowWolf(220,70), new SnowWolf(60,100), new SnowWolf(240,40)];
        entities.archers = [new Archer(120,60), new Archer(200,80)];
      } else if (currentMapX <= -2 || (currentMapX < 0 && currentMapY >= 2)) {
        // å—è¥¿æ–¹å‘ï¼šç ‚æ¼ ã¨æ´çªŸ
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 80, y: 100, r: 12, opened:false}];
        entities.scorpions = [new DesertScorpion(100,50), new DesertScorpion(220,70), new DesertScorpion(60,90), new DesertScorpion(240,100)];
        entities.archers = [new Archer(120,60)];
      } else if (currentMapX >= 2 || (currentMapX > 0 && currentMapY >= 2)) {
        // å—æ±æ–¹å‘ï¼šæ°´ã¨å³¶ã€æµ·æ´‹
        entities.chests = [{x: 160, y: 50, r: 12, opened:false}, {x: 240, y: 70, r: 12, opened:false}, {x: 80, y: 40, r: 12, opened:false}];
        entities.krakens = [new OceanKraken(100,40), new OceanKraken(220,60), new OceanKraken(60,50), new OceanKraken(260,80)];
        entities.archers = [new Archer(140,45)];
      } else if (currentMapY <= -2) {
        // ãã®ä»–ã®åŒ—å´ã‚¨ãƒªã‚¢
        if (currentMapX < 0) {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70)];
          entities.archers = [new Archer(140,60)];
        } else {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 240, y: 60, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,90)];
          entities.archers = [new Archer(140,60)];
        }
      } else if (currentMapY >= 2) {
        // ãã®ä»–ã®å—å´ã‚¨ãƒªã‚¢
        if (currentMapX < 0) {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,90)];
          entities.archers = [new Archer(120,60)];
        } else {
          entities.chests = [{x: 160, y: 50, r: 12, opened:false}, {x: 240, y: 70, r: 12, opened:false}];
          entities.slimes = [new Slime(100,40), new Slime(220,60), new Slime(60,50)];
          entities.archers = [new Archer(140,45)];
        }
      } else if (currentMapX <= -2) {
        // ãã®ä»–ã®è¥¿å´ã‚¨ãƒªã‚¢
        if (currentMapY < 0) {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70)];
          entities.archers = [new Archer(140,60)];
        } else {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,90)];
          entities.archers = [new Archer(120,60)];
        }
      } else if (currentMapX >= 2) {
        // ãã®ä»–ã®æ±å´ã‚¨ãƒªã‚¢
        if (currentMapY < 0) {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 240, y: 60, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,90)];
          entities.archers = [new Archer(140,60)];
        } else {
          entities.chests = [{x: 160, y: 50, r: 12, opened:false}, {x: 240, y: 70, r: 12, opened:false}];
          entities.slimes = [new Slime(100,40), new Slime(220,60), new Slime(60,50)];
          entities.archers = [new Archer(140,45)];
        }
      }
      
      mapEntities.set(key, entities);
    }
    return mapEntities.get(key);
  }
  
  const arrows = [];
  const bombs = [];
  const blasts = [];

  // å®‰å…¨ãªè¡çªåˆ¤å®š
  function getTile(x, y) {
    const map = getCurrentMap();
    if (y < 0 || y >= ROWS || x < 0 || x >= COLS) return T.TREE; // å¢ƒç•Œå¤–ã¯å£
    if (!map[y] || map[y][x] === undefined) return T.TREE;
    return map[y][x];
  }

  function moveWithTile(e, dt, allowEdgePass = false) {
    let nx = e.x + e.vx * dt;
    let ny = e.y + e.vy * dt;
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å ´åˆã€ç”»é¢ç«¯ã§ã®è¡çªåˆ¤å®šã‚’ã‚¹ã‚­ãƒƒãƒ—
    if (allowEdgePass) {
      // ç”»é¢ç«¯ã«è¿‘ã„å ´åˆã¯ã€ã‚¿ã‚¤ãƒ«è¡çªåˆ¤å®šã‚’ã‚¹ã‚­ãƒƒãƒ—
      const nearLeftEdge = nx < TS;
      const nearRightEdge = nx > W - TS;
      const nearTopEdge = ny < TS;
      const nearBottomEdge = ny > H - TS;
      
      if (nearLeftEdge || nearRightEdge || nearTopEdge || nearBottomEdge) {
        // ç”»é¢ç«¯ã«è¿‘ã„å ´åˆã¯ç§»å‹•ã‚’è¨±å¯ï¼ˆãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆã®ãŸã‚ï¼‰
        e.x = nx;
        e.y = ny;
      } else {
        // é€šå¸¸ã®è¡çªåˆ¤å®š
        if (!collidesTile(nx, e.y, e.w, e.h)) e.x = nx; else e.vx=0;
        if (!collidesTile(e.x, ny, e.w, e.h)) e.y = ny; else e.vy=0;
      }
    } else {
      // é€šå¸¸ã®ç§»å‹•å‡¦ç†
      if (!collidesTile(nx, e.y, e.w, e.h)) e.x = nx; else e.vx=0;
      if (!collidesTile(e.x, ny, e.w, e.h)) e.y = ny; else e.vy=0;
    }
  }

  function collidesTile(cx, cy, w, h) {
    // ç”»é¢å¤–ã®å ´åˆã¯è¡çªã—ãªã„ï¼ˆãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆã‚’è¨±å¯ï¼‰
    if (cx - w/2 < 0 || cx + w/2 > W || cy - h/2 < 0 || cy + h/2 > H) {
      return false;
    }
    
    const x0 = Math.floor((cx-w/2)/TS);
    const x1 = Math.floor((cx+w/2)/TS);
    const y0 = Math.floor((cy-h/2)/TS);
    const y1 = Math.floor((cy+h/2)/TS);
    
    for(let y=y0;y<=y1;y++) {
      for(let x=x0;x<=x1;x++){
        const tile = getTile(x, y);
        if (isBlock(tile)) return true;
      }
    }
    return false;
  }

  // æ”»æ’ƒ
  function attack() {
    if (player.attackCd>0) return;
    player.attackCd = 0.3;
    
    const dirX = Math.sign(Input.ax || player.dir) || player.dir;
    const dirY = Math.sign(Input.ay || 0);
    player.sdx = dirX; player.sdy = dirY;
    player.swordT = 0.18;

    Sound.playSound('sword');

    const range = 18; const w=16, h=12;
    const ax = player.x + dirX*range;
    const ay = player.y + dirY*range;
    const hit = (e) => Math.abs(e.x-ax)<w/2 && Math.abs(e.y-ay)<h/2;
    
    const entities = getMapEntities();
    let hitSomething = false;
    for (const s of entities.slimes) {
      if (!s.dead && hit(s)) {
        s.hp--;
        hitSomething = true;
        if (s.hp<=0) {
          s.dead=true;
          state.coins+=3;
          gainExp(2);
          showHint('ğŸŸ¢ ã‚¹ãƒ©ã‚¤ãƒ æ’ƒç ´! +3ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const a of entities.archers) {
      if (!a.dead && hit(a)) {
        a.hp--;
        a.alertT = 0.5;
        hitSomething = true;
        if (a.hp<=0) {
          a.dead=true;
          state.coins+=5;
          gainExp(3);
          showHint('ğŸ¹ ã‚¢ãƒ¼ãƒãƒ£ãƒ¼æ’ƒç ´! +5ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const c of entities.cacti) {
      if (!c.dead && hit(c)) {
        c.hp--;
        hitSomething = true;
        if (c.hp<=0) {
          c.dead=true;
          state.coins+=4;
          gainExp(2);
          showHint('ğŸŒµ ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´! +4ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const w of entities.snowwolves) {
      if (!w.dead && hit(w)) {
        w.hp--;
        hitSomething = true;
        if (w.hp<=0) {
          w.dead=true;
          state.coins+=4;
          gainExp(3);
          showHint('ğŸº é›ªã‚ªã‚ªã‚«ãƒŸæ’ƒç ´! +4ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const sc of entities.scorpions) {
      if (!sc.dead && hit(sc)) {
        sc.hp--;
        hitSomething = true;
        if (sc.hp<=0) {
          sc.dead=true;
          state.coins+=5;
          gainExp(3);
          showHint('ğŸ¦‚ ã‚µã‚½ãƒªæ’ƒç ´! +5ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const k of entities.krakens) {
      if (!k.dead && hit(k)) {
        k.hp--;
        k.alertT = 0.5;
        hitSomething = true;
        if (k.hp<=0) {
          k.dead=true;
          state.coins+=6;
          gainExp(4);
          showHint('ğŸ™ ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³æ’ƒç ´! +6ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const f of entities.firespirits) {
      if (!f.dead && hit(f)) {
        f.hp--;
        hitSomething = true;
        if (f.hp<=0) {
          f.dead=true;
          state.coins+=4;
          gainExp(2);
          showHint('ğŸ”¥ ç‚ã®ç²¾éœŠæ’ƒç ´! +4ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
  }

  function placeBomb() {
    if (bombs.length >= 3) return;
    bombs.push(new Bomb(Math.round(player.x/TS)*TS, Math.round(player.y/TS)*TS));
    Sound.playSound('button');
    showHint('ğŸ’£ çˆ†å¼¾è¨­ç½®');
  }

  function hitPlayer(dmg) {
    if (player.inv>0) return;
    player.hp = Math.max(0, player.hp - dmg);
    state.hp = player.hp;
    player.inv = 1.2;
    Sound.playSound('hit');
    showHint(`ğŸ’” -${dmg} HP`);
    if (player.hp<=0) respawn();
  }

  let justRespawned = false; // ãƒªã‚¹ãƒãƒ¼ãƒ³ç›´å¾Œã®ãƒ•ãƒ©ã‚°
  
  function respawn() {
    state.coins = Math.max(0, Math.floor(state.coins/2));
    // ä¸­å¤®ãƒãƒƒãƒ—ã«æˆ»ã‚‹
    currentMapX = 0;
    currentMapY = 0;
    player.x=160; player.y=96;
    player.hp=player.maxHp;
    state.hp=player.hp;
    arrows.length = 0; // çŸ¢ã‚’ã‚¯ãƒªã‚¢
    hideSpeechBubble();
    justRespawned = true; // ãƒªã‚¹ãƒãƒ¼ãƒ³ç›´å¾Œãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
    showHint('ğŸ  æ‘ã«æˆ»ã‚Šã¾ã—ãŸ');
    Sound.playSound('talk');
  }

  function hasLineOfSight(x0,y0,x1,y1) {
    const steps = 40;
    for(let i=1;i<steps;i++) {
      const t=i/steps;
      const x=x0+(x1-x0)*t, y=y0+(y1-y0)*t;
      const tx=Math.floor(x/TS), ty=Math.floor(y/TS);
      const tile = getTile(tx, ty);
      if (isBlock(tile)) return false;
    }
    return true;
  }

  // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æç”»
  function drawCharacter(x, y, type, entity = null) {
    ctx.save();
    
    switch(type) {
      case 'player':
        if (entity && entity.inv > 0) {
          ctx.globalAlpha = 0.6 + 0.4 * Math.sin(performance.now() * 0.02);
        }
        
        // ä½“ï¼ˆé’ã„æœï¼‰
        ctx.fillStyle = '#4a90e2';
        ctx.fillRect(x-6, y-8, 12, 16);
        
        // é ­ï¼ˆè‚Œè‰²ï¼‰
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-5, y-12, 10, 8);
        
        // é«ªï¼ˆèŒ¶è‰²ï¼‰
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(x-6, y-14, 12, 4);
        
        // ç›®
        ctx.fillStyle = '#000';
        ctx.fillRect(x-3, y-10, 2, 1);
        ctx.fillRect(x+1, y-10, 2, 1);
        
        // è…•
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-8, y-6, 3, 8);
        ctx.fillRect(x+5, y-6, 3, 8);
        
        // è¶³ï¼ˆé´ï¼‰
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(x-6, y+6, 5, 4);
        ctx.fillRect(x+1, y+6, 5, 4);
        break;
        
      case 'slime':
        const bounce = entity ? Math.sin(entity.bounceT) * 1 : 0;
        ctx.fillStyle = '#6cf07a';
        ctx.beginPath();
        ctx.ellipse(x, y + bounce, 8, 6 - bounce * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        ctx.fillStyle = '#a8ffa8';
        ctx.beginPath();
        ctx.ellipse(x - 2, y - 1 + bounce, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ç›®
        ctx.fillStyle = '#000';
        ctx.fillRect(x-3, y-1, 2, 2);
        ctx.fillRect(x+1, y-1, 2, 2);
        break;
        
      case 'archer':
        const alert = entity && entity.alertT > 0;
        if (alert) {
          ctx.globalAlpha = 0.8 + 0.2 * Math.sin(performance.now() * 0.01);
        }
        
        // ä½“
        ctx.fillStyle = alert ? '#ff6b6b' : '#b7a1f0';
        ctx.fillRect(x-5, y-6, 10, 12);
        
        // é ­
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-4, y-10, 8, 6);
        
        // ãƒ•ãƒ¼ãƒ‰
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x-5, y-12, 10, 4);
        
        // å¼“
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x + 6, y, 8, -Math.PI/3, Math.PI/3);
        ctx.stroke();
        
        // ç›®
        ctx.fillStyle = alert ? '#ff0000' : '#000';
        ctx.fillRect(x-2, y-8, 1, 1);
        ctx.fillRect(x+1, y-8, 1, 1);
        break;
        
      case 'npc':
        // è€äººé¢¨NPC
        ctx.fillStyle = '#6b4423';
        ctx.fillRect(x-6, y-8, 12, 16);
        
        // é ­
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-4, y-10, 8, 6);
        
        // å¸½å­ï¼ˆã¤ã°åºƒå¸½å­é¢¨ï¼‰
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x-6, y-14, 12, 3);
        ctx.fillRect(x-5, y-11, 10, 2);
        
        // é•·ã„ã²ã’
        ctx.fillStyle = '#ddd';
        ctx.fillRect(x-4, y-6, 8, 4);
        ctx.fillRect(x-3, y-4, 6, 2);
        
        // æ–
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + 8, y + 8);
        ctx.lineTo(x + 8, y - 10);
        ctx.stroke();
        
        // æ–ã®å…ˆï¼ˆä¸¸ã„è£…é£¾ï¼‰
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.arc(x + 8, y - 10, 2, 0, Math.PI * 2);
        ctx.fill();
        break;
        
      case 'cactus':
        const spike = entity ? Math.sin(entity.spikeT) * 0.5 : 0;
        // ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼
        ctx.fillStyle = '#4a7c59';
        ctx.fillRect(x-6, y-8, 12, 16);
        // ãƒˆã‚²
        ctx.fillStyle = '#1a3d2e';
        for(let i = 0; i < 4; i++) {
          const tx = x - 4 + i * 3;
          ctx.fillRect(tx, y - 6 + spike, 1, 2);
          ctx.fillRect(tx, y + 4 + spike, 1, 2);
        }
        // ç›®
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(x-3, y-4, 2, 2);
        ctx.fillRect(x+1, y-4, 2, 2);
        break;
        
      case 'snowwolf':
        const howl = entity ? Math.sin(entity.howlT) * 1 : 0;
        // é›ªã‚ªã‚ªã‚«ãƒŸ
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(x-7, y-7, 14, 14);
        // è€³
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(x-6, y-9, 4, 4);
        ctx.fillRect(x+2, y-9, 4, 4);
        // ç›®
        ctx.fillStyle = '#0000ff';
        ctx.fillRect(x-3, y-4, 2, 2);
        ctx.fillRect(x+1, y-4, 2, 2);
        // å£
        ctx.fillStyle = '#000';
        ctx.fillRect(x-2, y+2 + howl, 4, 2);
        break;
        
      case 'scorpion':
        const sting = entity ? Math.sin(entity.stingT) * 1.5 : 0;
        // ã‚µã‚½ãƒª
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(x-5, y-5, 10, 8);
        // é ­
        ctx.fillRect(x-4, y-7, 8, 4);
        // å°¾
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x+5, y+3);
        ctx.lineTo(x+8, y-2 + sting);
        ctx.stroke();
        // ç›®
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(x-2, y-6, 1, 1);
        ctx.fillRect(x+1, y-6, 1, 1);
        // è„š
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        for(let i = 0; i < 4; i++) {
          const lx = x - 4 + i * 2.5;
          ctx.beginPath();
          ctx.moveTo(lx, y+3);
          ctx.lineTo(lx - 2, y+6);
          ctx.stroke();
        }
        break;
        
      case 'kraken':
        const tentacle = entity ? Math.sin(entity.tentacleT) * 2 : 0;
        // ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³
        ctx.fillStyle = '#2c3e50';
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        ctx.fill();
        // ç›®
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(x-4, y-3, 3, 3);
        ctx.fillRect(x+1, y-3, 3, 3);
        // è§¦æ‰‹
        ctx.strokeStyle = '#1a1a2e';
        ctx.lineWidth = 2;
        for(let i = 0; i < 4; i++) {
          const ang = (i / 4) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(ang) * (8 + tentacle), y + Math.sin(ang) * (8 + tentacle));
          ctx.stroke();
        }
        break;
        
      case 'firespirit':
        const flame = entity ? Math.sin(entity.flameT) * 1.5 : 0;
        // ç‚ã®ç²¾éœŠ
        ctx.fillStyle = '#ff4500';
        ctx.beginPath();
        ctx.arc(x, y + flame, 7, 0, Math.PI * 2);
        ctx.fill();
        // ç‚ã®å¤–å´
        ctx.fillStyle = '#ffaa00';
        ctx.beginPath();
        ctx.arc(x - 2, y - 2 + flame, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + 2, y - 1 + flame, 4, 0, Math.PI * 2);
        ctx.fill();
        // ç›®
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(x-2, y-1 + flame, 1, 1);
        ctx.fillRect(x+1, y-1 + flame, 1, 1);
        break;
    }
    
    ctx.restore();
  }

  // æç”»
  function draw() {
    ctx.clearRect(0,0,W,H);

    // ã‚¿ã‚¤ãƒ«
    const map = getCurrentMap();
    for(let y=0;y<ROWS;y++) {
      for(let x=0;x<COLS;x++){
        const t = map[y][x];
        const px = x*TS, py=y*TS;
        
        switch(t){
          case T.GRASS: 
            ctx.fillStyle='#2d5016'; 
            ctx.fillRect(px,py,TS,TS);
            // è‰ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£
            ctx.fillStyle='#3a6b1f';
            for(let i=0;i<3;i++) {
              const gx = px + (i*5) + 2;
              const gy = py + 8 + (i%2)*3;
              ctx.fillRect(gx, gy, 1, 4);
            }
            break;
            
          case T.PATH: 
            ctx.fillStyle='#8b7355'; 
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#756347';
            ctx.fillRect(px+2, py+2, 5, 5);
            ctx.fillRect(px+9, py+9, 5, 5);
            break;
            
          case T.TREE: 
            ctx.fillStyle='#2d5016';
            ctx.fillRect(px,py,TS,TS);
            // å¹¹
            ctx.fillStyle='#8b4513';
            ctx.fillRect(px+6, py+8, 4, 8);
            // è‘‰
            ctx.fillStyle='#228b22';
            ctx.fillRect(px+2, py+2, 12, 10);
            ctx.fillStyle='#32cd32';
            ctx.fillRect(px+4, py+4, 8, 6);
            break;
            
          case T.WATER: 
            ctx.fillStyle='#1e3a8a'; 
            ctx.fillRect(px,py,TS,TS);
            const waveTime = performance.now() * 0.005;
            const wave = Math.sin(waveTime + x + y) * 0.3;
            ctx.fillStyle=`rgba(100,149,237,${0.3 + wave})`;
            ctx.fillRect(px,py,TS,TS*0.5);
            break;
            
          case T.FLOWER:
            ctx.fillStyle='#2d5016'; 
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#ff69b4';
            ctx.fillRect(px+6, py+6, 4, 4);
            ctx.fillStyle='#ffd700';
            ctx.fillRect(px+7, py+7, 2, 2);
            break;
            
          case T.ROCK:
            ctx.fillStyle='#2d5016';
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#555';
            ctx.fillRect(px+2, py+2, 12, 12);
            ctx.fillStyle='#666';
            ctx.fillRect(px+4, py+4, 8, 8);
            ctx.fillStyle='#444';
            ctx.fillRect(px+6, py+6, 4, 4);
            break;
            
          case T.SAND:
            ctx.fillStyle='#d4a574';
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#c9a068';
            ctx.fillRect(px+2, py+2, 5, 5);
            ctx.fillRect(px+9, py+9, 5, 5);
            break;
            
          case T.CACTUS:
            ctx.fillStyle='#2d5016';
            ctx.fillRect(px,py,TS,TS);
            // ã‚µãƒœãƒ†ãƒ³ã®æœ¬ä½“
            ctx.fillStyle='#4a7c59';
            ctx.fillRect(px+6, py+2, 4, 12);
            // ã‚µãƒœãƒ†ãƒ³ã®è…•
            ctx.fillRect(px+2, py+6, 3, 4);
            ctx.fillRect(px+11, py+8, 3, 4);
            // ãƒˆã‚²
            ctx.fillStyle='#1a3d2e';
            ctx.fillRect(px+6, py+4, 1, 1);
            ctx.fillRect(px+9, py+6, 1, 1);
            ctx.fillRect(px+7, py+9, 1, 1);
            break;
            
          case T.SNOW:
            ctx.fillStyle='#e8f4f8';
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#d0e8f0';
            ctx.fillRect(px+2, py+2, 5, 5);
            ctx.fillRect(px+9, py+9, 5, 5);
            // é›ªã®çµæ™¶
            ctx.fillStyle='#ffffff';
            ctx.fillRect(px+7, py+3, 1, 1);
            ctx.fillRect(px+6, py+7, 1, 1);
            ctx.fillRect(px+8, py+7, 1, 1);
            break;
            
          case T.DESERT:
            ctx.fillStyle='#d2b48c';
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#c19a6b';
            ctx.fillRect(px+2, py+2, 5, 5);
            ctx.fillRect(px+9, py+9, 5, 5);
            // ç ‚ã®æ³¢ç´‹
            ctx.fillStyle='#b8860b';
            for(let i = 0; i < 3; i++) {
              const wx = px + (i * 5);
              ctx.fillRect(wx, py + 8, 3, 1);
            }
            break;
            
          case T.ICE:
            ctx.fillStyle='#1e3a8a';
            ctx.fillRect(px,py,TS,TS);
            const iceTime = performance.now() * 0.003;
            const iceWave = Math.sin(iceTime + x + y) * 0.2;
            ctx.fillStyle=`rgba(173,216,230,${0.4 + iceWave})`;
            ctx.fillRect(px,py,TS,TS);
            // æ°·ã®ã²ã³
            ctx.strokeStyle='rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(px+2, py+2);
            ctx.lineTo(px+6, py+8);
            ctx.moveTo(px+10, py+4);
            ctx.lineTo(px+14, py+12);
            ctx.stroke();
            break;
        }
      }
    }

    // ç¾åœ¨ã®ãƒãƒƒãƒ—ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’å–å¾—
    const entities = getMapEntities();
    
    // NPC
    for (const n of entities.npcs){
      drawCharacter(n.x, n.y, 'npc');
      if (!n.talked) {
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(n.x-1, n.y-20, 2, 6);
        ctx.fillRect(n.x-1, n.y-12, 2, 2);
      }
    }
    
    // å®ç®±
    for (const c of entities.chests){ 
      const chestColor = c.opened? '#8e6b3f' : '#d4af37';
      ctx.fillStyle = chestColor;
      ctx.fillRect(c.x-8,c.y-6,16,12);
      
      if (!c.opened) {
        ctx.fillStyle = '#ffd700';
        ctx.fillRect(c.x-6, c.y-4, 12, 2);
        ctx.fillRect(c.x-2, c.y-2, 4, 4);
        const sparkleTime = performance.now() * 0.01;
        const sparkle = Math.sin(sparkleTime) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255,255,255,${sparkle})`;
        ctx.fillRect(c.x-10, c.y-8, 2, 2);
        ctx.fillRect(c.x+8, c.y-8, 2, 2);
        ctx.fillRect(c.x, c.y-10, 2, 2);
      }
    }

    // çˆ†å¼¾
    for (const b of bombs){ 
      const pulseTime = performance.now() * 0.01;
      const bombColor = b.t < 0.3 ? '#ff0000' : '#333';
      ctx.fillStyle = bombColor;
      ctx.fillRect(b.x-4, b.y-4, 8, 8);
      
      ctx.fillStyle = '#ff4500';
      ctx.fillRect(b.x-1, b.y-8, 2, 4);
      
      if (b.t < 0.3) {
        const pulse = Math.sin(pulseTime * 10) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255,255,255,${pulse})`;
        ctx.fillRect(b.x-5, b.y-5, 10, 10);
      }
    }
    
    // çˆ†ç™º
    for (const ex of blasts){ 
      const intensity = ex.t / 0.4;
      ctx.save();
      ctx.globalAlpha = intensity;
      
      ctx.fillStyle='#ffaa00';
      ctx.fillRect(ex.x-TS*2, ex.y-4, TS*4, 8);
      ctx.fillRect(ex.x-4, ex.y-TS*2, 8, TS*4);
      
      ctx.fillStyle='#ff6600';
      ctx.fillRect(ex.x-TS, ex.y-2, TS*2, 4);
      ctx.fillRect(ex.x-2, ex.y-TS, 4, TS*2);
      
      ctx.fillStyle='#ffffff';
      ctx.fillRect(ex.x-8, ex.y-1, 16, 2);
      ctx.fillRect(ex.x-1, ex.y-8, 2, 16);
      
      ctx.restore();
    }

    // çŸ¢
    for (const ar of arrows){ 
      ctx.save();
      const angle = Math.atan2(ar.vy, ar.vx);
      ctx.translate(ar.x, ar.y);
      ctx.rotate(angle);
      
      ctx.fillStyle='#8b4513';
      ctx.fillRect(-6, -1, 8, 2);
      ctx.fillStyle='#ddd';
      ctx.fillRect(2, -2, 4, 4);
      
      ctx.restore();
    }

    // æ•µ
    for (const s of entities.slimes){ 
      if (s.dead) continue; 
      drawCharacter(s.x, s.y, 'slime', s);
    }
    for (const a of entities.archers){ 
      if (a.dead) continue; 
      drawCharacter(a.x, a.y, 'archer', a);
    }
    for (const c of entities.cacti){ 
      if (c.dead) continue; 
      drawCharacter(c.x, c.y, 'cactus', c);
    }
    for (const w of entities.snowwolves){ 
      if (w.dead) continue; 
      drawCharacter(w.x, w.y, 'snowwolf', w);
    }
    for (const sc of entities.scorpions){ 
      if (sc.dead) continue; 
      drawCharacter(sc.x, sc.y, 'scorpion', sc);
    }
    for (const k of entities.krakens){ 
      if (k.dead) continue; 
      drawCharacter(k.x, k.y, 'kraken', k);
    }
    for (const f of entities.firespirits){ 
      if (f.dead) continue; 
      drawCharacter(f.x, f.y, 'firespirit', f);
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    drawCharacter(player.x, player.y, 'player', player);

    // å‰£
    if (player.swordT > 0){
      const alpha = clamp(player.swordT / 0.18, 0, 1);
      ctx.save();
      ctx.globalAlpha = alpha;
      
      const dx = player.sdx, dy = player.sdy;
      const swordLength = 16;
      const swordWidth = 4;
      
      ctx.translate(player.x, player.y);
      ctx.rotate(Math.atan2(dy, dx));
      
      // å‰£èº«
      ctx.fillStyle = '#e8e8e8';
      ctx.fillRect(8, -swordWidth/2, swordLength, swordWidth);
      
      // å‰£å…ˆ
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(8 + swordLength - 2, -1, 2, 2);
      
      // æŸ„
      ctx.fillStyle = '#8b4513';
      ctx.fillRect(4, -2, 6, 4);
      
      // ãƒ„ãƒ
      ctx.fillStyle = '#666';
      ctx.fillRect(8, -3, 2, 6);
      
      ctx.restore();
    }
    
    // ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’æç”»
    drawMinimap();
  }

  // æ›´æ–°
  function update(dt) {
    // å…¥åŠ›
    const speed = player.speed;
    player.vx = Input.ax * speed; 
    player.vy = Input.ay * speed;
    if (Math.abs(Input.ax) > 0.1) player.dir = Math.sign(Input.ax);

    // æ”»æ’ƒãƒ»çˆ†å¼¾
    if (Input.aDown) attack();
    if (Input.xDown) placeBomb();

    if (player.attackCd>0) player.attackCd-=dt;
    if (player.inv>0) player.inv-=dt;
    if (player.swordT>0) player.swordT-=dt;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ï¼ˆç”»é¢ç«¯é€šéã‚’è¨±å¯ï¼‰
    moveWithTile(player, dt, true);

    // ãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆãƒã‚§ãƒƒã‚¯
    if (player.x < 0) {
      markMapVisited(currentMapX, currentMapY); // ç¾åœ¨ã®ãƒãƒƒãƒ—ã‚’è¨ªå•æ¸ˆã¿ã«
      currentMapX--;
      player.x = W - 10;
      arrows.length = 0; // çŸ¢ã‚’ã‚¯ãƒªã‚¢
      hideSpeechBubble();
      markMapVisited(currentMapX, currentMapY); // æ–°ã—ã„ãƒãƒƒãƒ—ã‚’è¨ªå•æ¸ˆã¿ã«
      Sound.playSound('button'); // ãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆéŸ³
    } else if (player.x > W) {
      markMapVisited(currentMapX, currentMapY);
      currentMapX++;
      player.x = 10;
      arrows.length = 0;
      hideSpeechBubble();
      markMapVisited(currentMapX, currentMapY);
      Sound.playSound('button');
    }
    if (player.y < 0) {
      markMapVisited(currentMapX, currentMapY);
      currentMapY--;
      player.y = H - 10;
      arrows.length = 0;
      hideSpeechBubble();
      markMapVisited(currentMapX, currentMapY);
      Sound.playSound('button');
    } else if (player.y > H) {
      markMapVisited(currentMapX, currentMapY);
      currentMapY++;
      player.y = 10;
      arrows.length = 0;
      hideSpeechBubble();
      markMapVisited(currentMapX, currentMapY);
      Sound.playSound('button');
    }
    
    // ç¾åœ¨ã®ãƒãƒƒãƒ—ã‚’è¨ªå•æ¸ˆã¿ã«ãƒãƒ¼ã‚¯
    markMapVisited(currentMapX, currentMapY);

    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
    const entities = getMapEntities();
    let canTalk = false, canOpen = false;
    const near = (o,r) => dist2(player.x,player.y,o.x,o.y) < (r*r);
    
    for (const n of entities.npcs){ 
      if (near(n, 20)) canTalk = true; 
    }
    for (const c of entities.chests){ 
      if (!c.opened && near(c, 20)) canOpen = true; 
    }
    
    // ãƒªã‚¹ãƒãƒ¼ãƒ³ç›´å¾Œã«è€äººãŒè‡ªå‹•çš„ã«æ„šç—´ã‚’è¨€ã†
    if (justRespawned && currentMapX === 0 && currentMapY === 0) {
      const npc = entities.npcs.find(n => near(n, 50)); // å°‘ã—åºƒã‚ã®ç¯„å›²
      if (npc && npc.deathTexts) {
        justRespawned = false;
        Sound.playSound('talk');
        // ãƒ©ãƒ³ãƒ€ãƒ ã«æ„šç—´ã‚’é¸ã¶
        const randomDeathText = npc.deathTexts[Math.floor(Math.random() * npc.deathTexts.length)];
        showSpeechBubble(npc, randomDeathText);
        // é€šå¸¸ã®ä¼šè©±ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ãƒªã‚»ãƒƒãƒˆã—ãªã„ï¼ˆåˆ¥ç®¡ç†ï¼‰
      } else {
        justRespawned = false;
      }
    }
    
    if (canTalk) showHint('ğŸ’¬ Bã§è©±ã™'); 
    else if (canOpen) showHint('ğŸ“¦ Bã§é–‹ã‘ã‚‹');
    
    if (Input.bDown){
      if (canTalk){ 
        const npc = entities.npcs.find(n => near(n, 20));
        if (npc) {
          Sound.playSound('talk');
          
          // å¹ãå‡ºã—ã§ä¼šè©±ã‚’è¡¨ç¤º
          if (npc.currentTextIndex < npc.texts.length) {
            showSpeechBubble(npc, npc.texts[npc.currentTextIndex]);
            npc.currentTextIndex++;
            
            // åˆå›ä¼šè©±æ™‚ã®ã¿å ±é…¬
            if (!npc.talked && npc.currentTextIndex >= npc.texts.length) {
              npc.talked = true;
              state.coins += 5;
              gainExp(1);
              showHint('ğŸ‘´ é•·è€ã‹ã‚‰+5ğŸ’°');
            }
          } else {
            // å…¨ã¦ã®ä¼šè©±ãŒçµ‚ã‚ã£ãŸã‚‰æœ€åˆã«æˆ»ã™
            npc.currentTextIndex = 0;
            showSpeechBubble(npc, npc.texts[0]);
          }
        }
      }
      else if (canOpen){ 
        const chest = entities.chests.find(c=>!c.opened && near(c,20)); 
        if (chest){ 
          chest.opened = true; 
          const reward = 10 + state.level * 2;
          state.coins += reward; 
          gainExp(3);
          Sound.playSound('chest'); 
          showHint(`ğŸ“¦ å®ç®±ã‹ã‚‰+${reward}ğŸ’°`); 
        }
      }
    }

    // ã‚¹ãƒ©ã‚¤ãƒ 
    for (const s of entities.slimes){ 
      if (s.dead) continue; 
      s.update(dt); 
      moveWithTile(s, dt); 
      if (dist2(s.x,s.y,player.x,player.y) < 15*15) hitPlayer(1); 
    }

    // ã‚¢ãƒ¼ãƒãƒ£ãƒ¼
    for (const a of entities.archers){ 
      if (a.dead) continue; 
      a.update(dt);
      if ((a.cd-=dt)<=0){
        const playerDist = Math.hypot(a.x - player.x, a.y - player.y);
        if (playerDist < a.range) {
          if (Math.abs(a.y-player.y)<12 && hasLineOfSight(a.x,a.y,player.x,player.y)) { 
            const vx = Math.sign(player.x-a.x)*120; 
            arrows.push(new Arrow(a.x, a.y, vx, 0)); 
            a.cd=1.5; 
            a.alertT = 0.5;
            Sound.playSound('button');
          } 
          else if (Math.abs(a.x-player.x)<12 && hasLineOfSight(a.x,a.y,player.x,player.y)) { 
            const vy = Math.sign(player.y-a.y)*120; 
            arrows.push(new Arrow(a.x, a.y, 0, vy)); 
            a.cd=1.5; 
            a.alertT = 0.5;
            Sound.playSound('button');
          } 
          else a.cd=0.4;
        } else {
          a.cd = 0.3;
        }
      } 
    }

    // ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼
    for (const c of entities.cacti){ 
      if (c.dead) continue; 
      c.update(dt); 
      moveWithTile(c, dt); 
      if (dist2(c.x,c.y,player.x,player.y) < 15*15) hitPlayer(1); 
    }

    // é›ªã‚ªã‚ªã‚«ãƒŸ
    for (const w of entities.snowwolves){ 
      if (w.dead) continue; 
      w.update(dt); 
      moveWithTile(w, dt); 
      if (dist2(w.x,w.y,player.x,player.y) < 15*15) hitPlayer(1); 
    }

    // ã‚µã‚½ãƒª
    for (const sc of entities.scorpions){ 
      if (sc.dead) continue; 
      sc.update(dt); 
      moveWithTile(sc, dt); 
      if (dist2(sc.x,sc.y,player.x,player.y) < 15*15) hitPlayer(2); 
    }

    // ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³
    for (const k of entities.krakens){ 
      if (k.dead) continue; 
      k.update(dt);
      if ((k.cd-=dt)<=0){
        const playerDist = Math.hypot(k.x - player.x, k.y - player.y);
        if (playerDist < k.range) {
          if (Math.abs(k.y-player.y)<12 && hasLineOfSight(k.x,k.y,player.x,player.y)) { 
            const vx = Math.sign(player.x-k.x)*100; 
            arrows.push(new Arrow(k.x, k.y, vx, 0)); 
            k.cd=2.0; 
            k.alertT = 0.5;
            Sound.playSound('button');
          } 
          else if (Math.abs(k.x-player.x)<12 && hasLineOfSight(k.x,k.y,player.x,player.y)) { 
            const vy = Math.sign(player.y-k.y)*100; 
            arrows.push(new Arrow(k.x, k.y, 0, vy)); 
            k.cd=2.0; 
            k.alertT = 0.5;
            Sound.playSound('button');
          } 
          else k.cd=0.5;
        } else {
          k.cd = 0.4;
        }
      } 
    }

    // ç‚ã®ç²¾éœŠ
    for (const f of entities.firespirits){ 
      if (f.dead) continue; 
      f.update(dt); 
      moveWithTile(f, dt); 
      if (dist2(f.x,f.y,player.x,player.y) < 15*15) hitPlayer(1); 
    }

    // çŸ¢
    for (const ar of arrows){ 
      ar.x += ar.vx*dt; 
      ar.y += ar.vy*dt; 
      ar.life-=dt; 
      if (collidesTile(ar.x,ar.y,6,2)) ar.life=0; 
      if (ar.life<=0) ar.dead=true; 
      if (dist2(ar.x,ar.y,player.x,player.y)<12*12){ 
        ar.dead=true; 
        hitPlayer(1);
      } 
    }

    // çˆ†å¼¾
    for (const b of bombs){ 
      b.t-=dt; 
      if (!b.exploded && b.t<=0){ 
        b.exploded = true; 
        blasts.push(new Explosion(b.x,b.y)); 
        Sound.playSound('bomb');
        
        const hitRect = (e) => Math.abs(e.x-b.x)<TS*1.5 && Math.abs(e.y-b.y)<8 || Math.abs(e.y-b.y)<TS*1.5 && Math.abs(e.x-b.x)<8;
        const bombEntities = getMapEntities();
        for (const s of bombEntities.slimes){ 
          if (!s.dead && hitRect(s)){ 
            s.dead=true; 
            state.coins+=3; 
            gainExp(2);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚¹ãƒ©ã‚¤ãƒ æ’ƒç ´!'); 
          } 
        }
        for (const a of bombEntities.archers){ 
          if (!a.dead && hitRect(a)){ 
            a.dead=true; 
            state.coins+=5; 
            gainExp(3);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚¢ãƒ¼ãƒãƒ£ãƒ¼æ’ƒç ´!'); 
          } 
        }
        for (const c of bombEntities.cacti){ 
          if (!c.dead && hitRect(c)){ 
            c.dead=true; 
            state.coins+=4; 
            gainExp(2);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´!'); 
          } 
        }
        for (const w of bombEntities.snowwolves){ 
          if (!w.dead && hitRect(w)){ 
            w.dead=true; 
            state.coins+=4; 
            gainExp(3);
            showHint('ğŸ’¥ çˆ†å¼¾ã§é›ªã‚ªã‚ªã‚«ãƒŸæ’ƒç ´!'); 
          } 
        }
        for (const sc of bombEntities.scorpions){ 
          if (!sc.dead && hitRect(sc)){ 
            sc.dead=true; 
            state.coins+=5; 
            gainExp(3);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚µã‚½ãƒªæ’ƒç ´!'); 
          } 
        }
        for (const k of bombEntities.krakens){ 
          if (!k.dead && hitRect(k)){ 
            k.dead=true; 
            state.coins+=6; 
            gainExp(4);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³æ’ƒç ´!'); 
          } 
        }
        for (const f of bombEntities.firespirits){ 
          if (!f.dead && hitRect(f)){ 
            f.dead=true; 
            state.coins+=4; 
            gainExp(2);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ç‚ã®ç²¾éœŠæ’ƒç ´!'); 
          } 
        }
        if (hitRect(player)) hitPlayer(2);
      } 
    }
    
    // å¾Œç‰‡ä»˜ã‘
    for (let i=bombs.length-1;i>=0;i--){ 
      if (bombs[i].exploded && bombs[i].t<=-0.3) bombs.splice(i,1); 
    }
    for (const ex of blasts){ ex.t-=dt; }
    for (let i=arrows.length-1;i>=0;i--) if (arrows[i].dead) arrows.splice(i,1);
    for (let i=blasts.length-1;i>=0;i--) if (blasts[i].t<=0) blasts.splice(i,1);

    // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«
    tutorialTick(dt, { 
      moved: (Math.abs(Input.ax)+Math.abs(Input.ay))>0.5, 
      attacked: Input.aDown, 
      opened: (Input.bDown && canOpen), 
      talked: (Input.bDown && canTalk)
    });

    // UIæ›´æ–°
    renderHUD(); 
    if (state.hintTimer > 0) {
      state.hintTimer -= dt;
      if (state.hintTimer <= 0) hintEl.classList.remove('show');
    }
    
    // å¹ãå‡ºã—ã®ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
    if (speechBubbleTimer > 0) {
      speechBubbleTimer -= dt;
      if (speechBubbleTimer <= 0) {
        hideSpeechBubble();
      }
    }
  }

  // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
  let acc = 0; 
  const FIXED = 1/60; 
  let last = performance.now();
  
  function loop(){
    const t = performance.now(); 
    let dt = (t - last)/1000; 
    last = t; 
    dt = Math.min(dt, 0.05);

    if (!state.paused){
      acc += dt; 
      while (acc >= FIXED){ 
        Input.updateEdges(); 
        update(FIXED); 
        acc -= FIXED; 
        Input.aDown=Input.bDown=Input.xDown=false; 
      }
      draw();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«
  const tut = document.getElementById('tutorial');
  const tutContent = document.getElementById('tutContent');
  const tutNext = document.getElementById('tutNext');
  const tutSkip = document.getElementById('tutSkip');
  
  const steps = [
    { text: 'ğŸ® å·¦ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‹çŸ¢å°ã‚­ãƒ¼ã§æ­©ã„ã¦ã¿ã¾ã—ã‚‡ã†ï¼', check: s=> s.moved },
    { text: 'âš”ï¸ âš”ï¸ãƒœã‚¿ãƒ³ã§æ”»æ’ƒï¼ã‚¹ãƒ©ã‚¤ãƒ ã‚’å€’ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚', check: s=> s.attacked },
    { text: 'ğŸ’¬ ğŸ’¬ãƒœã‚¿ãƒ³ã§å®ç®±ã‚’é–‹ã‘ãŸã‚Šã€é­”æ³•ä½¿ã„ã¨è©±ã—ãŸã‚Šã§ãã¾ã™ã€‚', check: s=> s.opened || s.talked },
    { text: 'ğŸ’£ ğŸ’£ãƒœã‚¿ãƒ³ã§çˆ†å¼¾ã‚’è¨­ç½®ï¼æ•µã‚’ã¾ã¨ã‚ã¦å€’ã›ã¾ã™ã€‚ã•ã‚å†’é™ºã—ã‚ˆã†ï¼', check: s=> true },
  ];
  
  function tutorialOpen(){ 
    state.tutorialStep = 0; 
    tut.showModal(); 
    renderStep(); 
  }
  
  function renderStep(){ 
    tutContent.innerHTML = `<p>${steps[state.tutorialStep].text}</p>`; 
  }
  
  function tutorialTick(dt, flags){
    const st = steps[state.tutorialStep]; 
    if (!st) return; 
    if (st.check(flags)) nextStep();
  }
  
  function nextStep(){ 
    state.tutorialStep++; 
    if (state.tutorialStep >= steps.length){ 
      tut.close(); 
      showHint('ğŸŒŸ å†’é™ºã‚’æ¥½ã—ã‚“ã§ã­ï¼', 4.0); 
      Sound.playSound('level');
    } else { 
      renderStep(); 
    } 
  }
  
  tutNext.addEventListener('click', ()=> { nextStep(); Sound.playSound('button'); });
  tutSkip.addEventListener('click', ()=> { tut.close(); Sound.playSound('button'); });
  setTimeout(tutorialOpen, 800);

  // ãƒãƒ¼ã‚º
  const pause = document.getElementById('pause');
  const btnPause = document.getElementById('btnPause');
  const btnClose = document.getElementById('btnClose');

  function togglePause(){
    state.paused = !state.paused;
    if (state.paused){ pause.showModal(); } else { pause.close(); }
  }

  btnPause.addEventListener('click', ()=> { togglePause(); Sound.playSound('button'); });
  btnClose.addEventListener('click', ()=> { togglePause(); Sound.playSound('button'); });

  // åˆæœŸåŒ–
  markMapVisited(currentMapX, currentMapY); // åˆæœŸãƒãƒƒãƒ—ã‚’è¨ªå•æ¸ˆã¿ã«
  renderHUD();
  drawMinimap(); // åˆæœŸãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’æç”»
  showHint('ğŸ® ç§»å‹•ã—ã¦ã¿ã‚ˆã†', 3);

})();
</script>
</body>
</html>
