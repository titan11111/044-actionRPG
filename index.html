<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover, user-scalable=no" />
<meta name="apple-mobile-web-app-capable" content="yes" />
<title>ã¼ã†ã‘ã‚“RPG - å‹‡è€…ã®æ—…ç«‹ã¡</title>
<style>
  :root {
    --bg: #0b0c10;
    --panel: rgba(255,255,255,0.06);
    --panel-strong: rgba(255,255,255,0.12);
    --outline: rgba(255,255,255,0.24);
    --text: #eef2f6;
    --muted: #aab2bf;
    --accent: #8bd3ff;
    --danger: #ff6b6b;
    --gold: #ffd56c;
    --btn-size: 64px;
    --font-scale: 1;
    --landscape-scale: 1; /* ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ï¼ˆç¸¦ç”»é¢æ™‚ï¼‰ */
  }

  /* æ¨ªç”»é¢æ™‚ã®ã‚¹ã‚±ãƒ¼ãƒ«èª¿æ•´ */
  @media (orientation: landscape) and (max-height: 400px) {
    :root {
      --landscape-scale: 0.6;
    }
  }
  @media (orientation: landscape) and (min-height: 401px) and (max-height: 500px) {
    :root {
      --landscape-scale: 0.7;
    }
  }
  @media (orientation: landscape) and (min-height: 501px) and (max-height: 600px) {
    :root {
      --landscape-scale: 0.8;
    }
  }
  @media (orientation: landscape) and (min-height: 601px) {
    :root {
      --landscape-scale: 1;
    }
  }

  html, body { height: 100%; margin: 0; }
  body {
    font-family: ui-sans-serif, system-ui, sans-serif;
    color: var(--text);
    background: radial-gradient(1200px 800px at 50% 10%, #141720, #0b0c10 60%);
    overflow: hidden;
    -webkit-user-select: none; user-select: none;
    touch-action: manipulation; /* iOSã®ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ ã‚’ç„¡åŠ¹åŒ– */
    -webkit-touch-callout: none; /* iOSã®é•·æŠ¼ã—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ç„¡åŠ¹åŒ– */
  }

  #root {
    position: fixed; inset: 0;
    display: grid; place-items: center;
  }

  .stage {
    position: relative;
    width: min(100vw, 100vh * 16/9);
    height: min(100vh, 100vw * 9/16);
    border-radius: 16px;
    background: linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.3));
    box-shadow: 0 20px 60px rgba(0,0,0,0.5);
    border: 1px solid rgba(255,255,255,0.08);
    overflow: hidden;
  }

  #game {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
    background: #151821;
  }

  .hud { 
    position:absolute; inset:0; pointer-events:none; 
    font-size: calc(14px * var(--font-scale)); 
  }

  .hud-top { 
    position:absolute; top: 8px; left:8px; right:8px; 
    display:flex; align-items:flex-start; justify-content:space-between; gap:8px; 
  }

  .hud-right {
    position: absolute;
    top: 8px;
    right: 8px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    align-items: flex-end;
    z-index: 10;
    /* å³ä¸Šã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨å³ä¸‹ã®ãƒœã‚¿ãƒ³ãŒé‡ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ */
    max-width: calc(100vw - 250px); /* å³å´ã®ãƒœã‚¿ãƒ³ã‚¨ãƒªã‚¢ï¼ˆX+ğŸ’+A+Bï¼‰ã‚’ç¢ºä¿ */
  }
  
  .hud-right .stats-row {
    display: flex;
    flex-direction: row;
    gap: 8px;
    align-items: center;
  }

  .hud-left {
    display: none; /* ç¸¦ç”»é¢æ™‚ã¯éè¡¨ç¤º */
  }

  .minimap-landscape,
  .hearts-landscape,
  .stats-landscape {
    display: none; /* ç¸¦ç”»é¢æ™‚ã¯éè¡¨ç¤º */
  }

  .hearts { 
    display:flex; 
    flex-wrap: nowrap; /* 2æ®µã«ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ */
    gap:4px; 
    background: var(--panel); 
    border:1px solid var(--outline); 
    padding:8px 12px; 
    border-radius:12px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    max-width: calc(24px * 10 + 4px * 9 + 24px); /* æœ€å¤§10å€‹ã®æ˜ŸãŒåã¾ã‚‹å¹… */
  }
  .heart { 
    width:24px; height:24px; 
    flex-shrink: 0; /* æ˜Ÿã®ã‚µã‚¤ã‚ºã‚’å›ºå®š */
    background: #ff4364;
    clip-path: polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%);
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    animation: heartbeat 1.5s ease-in-out infinite;
  }
  .heart.empty { 
    background: #666; 
    filter: grayscale(1) brightness(0.6);
    animation: none;
  }
  
  @keyframes heartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
  }

  .counter { 
    pointer-events:auto; 
    display:flex; align-items:center; gap:8px; 
    background: var(--panel); 
    border:1px solid var(--outline); 
    padding:8px 12px; border-radius: 999px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  
  .coin { 
    width:20px; height:20px; border-radius:50%; 
    background: radial-gradient(circle at 35% 35%, #fff7bf, var(--gold)); 
    border:2px solid #b8860b; 
    box-shadow: inset 0 0 4px rgba(0,0,0,0.3), 0 2px 4px rgba(0,0,0,0.2);
    animation: coinSpin 3s linear infinite;
  }
  
  @keyframes coinSpin {
    0%, 100% { transform: rotateY(0deg); }
    50% { transform: rotateY(180deg); }
  }

  .btn-ghost { 
    pointer-events:auto; 
    background: var(--panel); border:1px solid var(--outline); 
    color: var(--text); padding:8px 12px; border-radius:12px; 
    font-weight:700; box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    transition: all 0.2s ease; cursor: pointer;
  }
  .btn-ghost:active { transform: scale(0.96); }

  .hint { 
    position:absolute; left:50%; transform: translateX(-50%); 
    bottom: 68px; background: var(--panel); 
    border:1px solid var(--outline); padding:8px 12px; 
    border-radius:12px; opacity:0; transition: opacity .2s ease;
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
  }
  .hint.show { opacity: 1; }

  /* ç”»é¢å›è»¢æ¡ˆå†… */
  .rotate-hint {
    position: fixed;
    inset: 0;
    background: rgba(11, 12, 16, 0.95);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 10000;
    flex-direction: column;
    gap: 20px;
  }
  .rotate-hint.show {
    display: flex;
  }
  .rotate-hint-content {
    text-align: center;
    color: var(--text);
    font-size: calc(24px * var(--font-scale));
    font-weight: 700;
    padding: 20px;
    background: var(--panel);
    border: 2px solid var(--outline);
    border-radius: 16px;
    box-shadow: 0 8px 16px rgba(0,0,0,0.5);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 16px;
  }
  .rotate-hint-icon {
    font-size: 64px;
    animation: rotate 2s linear infinite;
  }
  @keyframes rotate {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(90deg); }
  }
  .btn-fullscreen {
    pointer-events: auto;
    background: var(--accent);
    border: 2px solid var(--outline);
    color: var(--text);
    padding: 12px 24px;
    border-radius: 12px;
    font-weight: 700;
    font-size: calc(18px * var(--font-scale));
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    margin-top: 8px;
  }
  .btn-fullscreen:active {
    transform: scale(0.96);
    background: var(--panel-strong);
  }

  .virtual { position:absolute; inset:0; pointer-events:none; }
  
  .stick { 
    position:absolute; left: 60px; bottom: 80px; 
    width: 176px; height: 176px; pointer-events:auto; 
    transform: scale(1.5);
  }
  .stick .base { 
    position:absolute; inset: 0; border-radius:50%; 
    background: var(--panel); border: 2px solid var(--outline);
    box-shadow: inset 0 4px 8px rgba(0,0,0,0.3), 0 4px 12px rgba(0,0,0,0.2);
  }
  .stick .knob { 
    --k: calc(var(--btn-size) * 0.75); 
    position:absolute; left: 50%; top: 50%; 
    width: var(--k); height: var(--k); 
    transform: translate(-50%,-50%); border-radius: 50%; 
    background: linear-gradient(135deg, var(--panel-strong), var(--panel)); 
    border: 2px solid var(--outline); 
    box-shadow: 0 4px 8px rgba(0,0,0,0.35);
  }

  .btn-top-row {
    position: absolute;
    right: 70px;
    bottom: calc(90px + var(--btn-size) + 12px);
    display: flex;
    flex-direction: row;
    gap: 12px;
    align-items: center;
    pointer-events: auto;
    z-index: 10;
    transform: scale(1.7);
  }
  
  .btn-bottom-row {
    position: absolute;
    right: 70px;
    bottom: 40px;
    display: flex;
    flex-direction: row;
    gap: 12px;
    align-items: center;
    pointer-events: auto;
    z-index: 10;
    transform: scale(1.7);
  }
  
  .btn-item-select {
    width: var(--btn-size);
    height: var(--btn-size);
    border-radius: 50%;
    background: linear-gradient(135deg, var(--panel-strong), var(--panel));
    border: 2px solid var(--outline);
    display: grid;
    place-items: center;
    font-size: 2em;
    line-height: 1;
    box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    transition: all 0.2s ease;
    cursor: pointer;
    pointer-events: auto;
  }
  
  .btn-item-select:active {
    transform: scale(0.92);
    box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  }
  
  .btn { 
    width: var(--btn-size); height: var(--btn-size); 
    border-radius: 50%; 
    background: linear-gradient(135deg, var(--panel-strong), var(--panel)); 
    border:2px solid var(--outline); 
    display:grid; place-items:center; 
    font-weight: 800; font-size: calc(16px * var(--font-scale));
    box-shadow: 0 6px 12px rgba(0,0,0,0.35);
    transition: all 0.2s ease; cursor: pointer;
  }
  .btn:active { 
    transform: scale(0.92); 
    box-shadow: 0 2px 6px rgba(0,0,0,0.4);
  }
  .btn.a { background: linear-gradient(135deg, #ff6b6b, #e74c3c); color: white; }
  .btn.b { background: linear-gradient(135deg, #4ecdc4, #45b7b8); color: white; }
  .btn.x { background: linear-gradient(135deg, #f39c12, #e67e22); color: white; }

  dialog { border: none; padding: 0; background: transparent; }
  .sheet { 
    width: min(92vw, 480px); 
    background: rgba(18,20,28,0.9); backdrop-filter: blur(8px); 
    border: 1px solid var(--outline); color: var(--text); 
    border-radius: 16px; overflow: hidden;
    box-shadow: 0 20px 40px rgba(0,0,0,0.5);
  }
  .sheet header { 
    padding: 16px 20px; font-weight: 800; 
    border-bottom: 1px solid var(--outline);
    background: var(--panel); font-size: calc(18px * var(--font-scale));
  }
  .sheet .content { padding: 16px 20px; }
  .sheet .actions { 
    padding: 16px 20px; display:flex; gap: 12px; 
    justify-content:flex-end; border-top: 1px solid var(--outline);
    background: var(--panel);
  }

  .level-up {
    position: absolute; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: calc(24px * var(--font-scale));
    font-weight: 800; color: var(--gold);
    text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
    opacity: 0; pointer-events: none;
  }

  @keyframes levelUpAnim {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
    20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
    80% { opacity: 1; transform: translate(-50%, -60%) scale(1); }
    100% { opacity: 0; transform: translate(-50%, -70%) scale(1); }
  }

  .speech-bubble {
    position: absolute;
    background: rgba(255, 255, 255, 0.95);
    color: #1a1a1a;
    padding: 18px 24px;
    border-radius: 18px;
    font-size: calc(18px * var(--font-scale));
    font-weight: 500;
    line-height: 1.4;
    max-width: 300px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    border: 2px solid rgba(0,0,0,0.1);
    pointer-events: none;
    opacity: 0;
    transform: translateY(10px);
    transition: opacity 0.3s ease, transform 0.3s ease;
    z-index: 1000;
    white-space: pre-line;
    text-align: left;
  }

  .speech-bubble.show {
    opacity: 1;
    transform: translateY(0);
  }

  .speech-bubble::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 20px;
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid rgba(255, 255, 255, 0.95);
  }

  .minimap {
    position: absolute;
    top: 8px;
    left: 8px;
    width: 198px;
    height: 198px;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid var(--outline);
    border-radius: 8px;
    pointer-events: none;
    z-index: 100;
    box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  }

  .minimap canvas {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
  }

  @media (orientation: landscape) {
    
    .stage {
      width: 100vw;
      height: 100vh;
      border-radius: 0;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: center;
    }

    #game {
      flex: 1;
      /* 16:9ã®ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã‚’ç¶­æŒã—ã¤ã¤ã€ç”»é¢ã®é«˜ã•ã«åã¾ã‚‹ã‚ˆã†ã« */
      --game-padding: calc(32px * var(--landscape-scale));
      height: calc(100vh - var(--game-padding));
      max-height: calc(100vh - var(--game-padding));
      width: calc((100vh - var(--game-padding)) * 16 / 9);
      max-width: calc(100vw - calc(400px * var(--landscape-scale)));
      object-fit: contain;
    }

    .hud {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
      pointer-events: none;
      font-size: calc(14px * var(--landscape-scale));
    }

    .minimap {
      display: none; /* æ¨ªç”»é¢æ™‚ã¯éè¡¨ç¤º */
    }

    .minimap-landscape {
      display: block !important;
      position: absolute;
      top: calc(8px * var(--landscape-scale));
      left: calc(8px * var(--landscape-scale));
      width: calc(118.8px * var(--landscape-scale));
      height: calc(118.8px * var(--landscape-scale));
      margin: 0;
      pointer-events: auto;
      z-index: 10;
    }

    .hud-right {
      display: none; /* æ¨ªç”»é¢æ™‚ã¯éè¡¨ç¤º */
    }

    .hud-left {
      display: flex !important;
      flex-direction: column;
      align-items: flex-end;
      gap: calc(8px * var(--landscape-scale));
      position: absolute;
      top: calc(12px * var(--landscape-scale));
      right: calc(12px * var(--landscape-scale));
      margin: 0;
      pointer-events: none;
    }

    .hud-left .minimap-landscape {
      display: none !important; /* .hud-leftå†…ã®minimap-landscapeã¯éè¡¨ç¤º */
    }

    .hearts-landscape {
      display: flex !important;
      flex-wrap: nowrap; /* 2æ®µã«ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ */
      gap: calc(4px * var(--landscape-scale));
      padding: calc(8px * var(--landscape-scale)) calc(12px * var(--landscape-scale));
      max-width: calc(24px * 10 * var(--landscape-scale) + 4px * 9 * var(--landscape-scale) + 24px * var(--landscape-scale)); /* æœ€å¤§10å€‹ã®æ˜ŸãŒåã¾ã‚‹å¹… */
    }

    .hearts-landscape .heart {
      width: calc(24px * var(--landscape-scale));
      height: calc(24px * var(--landscape-scale));
      flex-shrink: 0; /* æ˜Ÿã®ã‚µã‚¤ã‚ºã‚’å›ºå®š */
    }

    .stats-landscape {
      display: flex !important;
      flex-direction: row !important;
      align-items: center !important;
      gap: calc(8px * var(--landscape-scale));
    }

    .stats-landscape .counter {
      padding: calc(8px * var(--landscape-scale)) calc(12px * var(--landscape-scale));
      font-size: calc(14px * var(--landscape-scale));
    }

    .stats-landscape .coin {
      width: calc(20px * var(--landscape-scale));
      height: calc(20px * var(--landscape-scale));
    }

    .stats-landscape .btn-ghost {
      padding: calc(8px * var(--landscape-scale)) calc(12px * var(--landscape-scale));
      font-size: calc(2em * var(--landscape-scale));
    }

    .hud-left > * {
      pointer-events: auto;
    }

    .virtual {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: row;
      align-items: flex-end;
      justify-content: space-between;
      padding: calc(8px * var(--landscape-scale));
      pointer-events: none;
      box-sizing: border-box;
    }

    .stick {
      position: absolute;
      left: calc(58px * var(--landscape-scale)); /* å³ä¸Šã«40pxç§»å‹•ï¼ˆ18px + 40pxï¼‰ */
      bottom: calc(78px * var(--landscape-scale)); /* ä¸Šã«40pxç§»å‹•ï¼ˆ38px + 40pxï¼‰ */
      width: calc(121px * var(--landscape-scale));
      height: calc(121px * var(--landscape-scale));
      margin: 0;
      pointer-events: auto;
      z-index: 10;
      transform: scale(1.5);
    }

    .btn-top-row {
      position: absolute;
      right: calc(68px * var(--landscape-scale)); /* å³ä¸Šã«60pxç§»å‹•ï¼ˆ8px + 60pxï¼‰ */
      bottom: calc((88px + 64px + 16px) * var(--landscape-scale));
      gap: calc(12px * var(--landscape-scale));
      pointer-events: auto;
      z-index: 10;
      transform: scale(1.7);
    }
    
    .btn-bottom-row {
      position: absolute;
      right: calc(68px * var(--landscape-scale)); /* å³ä¸Šã«60pxç§»å‹•ï¼ˆ8px + 60pxï¼‰ */
      bottom: calc(38px * var(--landscape-scale));
      gap: calc(12px * var(--landscape-scale));
      pointer-events: auto;
      z-index: 10;
      transform: scale(1.7);
    }

    .btn-top-row .btn,
    .btn-bottom-row .btn {
      width: calc(64px * var(--landscape-scale));
      height: calc(64px * var(--landscape-scale));
      font-size: calc(16px * var(--landscape-scale));
    }
    
    /* æ¨ªç”»é¢æ™‚ã‚‚å³ä¸Šã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã¨å³ä¸‹ã®ãƒœã‚¿ãƒ³ãŒé‡ãªã‚‰ãªã„ã‚ˆã†ã«ã™ã‚‹ */
    .hud-left {
      max-width: calc(100vw - 300px * var(--landscape-scale));
    }
    
    .btn-item-select {
      width: calc(64px * var(--landscape-scale));
      height: calc(64px * var(--landscape-scale));
      font-size: calc(2em * var(--landscape-scale));
    }

    .hint {
      left: 50%;
      bottom: auto;
      top: 50%;
      transform: translate(-50%, -50%);
      font-size: calc(14px * var(--landscape-scale));
      padding: calc(8px * var(--landscape-scale)) calc(12px * var(--landscape-scale));
    }

    /* iOSå‘ã‘æœ€é©åŒ–ï¼ˆæ¨ªç”»é¢æ™‚ï¼‰ */
    @supports (-webkit-touch-callout: none) {
      .stick {
        left: calc(108px * var(--landscape-scale)); /* å·¦ã«10pxç§»å‹•ï¼ˆ98px + 10pxï¼‰ */
        bottom: calc(118px * var(--landscape-scale)); /* ä¸Šã«40pxç§»å‹•ï¼ˆ78px + 40pxï¼‰ */
        transform: scale(1.65); /* 1.1å€ã«æ‹¡å¤§ï¼ˆ1.5 * 1.1ï¼‰ */
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
      }

      .btn-top-row,
      .btn-bottom-row {
        right: calc(98px * var(--landscape-scale)); /* å³ä¸‹ã«10pxç§»å‹•ï¼ˆ108px - 10pxï¼‰ */
        transform: scale(1.87); /* 1.1å€ã«æ‹¡å¤§ï¼ˆ1.7 * 1.1ï¼‰ */
      }

      .btn-top-row {
        bottom: calc((116px + 64px + 16px) * var(--landscape-scale)); /* ä¸‹ã«12pxç§»å‹•ï¼ˆ128px - 12pxï¼‰ */
      }

      .btn-bottom-row {
        bottom: calc(68px * var(--landscape-scale)); /* å³ä¸‹ã«10pxç§»å‹•ï¼ˆ78px - 10pxï¼‰ */
      }

      .btn-top-row .btn,
      .btn-bottom-row .btn,
      .btn-item-select {
        touch-action: manipulation;
        -webkit-tap-highlight-color: transparent;
      }

      /* å³ä¸‹ã®ãƒœã‚¿ãƒ³å°‚ç”¨ã®å¼·åŒ–ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆiOSæ¨ªç”»é¢ï¼‰ */
      .btn-bottom-row .btn:active {
        transform: scale(0.75) !important;
        box-shadow: 0 2px 8px rgba(0,0,0,0.6), inset 0 3px 6px rgba(0,0,0,0.4);
      }
    }
  }

  /* ãƒœã‚¿ãƒ³ã®æ‰“æ„Ÿã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆå¼·åŒ–ç‰ˆï¼‰ */
  @keyframes buttonPress {
    0% { transform: scale(1); }
    30% { transform: scale(0.75); }
    70% { transform: scale(0.88); }
    100% { transform: scale(0.95); }
  }

  .btn.pressed {
    animation: buttonPress 0.08s ease-out;
    box-shadow: 0 4px 12px rgba(0,0,0,0.5), inset 0 2px 4px rgba(0,0,0,0.3);
  }

  /* å³ä¸‹ã®ãƒœã‚¿ãƒ³å°‚ç”¨ã®å¼·åŒ–ã‚¹ã‚¿ã‚¤ãƒ« */
  .btn-bottom-row .btn {
    transition: transform 0.05s ease-out, box-shadow 0.05s ease-out;
  }

  .btn-bottom-row .btn:active {
    transform: scale(0.80) !important;
    box-shadow: 0 2px 8px rgba(0,0,0,0.6), inset 0 3px 6px rgba(0,0,0,0.4);
  }

  /* iOSå‘ã‘æœ€é©åŒ– */
  @supports (-webkit-touch-callout: none) {
    .stick {
      left: 110px; /* å·¦ã«10pxç§»å‹•ï¼ˆ100px + 10pxï¼‰ */
      bottom: 120px; /* ä¸Šã«40pxç§»å‹•ï¼ˆ80px + 40pxï¼‰ */
      transform: scale(1.65); /* 1.1å€ã«æ‹¡å¤§ï¼ˆ1.5 * 1.1ï¼‰ */
      touch-action: none; /* iOSã®ã‚¿ãƒƒãƒæ“ä½œã‚’æœ€é©åŒ– */
      -webkit-user-select: none;
      user-select: none;
    }

    .btn-top-row,
    .btn-bottom-row {
      right: 100px; /* å³ä¸‹ã«10pxç§»å‹•ï¼ˆ110px - 10pxï¼‰ */
      transform: scale(1.87); /* 1.1å€ã«æ‹¡å¤§ï¼ˆ1.7 * 1.1ï¼‰ */
    }

    .btn-top-row {
      bottom: calc(118px + var(--btn-size) + 12px); /* ä¸‹ã«12pxç§»å‹•ï¼ˆ130px - 12pxï¼‰ */
    }

    .btn-bottom-row {
      bottom: 70px; /* å³ä¸‹ã«10pxç§»å‹•ï¼ˆ80px - 10pxï¼‰ */
    }

    .btn-top-row .btn,
    .btn-bottom-row .btn,
    .btn-item-select {
      touch-action: manipulation; /* iOSã®ã‚¿ãƒƒãƒæ“ä½œã‚’æœ€é©åŒ– */
      -webkit-tap-highlight-color: transparent; /* ã‚¿ãƒƒãƒ—æ™‚ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ç„¡åŠ¹åŒ– */
    }

    /* å³ä¸‹ã®ãƒœã‚¿ãƒ³å°‚ç”¨ã®å¼·åŒ–ã‚¹ã‚¿ã‚¤ãƒ«ï¼ˆiOSï¼‰ */
    .btn-bottom-row .btn:active {
      transform: scale(0.75) !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.6), inset 0 3px 6px rgba(0,0,0,0.4);
    }
  }
</style>
</head>
<body>
  <div id="root">
    <div class="stage">
      <canvas id="game" width="320" height="180"></canvas>

      <div class="hud">
        <div class="minimap">
          <canvas id="minimap" width="150" height="150"></canvas>
        </div>
        <div class="minimap minimap-landscape">
          <canvas id="minimap-landscape" width="150" height="150"></canvas>
        </div>
        <div class="hud-left">
          <div class="hearts hearts-landscape" id="hearts-landscape"></div>
          <div class="stats-landscape">
            <div class="counter">
              <div class="coin"></div>
              <span id="coins-landscape">0</span>
            </div>
            <div class="counter" style="background: linear-gradient(135deg, var(--panel), rgba(139,211,255,0.1));">
              <span style="color: var(--accent); font-weight: 800;">Lv</span>
              <span id="level-landscape">1</span>
            </div>
          </div>
        </div>
        <div class="hud-right">
          <div class="hearts" id="hearts"></div>
          <div class="stats-row">
            <div class="counter">
              <div class="coin"></div>
              <span id="coins">0</span>
            </div>
            <div class="counter" style="background: linear-gradient(135deg, var(--panel), rgba(139,211,255,0.1));">
              <span style="color: var(--accent); font-weight: 800;">Lv</span>
              <span id="level">1</span>
            </div>
          </div>
        </div>
        <div class="hint" id="hint">ğŸ® ç§»å‹•ã—ã¦ã¿ã‚ˆã†</div>
        <div class="level-up" id="levelUp" style="display: none;">ğŸŒŸ LEVEL UP! ğŸŒŸ</div>
        <div class="speech-bubble" id="speechBubble"></div>
      </div>

      <div class="virtual">
        <div class="stick" id="stick">
          <div class="base"></div>
          <div class="knob" id="stickKnob"></div>
        </div>
        <div class="btn-top-row">
          <button class="btn-item-select" id="btnPause" title="æŒã¡ç‰©">ğŸ’</button>
          <button class="btn b" id="btnB" title="ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆå®ç®±ãƒ»ä¼šè©±ï¼‰">
            <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; overflow: hidden; padding: 2px;">
              <div style="font-size: 18px; line-height: 1;">ğŸ/ğŸ’¬</div>
              <div style="font-size: 8px; color: rgba(255,255,255,0.7); margin-top: 1px; line-height: 1;">Z</div>
            </div>
          </button>
        </div>
        <div class="btn-bottom-row">
          <button class="btn x" id="btnX" title="æ­¦å™¨ä½¿ç”¨">
            <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
              <div id="weaponIcon" style="font-size: 20px;">ğŸ’£</div>
              <div style="font-size: 9px; color: rgba(255,255,255,0.7); margin-top: 2px;">X</div>
            </div>
          </button>
          <button class="btn a" id="btnA" title="æ”»æ’ƒ">
            <div style="position: relative; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center;">
              <div style="font-size: 20px;">âš”ï¸</div>
              <div style="font-size: 9px; color: rgba(255,255,255,0.7); margin-top: 2px;">J/SP</div>
            </div>
          </button>
        </div>
      </div>

      <dialog id="tutorial">
        <div class="sheet">
          <header>ğŸ® ã¼ã†ã‘ã‚“ã®å§‹ã¾ã‚Š</header>
          <div class="content" id="tutContent">
            <p>ã‚ˆã†ã“ãã€å‹‡è€…ã•ã‚“ï¼ã¾ãšã¯æ­©ã„ã¦ã¿ã¾ã—ã‚‡ã†ã€‚</p>
          </div>
          <div class="actions">
            <button class="btn-ghost" id="tutSkip">ã‚¹ã‚­ãƒƒãƒ—</button>
            <button class="btn-ghost" id="tutNext">æ¬¡ã¸ â¡ï¸</button>
          </div>
        </div>
      </dialog>

      <dialog id="weaponSelect">
        <div class="sheet">
          <header>ğŸ’ æŒã¡ç‰©</header>
          <div class="content" id="weaponList">
            <!-- æ­¦å™¨ãƒªã‚¹ãƒˆã¯JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
          </div>
          <div class="actions">
            <button class="btn-ghost" id="btnCloseWeapon">é–‰ã˜ã‚‹</button>
          </div>
        </div>
      </dialog>

      <dialog id="chiefEvent">
        <div class="sheet">
          <header>ğŸ‘´ æ‘é•·ã‹ã‚‰ã®ç›¸è«‡</header>
          <div class="content" id="chiefEventContent">
            <!-- å†…å®¹ã¯JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
          </div>
          <div class="actions">
            <button class="btn-ghost" id="btnChiefYes">ã¯ã„</button>
            <button class="btn-ghost" id="btnChiefNo">ã„ã„ãˆ</button>
          </div>
        </div>
      </dialog>

      <dialog id="ending">
        <div class="sheet">
          <header>ğŸ‰ ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°</header>
          <div class="content" id="endingContent">
            <!-- å†…å®¹ã¯JavaScriptã§å‹•çš„ã«ç”Ÿæˆ -->
          </div>
          <div class="actions">
            <button class="btn-ghost" id="btnEndingClose">é–‰ã˜ã‚‹</button>
          </div>
        </div>
      </dialog>

      <!-- ç”»é¢å›è»¢æ¡ˆå†…ï¼ˆæºå¸¯ãƒ—ãƒ¬ã‚¤æ™‚ï¼‰ -->
      <div class="rotate-hint" id="rotateHint">
        <div class="rotate-hint-icon">ğŸ“±</div>
        <div class="rotate-hint-content">
          <p style="margin: 0 0 12px 0;">ç”»é¢ã‚’æ¨ªã«ã—ã¦ãƒ—ãƒ¬ã‚¤ã—ã¦ãã ã•ã„</p>
          <p style="margin: 0; font-size: 0.7em; color: var(--muted);">æ¨ªã«ã—ãŸã‚‰è‡ªå‹•çš„ã«å…¨ç”»é¢å±•é–‹ã•ã‚Œã¾ã™</p>
          <button class="btn-fullscreen" id="btnFullscreen" style="display: none;">å…¨ç”»é¢ã§é–‹å§‹</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const dist2 = (x1,y1,x2,y2) => { const dx = x2-x1, dy = y2-y1; return dx*dx+dy*dy; };

  // ã‚­ãƒ£ãƒ³ãƒã‚¹
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W = 320, H = 180;

  // å®‰å…¨ãªå®šæ•°
  const TS = 16;
  const COLS = 20; // 320/16 = 20
  const ROWS = 11; // 180/16 = 11.25 -> 11
  const T = { GRASS:0, TREE:1, WATER:2, TALL:3, PATH:4, FLOWER:5, ROCK:6, SAND:7, CACTUS:8, SNOW:9, DESERT:10, ICE:11 };

  // ãƒãƒƒãƒ—ç”Ÿæˆé–¢æ•°
  function generateMap(type, mapX = 0, mapY = 0) {
    const map = [];
    for(let y = 0; y < ROWS; y++) {
      map[y] = [];
      for(let x = 0; x < COLS; x++) {
        map[y][x] = T.GRASS;
      }
    }

    switch(type) {
      case 'village': // ä¸­å¤®ï¼šæ‘ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
        // ãƒ‘ã‚¹
        for(let y = 3; y < 8 && y < ROWS; y++) {
          for(let x = 4; x < 16 && x < COLS; x++) {
            map[y][x] = T.PATH;
          }
        }
        // æœ¨ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 9; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        // æ°´ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 3; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.WATER;
          }
        }
        // èŠ±ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 5; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.FLOWER;
          }
        }
        break;

      case 'forest': // ä¸Šï¼šæ£®ã®ã‚¨ãƒªã‚¢
        // æœ¨ã‚’å¤šãé…ç½®ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 15; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        // ãƒ‘ã‚¹ã‚’å°‘ã—
        for(let y = 5; y < 6 && y < ROWS; y++) {
          for(let x = 2; x < 18 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // èŠ±ã‚’å°‘ã—ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 2; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.FLOWER;
          }
        }
        break;

      case 'coast': // ä¸‹ï¼šæµ·å²¸ã®ã‚¨ãƒªã‚¢
        // ä¸‹å´ã«æ°´ã‚’å¤šãé…ç½®
        for(let y = 7; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (Math.random() > 0.3) {
              map[y][x] = T.WATER;
            }
          }
        }
        // ç ‚æµœ
        for(let y = 5; y < 7 && y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.SAND;
            }
          }
        }
        // ãƒ‘ã‚¹
        for(let y = 2; y < 5 && y < ROWS; y++) {
          for(let x = 3; x < 17 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // æœ¨ã‚’å°‘ã—ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 5; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * 5);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        break;

      case 'cave': // å·¦ï¼šæ´çªŸã®ã‚¨ãƒªã‚¢
        // å²©ã‚’å¤šãé…ç½®ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 12; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.ROCK;
          }
        }
        // æ°´ï¼ˆæ´çªŸã®æ°´ãŸã¾ã‚Šï¼‰ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 5; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.WATER;
          }
        }
        // ãƒ‘ã‚¹
        for(let y = 4; y < 7 && y < ROWS; y++) {
          for(let x = 5; x < 15 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        break;

      case 'field': // å³ï¼šè‰åŸã®ã‚¨ãƒªã‚¢
        // èŠ±ã‚’å¤šãé…ç½®ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 9; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.FLOWER;
          }
        }
        // ãƒ‘ã‚¹
        for(let y = 3; y < 8 && y < ROWS; y++) {
          for(let x = 2; x < 18 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // æœ¨ã‚’å°‘ã—ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 3; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        break;

      case 'ruins': // åŒ—è¥¿ï¼šå»ƒå¢Ÿã®ã‚¨ãƒªã‚¢ï¼ˆæ£®ã¨æ´çªŸã®é–“ï¼‰
        // å²©ã‚’å¤šãé…ç½®ï¼ˆå»ƒå¢Ÿã®çŸ³ï¼‰ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 11; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.ROCK;
          }
        }
        // ä¸­å¤®ã«å¤§ããªéºè·¡ã‚¨ãƒªã‚¢
        for(let y = 4; y < 7 && y < ROWS; y++) {
          for(let x = 6; x < 14 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.ROCK;
            }
          }
        }
        // ãƒ‘ã‚¹ï¼ˆéºè·¡ã¸ã®é“ï¼‰
        for(let y = 2; y < 9 && y < ROWS; y++) {
          for(let x = 8; x < 12 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // æœ¨ã‚’å°‘ã—ï¼ˆæ£®ã®åæ®‹ï¼‰ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 2; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        break;

      case 'garden': // åŒ—æ±ï¼šèŠ±ç•‘ã®ã‚¨ãƒªã‚¢ï¼ˆæ£®ã¨è‰åŸã®é–“ï¼‰
        // èŠ±ã‚’å¤§é‡ã«é…ç½®ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 15; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.FLOWER;
          }
        }
        // ãƒ‘ã‚¹ï¼ˆèŠ±ç•‘ã®ä¸­ã®å°é“ï¼‰
        for(let y = 4; y < 7 && y < ROWS; y++) {
          for(let x = 3; x < 17 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // æœ¨ã‚’å°‘ã—ï¼ˆç¸ã«ï¼‰
        for(let i = 0; i < 5; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * 3);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        for(let i = 0; i < 5; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * 3) + 8;
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        break;

      case 'cavecoast': // å—è¥¿ï¼šæµ·å²¸æ´çªŸã®ã‚¨ãƒªã‚¢ï¼ˆæµ·å²¸ã¨æ´çªŸã®é–“ï¼‰
        // å·¦å´ã«æ´çªŸé¢¨ã€å³å´ã«æµ·å²¸é¢¨
        // å·¦å´ã«å²©ã‚’é…ç½®ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 8; i++){
          const x = Math.floor(Math.random() * 10);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.ROCK;
          }
        }
        // å³å´ã«æ°´ã‚’é…ç½®ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 5; i++){
          const x = Math.floor(Math.random() * 10) + 10;
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.WATER;
          }
        }
        // ä¸‹å´ã«ç ‚æµœ
        for(let y = 8; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.SAND;
            }
          }
        }
        // ä¸­å¤®ã«ãƒ‘ã‚¹
        for(let y = 3; y < 8 && y < ROWS; y++) {
          for(let x = 8; x < 12 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        break;

      case 'beach': // å—æ±ï¼šãƒ“ãƒ¼ãƒã®ã‚¨ãƒªã‚¢ï¼ˆæµ·å²¸ã¨è‰åŸã®é–“ï¼‰
        // ç ‚æµœã‚’å¤šãé…ç½®
        for(let y = 0; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS && Math.random() > 0.3) {
              map[y][x] = T.SAND;
            }
          }
        }
        // ä¸‹å´ã«æ°´
        for(let y = 7; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.SAND && Math.random() > 0.5) {
              map[y][x] = T.WATER;
            }
          }
        }
        // ãƒ‘ã‚¹ï¼ˆãƒ“ãƒ¼ãƒæ²¿ã„ï¼‰
        for(let y = 2; y < 6 && y < ROWS; y++) {
          for(let x = 2; x < 18 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.SAND) {
              map[y][x] = T.PATH;
            }
          }
        }
        // èŠ±ã‚’å°‘ã—ï¼ˆãƒ“ãƒ¼ãƒã®è£…é£¾ï¼‰ï¼ˆ30%ã«å‰Šæ¸›ï¼‰
        for(let i = 0; i < 3; i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * 6);
          if (map[y] && map[y][x] === T.SAND) {
            map[y][x] = T.FLOWER;
          }
        }
        break;

      case 'cactus': // åŒ—æ±æ–¹å‘ï¼šã‚µãƒœãƒ†ãƒ³ã€é™½æ°—ãªä¸–ç•Œ
        // ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åˆ¤å®šï¼ˆåŒ—æ±ã®å››éš…ï¼‰
        const isBossFieldNE = (mapX === 3 && mapY === -3);
        // ã‚µãƒœãƒ†ãƒ³ã‚’å¤šãé…ç½®ï¼ˆé€šå¸¸ã¯30%ã«å‰Šæ¸›ã€ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯10%ä»¥ä¸‹ã«æŠ‘ãˆã‚‹ï¼‰
        for(let i = 0; i < (isBossFieldNE ? 1 : 12); i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.CACTUS;
          }
        }
        // ãƒ‘ã‚¹ï¼ˆé™½æ°—ãªé“ï¼‰
        for(let y = 4; y < 7 && y < ROWS; y++) {
          for(let x = 3; x < 17 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS) {
              map[y][x] = T.PATH;
            }
          }
        }
        // èŠ±ã‚’å°‘ã—ï¼ˆæ˜ã‚‹ã„é›°å›²æ°—ã€é€šå¸¸ã¯30%ã«å‰Šæ¸›ã€ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯10%ä»¥ä¸‹ã«æŠ‘ãˆã‚‹ï¼‰
        for(let i = 0; i < (isBossFieldNE ? 1 : 6); i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.FLOWER;
          }
        }
        break;

      case 'snow': // åŒ—è¥¿æ–¹å‘ï¼šé›ªã€æ£®æ—åœ°å¸¯ã€å±±
        // é›ªã‚’å¤šãé…ç½®
        for(let y = 0; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS && Math.random() > 0.2) {
              map[y][x] = T.SNOW;
            }
          }
        }
        // ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åˆ¤å®šï¼ˆåŒ—è¥¿ã®å››éš…ï¼‰
        const isBossFieldNW = (mapX === -3 && mapY === -3);
        // å±±ï¼ˆå²©ï¼‰ã‚’é…ç½®ï¼ˆé€šå¸¸ã¯30%ã«å‰Šæ¸›ã€ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯10%ä»¥ä¸‹ã«æŠ‘ãˆã‚‹ï¼‰
        for(let i = 0; i < (isBossFieldNW ? 1 : 9); i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.SNOW) {
            map[y][x] = T.ROCK;
          }
        }
        // æ£®ï¼ˆæœ¨ï¼‰ã‚’é…ç½®ï¼ˆé€šå¸¸ã¯30%ã«å‰Šæ¸›ã€ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯10%ä»¥ä¸‹ã«æŠ‘ãˆã‚‹ï¼‰
        for(let i = 0; i < (isBossFieldNW ? 1 : 8); i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.SNOW) {
            map[y][x] = T.TREE;
          }
        }
        // ãƒ‘ã‚¹
        for(let y = 5; y < 6 && y < ROWS; y++) {
          for(let x = 2; x < 18 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.SNOW) {
              map[y][x] = T.PATH;
            }
          }
        }
        break;

      case 'desert': // å—è¥¿æ–¹å‘ï¼šç ‚æ¼ ã¨æ´çªŸ
        // ç ‚æ¼ ã‚’å¤šãé…ç½®
        for(let y = 0; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS && Math.random() > 0.3) {
              map[y][x] = T.DESERT;
            }
          }
        }
        // ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åˆ¤å®šï¼ˆå—è¥¿ã®å››éš…ï¼‰
        const isBossFieldSW = (mapX === -3 && mapY === 3);
        // æ´çªŸï¼ˆå²©ï¼‰ã‚’é…ç½®ï¼ˆé€šå¸¸ã¯30%ã«å‰Šæ¸›ã€ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯10%ä»¥ä¸‹ã«æŠ‘ãˆã‚‹ï¼‰
        for(let i = 0; i < (isBossFieldSW ? 1 : 11); i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.DESERT) {
            map[y][x] = T.ROCK;
          }
        }
        // ã‚µãƒœãƒ†ãƒ³ã‚’å°‘ã—ï¼ˆé€šå¸¸ã¯30%ã«å‰Šæ¸›ã€ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯10%ä»¥ä¸‹ã«æŠ‘ãˆã‚‹ï¼‰
        for(let i = 0; i < (isBossFieldSW ? 0 : 5); i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.DESERT) {
            map[y][x] = T.CACTUS;
          }
        }
        // ãƒ‘ã‚¹
        for(let y = 4; y < 7 && y < ROWS; y++) {
          for(let x = 5; x < 15 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.DESERT) {
              map[y][x] = T.PATH;
            }
          }
        }
        break;

      case 'ocean': // å—æ±æ–¹å‘ï¼šæ°´ã¨å³¶ã€æµ·æ´‹
        // æ°´ã‚’å¤šãé…ç½®
        for(let y = 0; y < ROWS; y++) {
          for(let x = 0; x < COLS; x++) {
            if (map[y] && map[y][x] === T.GRASS && Math.random() > 0.4) {
              map[y][x] = T.WATER;
            }
          }
        }
        // ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰åˆ¤å®šï¼ˆå—æ±ã®å››éš…ï¼‰
        const isBossFieldSE = (mapX === 3 && mapY === 3);
        // å³¶ï¼ˆè‰ï¼‰ã‚’é…ç½®ï¼ˆé€šå¸¸ã¯30%ã«å‰Šæ¸›ã€ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯10%ä»¥ä¸‹ã«æŠ‘ãˆã‚‹ï¼šå°ã•ãªå³¶ã®ã¿ï¼‰
        for(let i = 0; i < (isBossFieldSE ? 1 : 2); i++){
          const islandX = Math.floor(Math.random() * (COLS - 4)) + 2;
          const islandY = Math.floor(Math.random() * (ROWS - 4)) + 2;
          // ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã§ã¯å°ã•ãªå³¶ï¼ˆ3x3ï¼‰ã®ã¿ç”Ÿæˆ
          const size = isBossFieldSE ? 1 : 2;
          for(let y = islandY - size; y < islandY + size + 1 && y < ROWS; y++) {
            for(let x = islandX - size; x < islandX + size + 1 && x < COLS; x++) {
              if (map[y] && map[y][x] === T.WATER && Math.random() > (isBossFieldSE ? 0.5 : 0.3)) {
                map[y][x] = T.GRASS;
              }
            }
          }
        }
        // å³¶ã«æœ¨ã‚’é…ç½®ï¼ˆé€šå¸¸ã¯30%ã«å‰Šæ¸›ã€ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯10%ä»¥ä¸‹ã«æŠ‘ãˆã‚‹ï¼‰
        for(let i = 0; i < (isBossFieldSE ? 0 : 5); i++){
          const x = Math.floor(Math.random() * COLS);
          const y = Math.floor(Math.random() * ROWS);
          if (map[y] && map[y][x] === T.GRASS) {
            map[y][x] = T.TREE;
          }
        }
        // ãƒ‘ã‚¹ï¼ˆæ©‹ã®ã‚ˆã†ãªï¼‰
        for(let y = 2; y < 9 && y < ROWS; y++) {
          for(let x = 9; x < 11 && x < COLS; x++) {
            if (map[y] && map[y][x] === T.WATER) {
              map[y][x] = T.PATH;
            }
          }
        }
        break;
    }

    return map;
  }

  // ãƒãƒƒãƒ—ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
  const maps = new Map();
  let currentMapX = 0, currentMapY = 0;
  // ãƒãƒƒãƒ—ã®å¢ƒç•Œå®šç¾©ï¼ˆ-4ã‹ã‚‰4ã®ç¯„å›²ï¼‰
  const MIN_MAP_X = -4, MAX_MAP_X = 4;
  const MIN_MAP_Y = -4, MAX_MAP_Y = 4;
  const visitedMaps = new Set(); // è¨ªå•ã—ãŸãƒãƒƒãƒ—ã‚’è¨˜éŒ²
  
  function getMapKey(x, y) {
    return `${x},${y}`;
  }
  
  function markMapVisited(x, y) {
    visitedMaps.add(getMapKey(x, y));
  }
  
  function isMapVisited(x, y) {
    return visitedMaps.has(getMapKey(x, y));
  }
  
  function getCurrentMap() {
    const key = getMapKey(currentMapX, currentMapY);
    if (!maps.has(key)) {
      let mapType = 'village';
      // æ—¢å­˜ã®ãƒãƒƒãƒ—
      if (currentMapX === 0 && currentMapY === -1) mapType = 'forest';
      else if (currentMapX === 0 && currentMapY === 1) mapType = 'coast';
      else if (currentMapX === -1 && currentMapY === 0) mapType = 'cave';
      else if (currentMapX === 1 && currentMapY === 0) mapType = 'field';
      else if (currentMapX === -1 && currentMapY === -1) mapType = 'ruins';
      else if (currentMapX === 1 && currentMapY === -1) mapType = 'garden';
      else if (currentMapX === -1 && currentMapY === 1) mapType = 'cavecoast';
      else if (currentMapX === 1 && currentMapY === 1) mapType = 'beach';
      // æ–°ã—ã„ãƒãƒƒãƒ—ï¼šåŒ—æ±æ–¹å‘ï¼ˆã‚µãƒœãƒ†ãƒ³ã€é™½æ°—ãªä¸–ç•Œï¼‰
      else if (currentMapX >= 2 || (currentMapX > 0 && currentMapY <= -2)) mapType = 'cactus';
      // æ–°ã—ã„ãƒãƒƒãƒ—ï¼šåŒ—è¥¿æ–¹å‘ï¼ˆé›ªã€æ£®æ—åœ°å¸¯ã€å±±ï¼‰
      else if (currentMapX <= -2 || (currentMapX < 0 && currentMapY <= -2)) mapType = 'snow';
      // æ–°ã—ã„ãƒãƒƒãƒ—ï¼šå—è¥¿æ–¹å‘ï¼ˆç ‚æ¼ ã¨æ´çªŸï¼‰
      else if (currentMapX <= -2 || (currentMapX < 0 && currentMapY >= 2)) mapType = 'desert';
      // æ–°ã—ã„ãƒãƒƒãƒ—ï¼šå—æ±æ–¹å‘ï¼ˆæ°´ã¨å³¶ã€æµ·æ´‹ï¼‰
      else if (currentMapX >= 2 || (currentMapX > 0 && currentMapY >= 2)) mapType = 'ocean';
      // ãã®ä»–ã®å¢ƒç•Œã‚¨ãƒªã‚¢
      else if (currentMapY <= -2) {
        if (currentMapX < 0) mapType = 'snow';
        else mapType = 'cactus';
      } else if (currentMapY >= 2) {
        if (currentMapX < 0) mapType = 'desert';
        else mapType = 'ocean';
      } else if (currentMapX <= -2) {
        if (currentMapY < 0) mapType = 'snow';
        else mapType = 'desert';
      } else if (currentMapX >= 2) {
        if (currentMapY < 0) mapType = 'cactus';
        else mapType = 'ocean';
      }
      maps.set(key, generateMap(mapType, currentMapX, currentMapY));
    }
    return maps.get(key);
  }

  const isBlock = (t) => t === T.TREE || t === T.WATER || t === T.ROCK || t === T.CACTUS || t === T.ICE;

  // ã‚µã‚¦ãƒ³ãƒ‰
  // BGMç®¡ç†
  let bgmAudio = null;
  
  const initBGM = () => {
    if (!bgmAudio) {
      bgmAudio = new Audio('bgm.mp3');
      bgmAudio.loop = true;
      bgmAudio.volume = 0.5;
    }
  };
  
  const playBGM = () => {
    if (bgmAudio) {
      bgmAudio.currentTime = 0; // æœ€åˆã‹ã‚‰å†ç”Ÿ
      bgmAudio.play().catch(e => console.log('BGM play error:', e));
    }
  };
  
  const stopBGM = () => {
    if (bgmAudio) {
      bgmAudio.pause();
      bgmAudio.currentTime = 0;
    }
  };

  const Sound = (() => {
    let audioContext = null;
    let unlocked = false;
    
    const unlock = () => { 
      try {
        if (!audioContext) {
          audioContext = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioContext.state === 'suspended') audioContext.resume(); 
        unlocked = true;
        // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè§£ç¦æ™‚ã«BGMã‚’åˆæœŸåŒ–
        initBGM();
        playBGM();
      } catch(e) {
        console.log('Audio not supported');
      }
    };

    const playSound = (type) => {
      if (!unlocked || !audioContext) return;
      
      try {
        const beep = (f, t, waveType='square', g=0.04) => {
          const o = audioContext.createOscillator();
          const v = audioContext.createGain();
          o.type = waveType; 
          o.frequency.value = f;
          v.gain.value = g; 
          o.connect(v); 
          v.connect(audioContext.destination);
          const t0 = audioContext.currentTime;
          o.start(t0); 
          o.stop(t0 + t);
        };

        switch(type) {
          case 'sword': beep(880, 0.05); setTimeout(() => beep(660, 0.08), 50); break;
          case 'hit': beep(150, 0.15, 'sawtooth', 0.08); break;
          case 'coin': beep(659, 0.3, 'sine', 0.05); break;
          case 'chest': beep(523, 0.4, 'triangle', 0.06); break;
          case 'bomb': beep(80, 0.2, 'square', 0.12); break;
          case 'talk': beep(523, 0.2, 'triangle', 0.04); break;
          case 'level': 
            for(let i = 0; i < 5; i++) {
              setTimeout(() => beep(523 + i*100, 0.15, 'sine', 0.05), i * 100);
            }
            break;
          case 'button': beep(440, 0.05, 'square', 0.02); break;
        }
      } catch(e) {
        console.log('Audio error:', e);
      }
    };

    return { unlock, playSound, get unlocked() { return unlocked; } };
  })();

  // åˆå›ã‚¯ãƒªãƒƒã‚¯ã§ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªè§£ç¦
  const unlockAudio = () => {
    Sound.unlock();
    window.removeEventListener('pointerdown', unlockAudio);
  };
  window.addEventListener('pointerdown', unlockAudio);

  // iOSã®ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ã‚ºãƒ¼ãƒ é˜²æ­¢ï¼ˆdouble-tap zoom preventionï¼‰
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd < 300) {
      e.preventDefault();
    }
    lastTouchEnd = now;
  }, { passive: false });
  
  // ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—é˜²æ­¢ã®è¿½åŠ å¯¾ç­–
  document.addEventListener('touchstart', (e) => {
    if (e.touches.length > 1) {
      e.preventDefault();
    }
  }, { passive: false });

  // å…¥åŠ›
  const Input = {
    ax: 0, ay: 0,
    a: false, b: false, x: false,
    aDown: false, bDown: false, xDown: false,
    updateEdges() {
      this.aDown = this.a && !this._pa; this._pa = this.a;
      this.bDown = this.b && !this._pb; this._pb = this.b;
      this.xDown = this.x && !this._px; this._px = this.x;
    },
  };

  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆå¾Œã§å®šç¾©ã•ã‚Œã‚‹é–¢æ•°ã‚’å‚ç…§ã™ã‚‹ãŸã‚ã€å¾Œã§è¨­å®šï¼‰
  let handleKeyDown, handleKeyUp;
  
  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰
  handleKeyDown = (e) => {
    // Escapeã‚­ãƒ¼ã¯å¸¸ã«æœ‰åŠ¹
    if (e.key === 'Escape') {
      if (typeof toggleWeaponSelect === 'function') {
        toggleWeaponSelect();
      }
      e.preventDefault();
      return;
    }
    
    // ãƒãƒ¼ã‚ºä¸­ã‚„ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã¯ä»–ã®ã‚­ãƒ¼ã‚’ç„¡åŠ¹åŒ–
    if (state.paused || state.ending) {
      return;
    }
    
    switch(e.key){
      case 'ArrowLeft': Input.ax = -1; break;
      case 'ArrowRight': Input.ax = 1; break;
      case 'ArrowUp': Input.ay = -1; break;
      case 'ArrowDown': Input.ay = 1; break;
      case ' ': case 'j': case 'J': Input.a = true; break;
      case 'k': case 'z': case 'K': case 'Z': Input.b = true; break;
      case 'x': case 'X': Input.x = true; break;
      default: return; // ä»–ã®ã‚­ãƒ¼ã¯å‡¦ç†ã—ãªã„
    }
    e.preventDefault();
  };
  
  handleKeyUp = (e) => {
    // ãƒãƒ¼ã‚ºä¸­ã‚„ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã¯ç„¡åŠ¹åŒ–
    if (state.paused || state.ending) {
      return;
    }
    
    switch(e.key){
      case 'ArrowLeft': if (Input.ax<0) Input.ax = 0; break;
      case 'ArrowRight': if (Input.ax>0) Input.ax = 0; break;
      case 'ArrowUp': if (Input.ay<0) Input.ay = 0; break;
      case 'ArrowDown': if (Input.ay>0) Input.ay = 0; break;
      case ' ': case 'j': case 'J': Input.a = false; break;
      case 'k': case 'z': case 'K': case 'Z': Input.b = false; break;
      case 'x': case 'X': Input.x = false; break;
      default: return;
    }
  };
  
  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('keyup', handleKeyUp);

  // ã‚¿ãƒƒãƒ
  const stick = document.getElementById('stick');
  const stickKnob = document.getElementById('stickKnob');
  let stickId = null, stickCenter = {x:0,y:0};
  const R = 56;

  const setKnob = (dx,dy) => stickKnob.style.transform = `translate(${dx}px, ${dy}px)`;

  // iOSå‘ã‘ã®ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆæœ€é©åŒ–
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
  
  const handleStickStart = (e) => {
    e.preventDefault();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    stickId = e.pointerId || (e.touches ? e.touches[0].identifier : 0);
    stickCenter.x = clientX;
    stickCenter.y = clientY;
  };

  const handleStickMove = (e) => {
    if (stickId === null) return;
    const isTouch = e.touches && e.touches.length > 0;
    const currentId = isTouch ? e.touches[0].identifier : e.pointerId;
    
    if (currentId === stickId || (stickId !== null && !isTouch)) {
      const clientX = isTouch ? e.touches[0].clientX : e.clientX;
      const clientY = isTouch ? e.touches[0].clientY : e.clientY;
      const dx = clientX - stickCenter.x;
      const dy = clientY - stickCenter.y;
      const len = Math.hypot(dx,dy) || 1;
      const cl = Math.min(len, R);
      const nx = dx/len, ny = dy/len;
      const kx = nx*cl, ky = ny*cl;
      setKnob(kx, ky);
      Input.ax = (cl/R)*nx;
      Input.ay = (cl/R)*ny;
      e.preventDefault();
    }
  };

  const handleStickEnd = (e) => {
    const isTouch = e.changedTouches && e.changedTouches.length > 0;
    const currentId = isTouch ? e.changedTouches[0].identifier : e.pointerId;
    
    if (currentId === stickId || (stickId !== null && !isTouch)) {
      stickId = null;
      setKnob(0, 0);
      Input.ax = 0;
      Input.ay = 0;
      e.preventDefault();
    }
  };

  // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®ç™»éŒ²ï¼ˆiOSå‘ã‘ã«æœ€é©åŒ–ï¼‰
  if (isIOS) {
    stick.addEventListener('touchstart', handleStickStart, { passive: false });
    stick.addEventListener('touchmove', handleStickMove, { passive: false });
    stick.addEventListener('touchend', handleStickEnd, { passive: false });
    stick.addEventListener('touchcancel', handleStickEnd, { passive: false });
  }
  
  stick.addEventListener('pointerdown', handleStickStart);
  window.addEventListener('pointermove', handleStickMove);
  window.addEventListener('pointerup', handleStickEnd);
  window.addEventListener('pointercancel', handleStickEnd);

  // ãƒœã‚¿ãƒ³ã®æ‰“æ„Ÿï¼ˆè§¦è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼‰
  const vibrate = (pattern = [10]) => {
    if ('vibrate' in navigator) {
      try {
        navigator.vibrate(pattern);
      } catch (e) {
        // ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
      }
    }
  };

  // ãƒœã‚¿ãƒ³
  const btnA = document.getElementById('btnA');
  const btnB = document.getElementById('btnB');
  const btnX = document.getElementById('btnX');

  const pressBtn = (key, btn) => (e) => {
    e.preventDefault();
    Input[key] = true;
    Sound.playSound('button');
    
    // æ‰“æ„Ÿï¼šè§¦è¦šãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆå¼·åŒ–ç‰ˆï¼‰
    const isBottomRow = btn.closest('.btn-bottom-row');
    if (isBottomRow) {
      // å³ä¸‹ã®ãƒœã‚¿ãƒ³ã¯ã‚ˆã‚Šå¼·ã„æŒ¯å‹•
      vibrate([10, 5, 15, 5, 10]);
    } else {
      vibrate([5, 5, 10]);
    }
    
    // æ‰“æ„Ÿï¼šè¦–è¦šçš„ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ï¼ˆé«˜é€ŸåŒ–ï¼‰
    btn.classList.add('pressed');
    setTimeout(() => {
      btn.classList.remove('pressed');
    }, 80); // 150ms â†’ 80ms ã«çŸ­ç¸®
  };
  const releaseBtn = (key) => (e) => {
    e.preventDefault();
    Input[key] = false;
  };

  // ãƒœã‚¿ãƒ³ã‚¤ãƒ™ãƒ³ãƒˆç™»éŒ²ï¼ˆé«˜é€ŸåŒ–ã®ãŸã‚ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆã‚‚è¿½åŠ ï¼‰
  const addButtonEvents = (btn, key) => {
    const press = pressBtn(key, btn);
    const release = releaseBtn(key);
    
    // ãƒã‚¤ãƒ³ã‚¿ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
    btn.addEventListener('pointerdown', press, { passive: false });
    btn.addEventListener('pointerup', release, { passive: false });
    btn.addEventListener('pointercancel', release, { passive: false });
    
    // ã‚¿ãƒƒãƒã‚¤ãƒ™ãƒ³ãƒˆï¼ˆiOSå‘ã‘é«˜é€ŸåŒ–ï¼‰
    if (isIOS) {
      btn.addEventListener('touchstart', press, { passive: false });
      btn.addEventListener('touchend', release, { passive: false });
      btn.addEventListener('touchcancel', release, { passive: false });
    }
  };

  addButtonEvents(btnA, 'a');
  addButtonEvents(btnB, 'b');
  addButtonEvents(btnX, 'x');

  // æ­¦å™¨ã®ç¨®é¡
  const WEAPONS = {
    BOMB: { id: 'bomb', name: 'çˆ†å¼¾', icon: 'ğŸ’£', color: '#333' },
    SHURIKEN: { id: 'shuriken', name: 'æ‰‹è£å‰£', icon: 'â­', color: '#ffd700' },
    SPEAR: { id: 'spear', name: 'é•·æ§', icon: 'ğŸ”±', color: '#4a90e2' },
    BAZOOKA: { id: 'bazooka', name: 'ãƒã‚ºãƒ¼ã‚«', icon: 'ğŸš€', color: '#ff4500' }
  };

  // æºå¸¯ãƒ‡ãƒã‚¤ã‚¹æ¤œå‡º
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || 
                   ('ontouchstart' in window) || 
                   (navigator.maxTouchPoints > 0);

  // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
  const state = {
    coins: 0,
    hp: 5, maxHp: 5,
    level: 1, exp: 0, expToNext: 10,
    tutorialStep: 0,
    paused: false,
    hintTimer: 0,
    weapons: [WEAPONS.BOMB.id], // æ‰€æŒæ­¦å™¨ãƒªã‚¹ãƒˆï¼ˆåˆæœŸã¯çˆ†å¼¾ã®ã¿ï¼‰
    currentWeapon: WEAPONS.BOMB.id, // ç¾åœ¨è£…å‚™ä¸­ã®æ­¦å™¨
    bossItems: [], // ãƒœã‚¹ã‹ã‚‰å…¥æ‰‹ã—ãŸã‚¢ã‚¤ãƒ†ãƒ 
    defeatedBosses: [], // å€’ã—ãŸãƒœã‚¹ã®ã‚¿ã‚¤ãƒ—ï¼ˆ'suzaku', 'genbu', 'seiryu', 'kirin'ï¼‰
    ending: false, // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒ•ãƒ©ã‚°
    chiefEventShown: false, // æ‘é•·ã‚¤ãƒ™ãƒ³ãƒˆè¡¨ç¤ºæ¸ˆã¿ãƒ•ãƒ©ã‚°
    canPlay: !isMobile, // æºå¸¯ã®å ´åˆã¯æ¨ªç”»é¢ã«ãªã‚‹ã¾ã§false
  };

  // HUDè¦ç´ 
  const heartEl = document.getElementById('hearts');
  const coinsEl = document.getElementById('coins');
  const levelEl = document.getElementById('level');
  const hintEl = document.getElementById('hint');
  const levelUpEl = document.getElementById('levelUp');
  const speechBubbleEl = document.getElementById('speechBubble');
  const minimapCanvas = document.getElementById('minimap');
  const minimapCtx = minimapCanvas.getContext('2d');
  
  // æ¨ªç”»é¢ç”¨ã®è¦ç´ 
  const heartElLandscape = document.getElementById('hearts-landscape');
  const coinsElLandscape = document.getElementById('coins-landscape');
  const levelElLandscape = document.getElementById('level-landscape');
  const minimapCanvasLandscape = document.getElementById('minimap-landscape');
  const minimapCtxLandscape = minimapCanvasLandscape ? minimapCanvasLandscape.getContext('2d') : null;
  const btnPauseLandscape = document.getElementById('btnPause-landscape');

  function renderHUD(){
    // ç¸¦ç”»é¢ç”¨ - æœ€å¤§10å€‹ã¾ã§è¡¨ç¤º
    heartEl.innerHTML = '';
    const maxHearts = Math.min(state.maxHp, 10); // æœ€å¤§10å€‹ã¾ã§
    for (let i=0;i<maxHearts;i++){
      const d = document.createElement('div');
      d.className = 'heart' + (i >= state.hp? ' empty':'');
      heartEl.appendChild(d);
    }
    coinsEl.textContent = state.coins;
    levelEl.textContent = state.level;
    
    // æ¨ªç”»é¢ç”¨ - æœ€å¤§10å€‹ã¾ã§è¡¨ç¤º
    if (heartElLandscape) {
      heartElLandscape.innerHTML = '';
      const maxHeartsLandscape = Math.min(state.maxHp, 10); // æœ€å¤§10å€‹ã¾ã§
      for (let i=0;i<maxHeartsLandscape;i++){
        const d = document.createElement('div');
        d.className = 'heart' + (i >= state.hp? ' empty':'');
        heartElLandscape.appendChild(d);
      }
    }
    if (coinsElLandscape) coinsElLandscape.textContent = state.coins;
    if (levelElLandscape) levelElLandscape.textContent = state.level;
  }

  function showHint(txt, secs=1.5){
    state.hintTimer = secs;
    hintEl.textContent = txt;
    hintEl.classList.add('show');
  }

  let speechBubbleTimer = 0;
  function showSpeechBubble(npc, text) {
    speechBubbleEl.textContent = text;
    speechBubbleEl.classList.add('show');
    
    // NPCã®ä½ç½®ã«å¹ãå‡ºã—ã‚’é…ç½®
    const canvasRect = canvas.getBoundingClientRect();
    const stageRect = document.querySelector('.stage').getBoundingClientRect();
    const scaleX = stageRect.width / W;
    const scaleY = stageRect.height / H;
    
    const bubbleX = (npc.x * scaleX) + stageRect.left;
    // å¹ãå‡ºã—ã®ä¸‹ã®è¾ºãŒNPCã®ã‚¢ã‚¤ã‚³ãƒ³ã®ä¸­å¤®ï¼ˆyä½ç½®ï¼‰ã«æ¥ã‚‹ã‚ˆã†ã«èª¿æ•´
    // ã¾ãšä¸€æ™‚çš„ã«é…ç½®ã—ã¦é«˜ã•ã‚’å–å¾—
    speechBubbleEl.style.left = `${bubbleX}px`;
    speechBubbleEl.style.top = '0px';
    speechBubbleEl.style.transform = 'translateX(-50%)';
    
    // å¹ãå‡ºã—ã®å®Ÿéš›ã®é«˜ã•ã‚’å–å¾—
    const bubbleHeight = speechBubbleEl.offsetHeight;
    // NPCã®yä½ç½®ï¼ˆã‚¢ã‚¤ã‚³ãƒ³ã®ä¸­å¤®ï¼‰ã«å¹ãå‡ºã—ã®ä¸‹ã®è¾ºãŒæ¥ã‚‹ã‚ˆã†ã«
    // ã•ã‚‰ã«ä¸Šã«é…ç½®ã™ã‚‹ãŸã‚ã€è¿½åŠ ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’å¼•ã
    const additionalOffset = 35; // è¿½åŠ ã§ä¸Šã«35px
    const bubbleY = (npc.y * scaleY) + stageRect.top - bubbleHeight - additionalOffset;
    
    speechBubbleEl.style.top = `${bubbleY}px`;
    
    // 3ç§’å¾Œã«è‡ªå‹•çš„ã«æ¶ˆã™
    speechBubbleTimer = 3.0;
  }

  function hideSpeechBubble() {
    speechBubbleEl.classList.remove('show');
    speechBubbleTimer = 0;
  }

  // ãƒŸãƒ‹ãƒãƒƒãƒ—æç”»
  function drawMinimap() {
    // æç”»å‰ã«ç¾åœ¨ä½ç½®ã®ãƒãƒƒãƒ—ã‚’è¨ªå•æ¸ˆã¿ã¨ã—ã¦è¨˜éŒ²ï¼ˆå¿µã®ãŸã‚ï¼‰
    markMapVisited(currentMapX, currentMapY);
    
    const drawToCanvas = (ctx, canvas) => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    
      // èƒŒæ™¯
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // ãƒãƒƒãƒ—ã®ã‚µã‚¤ã‚ºï¼ˆ9x9ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºï¼‰
      const cellSize = 8; // 9x9ã‚°ãƒªãƒƒãƒ‰ã«åã‚ã‚‹ãŸã‚å°‘ã—å°ã•ã
      const drawSize = cellSize - 1; // å®Ÿéš›ã®æç”»ã‚µã‚¤ã‚ºï¼ˆ7pxï¼‰
      
      // ä¸­å¤®ãƒãƒƒãƒ—(0,0)ã®ãƒã‚¹ã®ä¸­å¿ƒãŒãƒŸãƒ‹ãƒãƒƒãƒ—ã®ä¸­å¿ƒã«æ¥ã‚‹ã‚ˆã†ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’è¨ˆç®—
      // ä¸­å¤®ãƒãƒƒãƒ—ã¯(4,4)ã®ä½ç½®ï¼ˆ9x9ã‚°ãƒªãƒƒãƒ‰ã®ä¸­å¤®ï¼‰
      // ãƒŸãƒ‹ãƒãƒƒãƒ—ã®ä¸­å¿ƒ: (canvas.width/2, canvas.height/2)
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const offsetX = centerX - 4 * cellSize - drawSize / 2;
      const offsetY = centerY - 4 * cellSize - drawSize / 2;
      
      // è¨ªå•ã—ãŸãƒãƒƒãƒ—ã‚’æç”»
      const mapTypes = {
        '0,0': { name: 'æ‘', color: '#8b7355' },
        '0,-1': { name: 'æ£®', color: '#228b22' },
        '0,1': { name: 'æµ·å²¸', color: '#1e3a8a' },
        '-1,0': { name: 'æ´çªŸ', color: '#555' },
        '1,0': { name: 'è‰åŸ', color: '#2d5016' },
        '-1,-1': { name: 'å»ƒå¢Ÿ', color: '#666' },
        '1,-1': { name: 'èŠ±ç•‘', color: '#ff69b4' },
        '-1,1': { name: 'æµ·å²¸æ´çªŸ', color: '#4a5568' },
        '1,1': { name: 'ãƒ“ãƒ¼ãƒ', color: '#d4a574' }
      };
      
      // æ–°ã—ã„ãƒãƒƒãƒ—ã‚¿ã‚¤ãƒ—ã®è‰²ã‚’å‹•çš„ã«æ±ºå®š
      const getMapColor = (x, y) => {
        const key = getMapKey(x, y);
        if (mapTypes[key]) return mapTypes[key].color;
        
        // æ–°ã—ã„ãƒãƒƒãƒ—ã‚¿ã‚¤ãƒ—ã®è‰²
        if (x >= 2 || (x > 0 && y <= -2)) return '#90EE90'; // ã‚µãƒœãƒ†ãƒ³ï¼ˆæ˜ã‚‹ã„ç·‘ï¼‰
        if (x <= -2 || (x < 0 && y <= -2)) return '#E0E0E0'; // é›ªï¼ˆç™½ï¼‰
        if (x <= -2 || (x < 0 && y >= 2)) return '#D2B48C'; // ç ‚æ¼ ï¼ˆãƒ™ãƒ¼ã‚¸ãƒ¥ï¼‰
        if (x >= 2 || (x > 0 && y >= 2)) return '#4169E1'; // æµ·æ´‹ï¼ˆé’ï¼‰
        return '#666'; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
      };
      
      // å„ãƒãƒƒãƒ—ä½ç½®ã‚’æç”»ï¼ˆ9x9ã‚°ãƒªãƒƒãƒ‰ã€ä¸­å¤®ãŒ(4,4)ï¼‰
      // x: -4ã‹ã‚‰4ã¾ã§ã€y: -4ã‹ã‚‰4ã¾ã§
      const mapPositions = [];
      for(let y = -4; y <= 4; y++) {
        for(let x = -4; x <= 4; x++) {
          mapPositions.push({
            key: `${x},${y}`,
            x: x + 4, // -4ã‚’0ã«ã€0ã‚’4ã«ã€4ã‚’8ã«å¤‰æ›
            y: y + 4  // -4ã‚’0ã«ã€0ã‚’4ã«ã€4ã‚’8ã«å¤‰æ›
          });
        }
      }
      
      // æ­¦å™¨ãŒå…¥ã£ã¦ã„ã‚‹å®ç®±ãŒã‚ã‚‹ãƒãƒƒãƒ—ã‚’åˆ¤å®š
      const hasWeaponChest = (mx, my) => {
        // æ‰‹è£å‰£ï¼šå—æ±æ–¹å‘ï¼ˆ2, 2ï¼‰
        if (mx === 2 && my === 2) return true;
        // é•·æ§ï¼šåŒ—è¥¿æ–¹å‘ï¼ˆ-2, -2ï¼‰
        if (mx === -2 && my === -2) return true;
        // ãƒã‚ºãƒ¼ã‚«ï¼šåŒ—æ±æ–¹å‘ï¼ˆ2, -2ï¼‰
        if (mx === 2 && my === -2) return true;
        return false;
      };
      
      for (const pos of mapPositions) {
        const [mx, my] = pos.key.split(',').map(Number);
        const isCurrent = (currentMapX === mx && currentMapY === my);
        const isVisited = isMapVisited(mx, my);
        
        // 4ã¤ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒæƒã£ãŸã‚‰æ‘ï¼ˆ0,0ï¼‰ã‚’å¼·åˆ¶çš„ã«è¨ªå•æ¸ˆã¿ã¨ã—ã¦è¡¨ç¤º
        const isVillage = (mx === 0 && my === 0);
        const shouldShow = isVisited || isCurrent || (isVillage && state.bossItems.length === 4);
        
        // ç¾åœ¨ä½ç½®ã®ãƒãƒƒãƒ—ã¾ãŸã¯è¨ªå•æ¸ˆã¿ãƒãƒƒãƒ—ã‚’æç”»
        if (shouldShow) {
          const mapColor = mapTypes[pos.key] ? mapTypes[pos.key].color : getMapColor(mx, my);
          const px = offsetX + pos.x * cellSize;
          const py = offsetY + pos.y * cellSize;
          
          // 4ã¤ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒæƒã£ãŸã‚‰æ‘ã‚’ç‚¹ç¯ï¼ˆå…‰ã‚‹åŠ¹æœï¼‰
          const isVillageLighted = isVillage && state.bossItems.length === 4;
          let fillColor = isCurrent ? '#ffd700' : mapColor;
          
          if (isVillageLighted) {
            // ç‚¹ç¯åŠ¹æœï¼šæ˜ã‚‹ã„é»„è‰²ã§ç‚¹æ»…
            const pulse = Math.sin(performance.now() * 0.005) * 0.3 + 0.7;
            fillColor = `rgba(255, 215, 0, ${pulse})`;
          }
          
          // ãƒãƒƒãƒ—ã‚»ãƒ«ã‚’æç”»
          ctx.fillStyle = fillColor;
          ctx.fillRect(px, py, cellSize - 2, cellSize - 2);
          
          // ç¾åœ¨ä½ç½®ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆ
          if (isCurrent) {
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(px - 0.5, py - 0.5, cellSize - 1, cellSize - 1);
            
            // ç¾åœ¨ä½ç½®ã®ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(px + cellSize/2, py + cellSize/2, 2, 0, Math.PI * 2);
            ctx.fill();
          } else if (isVillageLighted) {
            // æ‘ãŒç‚¹ç¯ã—ã¦ã„ã‚‹å ´åˆã®ç‰¹åˆ¥ãªãƒã‚¤ãƒ©ã‚¤ãƒˆ
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.strokeRect(px - 1, py - 1, cellSize, cellSize);
            
            // ç‚¹ç¯ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ï¼ˆå…‰ã‚‹å††ï¼‰
            const glow = Math.sin(performance.now() * 0.005) * 0.5 + 0.5;
            ctx.fillStyle = `rgba(255, 215, 0, ${glow})`;
            ctx.beginPath();
            ctx.arc(px + cellSize/2, py + cellSize/2, 3, 0, Math.PI * 2);
            ctx.fill();
          } else {
            // è¨ªå•æ¸ˆã¿ãƒãƒƒãƒ—ã®æ 
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(px, py, cellSize - 2, cellSize - 2);
          }
          
          // æ­¦å™¨ãŒå…¥ã£ã¦ã„ã‚‹å®ç®±ãŒã‚ã‚‹ãƒãƒƒãƒ—ã«å°ã•ãªèµ¤ä¸¸ã‚’è¡¨ç¤º
          if (hasWeaponChest(mx, my)) {
            ctx.fillStyle = '#ff0000';
            ctx.beginPath();
            ctx.arc(px + cellSize - 3, py + 3, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }
      
      // ã‚°ãƒªãƒƒãƒ‰ç·šï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ã€å¿…è¦ã«å¿œã˜ã¦ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆï¼‰
      // ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
      // ctx.lineWidth = 1;
      // for (let i = 0; i <= 3; i++) {
      //   ctx.beginPath();
      //   ctx.moveTo(offsetX + i * cellSize, offsetY);
      //   ctx.lineTo(offsetX + i * cellSize, offsetY + 3 * cellSize);
      //   ctx.stroke();
      // }
      // for (let i = 0; i <= 3; i++) {
      //   ctx.beginPath();
      //   ctx.moveTo(offsetX, offsetY + i * cellSize);
      //   ctx.lineTo(offsetX + 3 * cellSize, offsetY + i * cellSize);
      //   ctx.stroke();
      // }
    };
    
    // ç¸¦ç”»é¢ç”¨ã®ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’æç”»
    drawToCanvas(minimapCtx, minimapCanvas);
    
    // æ¨ªç”»é¢ç”¨ã®ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’æç”»ï¼ˆåŒã˜å†…å®¹ï¼‰
    if (minimapCtxLandscape && minimapCanvasLandscape) {
      drawToCanvas(minimapCtxLandscape, minimapCanvasLandscape);
    }
  }

  function gainExp(amount) {
    state.exp += amount;
    if (state.exp >= state.expToNext) {
      state.level++;
      state.exp = 0;
      state.expToNext = Math.floor(state.expToNext * 1.2);
      state.maxHp++;
      state.hp = state.maxHp;
      Sound.playSound('level');
      showLevelUp();
      showHint(`ãƒ¬ãƒ™ãƒ« ${state.level}! HP+1`);
    }
  }

  function showLevelUp() {
    levelUpEl.style.display = 'block';
    levelUpEl.style.animation = 'none';
    setTimeout(() => {
      levelUpEl.style.animation = 'levelUpAnim 2s ease-out';
    }, 10);
    setTimeout(() => {
      levelUpEl.style.display = 'none';
    }, 2000);
  }

  // ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£
  class Entity {
    constructor(x,y) {
      this.x=x; this.y=y; this.w=12; this.h=12;
      this.vx=0; this.vy=0; this.dir=1; this.hp=1; this.dead=false;
    }
  }

  class Player extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=60; this.hp=state.hp; this.maxHp=state.maxHp;
      this.inv=0; this.attackCd=0; this.swordT=0;
      this.sdx=1; this.sdy=0;
      this.weaponCd=0; // æ­¦å™¨ä½¿ç”¨æ™‚ã®ç¡¬ç›´æ™‚é–“
    }
  }

  class Slime extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=25; this.hp=2; this.change=0; this.bounceT=0;
      this.knockbackT=0; // ãƒãƒƒã‚¯ãƒãƒƒã‚¯æ™‚é–“
    }
    update(dt) {
      // ãƒãƒƒã‚¯ãƒãƒƒã‚¯å‡¦ç†
      if (this.knockbackT > 0) {
        this.knockbackT -= dt;
        if (this.knockbackT <= 0) {
          this.vx = 0;
          this.vy = 0;
        }
        return; // ãƒãƒƒã‚¯ãƒãƒƒã‚¯ä¸­ã¯é€šå¸¸ã®ç§»å‹•ã‚’ã‚¹ã‚­ãƒƒãƒ—
      }
      this.bounceT += dt * 4;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 2 + 0.8;
        const ang = Math.random() * Math.PI * 2;
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed;
      }
    }
  }

  class Archer extends Entity {
    constructor(x,y) {
      super(x,y);
      this.hp=3; this.cd=0; this.range=180; this.alertT=0;
    }
    update(dt) {
      if (this.alertT > 0) this.alertT -= dt;
    }
  }

  class CactusMonster extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=20; this.hp=3; this.change=0; this.spikeT=0;
    }
    update(dt) {
      this.spikeT += dt * 3;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 2.5 + 1.0;
        const ang = Math.random() * Math.PI * 2;
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed;
      }
    }
  }

  class SnowWolf extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=40; this.hp=2; this.change=0; this.howlT=0;
    }
    update(dt) {
      this.howlT += dt * 2;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 1.5 + 0.5;
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã£ã¦ç§»å‹•
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 0 && dist < 200) {
          this.vx = (dx / dist) * this.speed;
          this.vy = (dy / dist) * this.speed;
        } else {
          const ang = Math.random() * Math.PI * 2;
          this.vx = Math.cos(ang) * this.speed;
          this.vy = Math.sin(ang) * this.speed;
        }
      }
    }
  }

  class DesertScorpion extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=30; this.hp=4; this.change=0; this.stingT=0;
    }
    update(dt) {
      this.stingT += dt * 5;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 2 + 0.8;
        const ang = Math.random() * Math.PI * 2;
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed;
      }
    }
  }

  class OceanKraken extends Entity {
    constructor(x,y) {
      super(x,y);
      this.hp=5; this.cd=0; this.range=200; this.tentacleT=0; this.alertT=0;
    }
    update(dt) {
      this.tentacleT += dt * 2;
      if (this.alertT > 0) this.alertT -= dt;
    }
  }

  class FireSpirit extends Entity {
    constructor(x,y) {
      super(x,y);
      this.speed=35; this.hp=2; this.change=0; this.flameT=0;
    }
    update(dt) {
      this.flameT += dt * 6;
      if ((this.change-=dt)<=0) {
        this.change = Math.random() * 1.8 + 0.6;
        const ang = Math.random() * Math.PI * 2;
        this.vx = Math.cos(ang) * this.speed;
        this.vy = Math.sin(ang) * this.speed;
      }
    }
  }

  // ãƒœã‚¹ã‚¯ãƒ©ã‚¹
  class Boss extends Entity {
    constructor(x, y, type) {
      super(x, y);
      this.type = type; // 'suzaku', 'genbu', 'seiryu', 'kirin'
      this.w = 48; this.h = 48; // 4å€ã®å¤§ãã•
      this.maxHp = 50;
      this.hp = 50;
      this.dead = false;
      this.attackCd = 0;
      this.attackPattern = 0;
      this.animT = 0;
      this.bullets = [];
      this.phase = 1; // ãƒ•ã‚§ãƒ¼ã‚ºï¼ˆ1: é€šå¸¸ã€2: ä½“åŠ›åŠåˆ†ä»¥ä¸‹ï¼‰
      
      this.moveT = 0; // ç§»å‹•ã‚¿ã‚¤ãƒãƒ¼
      this.moveDir = 0; // ç§»å‹•æ–¹å‘ï¼ˆ0-3: ä¸Šä¸‹å·¦å³ï¼‰
      this.moveSpeed = 20; // ã‚†ã£ãã‚Šå‹•ãé€Ÿåº¦
      this.moveCd = 0; // ç§»å‹•æ–¹å‘å¤‰æ›´ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
      
      // ãƒœã‚¹ã‚¿ã‚¤ãƒ—ã”ã¨ã®è¨­å®š
      switch(type) {
        case 'suzaku': // æœ±é›€ï¼ˆå—ï¼‰- å††å½¢ã«å‹•ãå›ã‚‹
          this.color = '#ff0000'; // èµ¤
          this.attackSpeed = 1.5;
          this.movePattern = 'circle';
          break;
        case 'genbu': // ç„æ­¦ï¼ˆåŒ—ï¼‰- å‰å¾Œã«å‹•ã
          this.color = '#ff0000'; // èµ¤ã«å¤‰æ›´
          this.attackSpeed = 2.0;
          this.movePattern = 'backforth';
          break;
        case 'seiryu': // é’é¾ï¼ˆæ±ï¼‰- å·¦å³ã«å‹•ã
          this.color = '#ff0000'; // èµ¤ã«å¤‰æ›´
          this.attackSpeed = 1.0;
          this.movePattern = 'sideways';
          break;
        case 'kirin': // éº’éºŸï¼ˆè¥¿ï¼‰- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½ã„ã‹ã‘ã‚‹
          this.color = '#ff0000'; // èµ¤ã«å¤‰æ›´
          this.attackSpeed = 1.8;
          this.movePattern = 'chase';
          break;
      }
    }
    
    update(dt) {
      this.animT += dt;
      this.attackCd -= dt;
      this.moveT += dt;
      this.moveCd -= dt;
      
      // HPãŒåŠåˆ†ä»¥ä¸‹ã«ãªã£ãŸã‚‰ãƒ•ã‚§ãƒ¼ã‚º2ã¸
      if (this.phase === 1 && this.hp <= this.maxHp / 2) {
        this.phase = 2;
        // ãƒ•ã‚§ãƒ¼ã‚º2ã§ã¯ç§»å‹•é€Ÿåº¦ã¨æ”»æ’ƒé€Ÿåº¦ã‚’ä¸Šæ˜‡
        this.moveSpeed *= 1.5;
        this.attackSpeed *= 0.7; // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ãŒçŸ­ããªã‚‹ = æ”»æ’ƒãŒé€Ÿããªã‚‹
        Sound.playSound('level'); // ãƒ•ã‚§ãƒ¼ã‚ºå¤‰åŒ–ã®éŸ³
      }
      
      // ãƒœã‚¹ã®ç§»å‹•ãƒ‘ã‚¿ãƒ¼ãƒ³
      if (!this.dead) {
        this.move(dt);
      }
      
      if (this.attackCd <= 0) {
        this.attack();
        this.attackCd = this.attackSpeed;
        this.attackPattern = (this.attackPattern + 1) % 3;
      }
    }
    
    move(dt) {
      const oldX = this.x;
      const oldY = this.y;
      
      if (this.phase === 1) {
        // ãƒ•ã‚§ãƒ¼ã‚º1: é€šå¸¸ã®å‹•ã
        switch(this.movePattern) {
          case 'circle': // æœ±é›€ï¼šå††å½¢ã«å‹•ãå›ã‚‹
            const radius = 40;
            const centerX = 160;
            const centerY = 90;
            this.x = centerX + Math.cos(this.moveT * 0.5) * radius;
            this.y = centerY + Math.sin(this.moveT * 0.5) * radius;
            break;
            
          case 'backforth': // ç„æ­¦ï¼šå‰å¾Œã«å‹•ã
            if (this.moveCd <= 0) {
              this.moveDir = (this.moveDir === 0) ? 1 : 0; // 0: ä¸Šã€1: ä¸‹
              this.moveCd = 2.0;
            }
            if (this.moveDir === 0) {
              this.y -= this.moveSpeed * dt;
              if (this.y < 50) {
                this.y = 50;
                this.moveDir = 1;
              }
            } else {
              this.y += this.moveSpeed * dt;
              if (this.y > 130) {
                this.y = 130;
                this.moveDir = 0;
              }
            }
            break;
            
          case 'sideways': // é’é¾ï¼šå·¦å³ã«å‹•ã
            if (this.moveCd <= 0) {
              this.moveDir = (this.moveDir === 0) ? 1 : 0; // 0: å·¦ã€1: å³
              this.moveCd = 2.0;
            }
            if (this.moveDir === 0) {
              this.x -= this.moveSpeed * dt;
              if (this.x < 80) {
                this.x = 80;
                this.moveDir = 1;
              }
            } else {
              this.x += this.moveSpeed * dt;
              if (this.x > 240) {
                this.x = 240;
                this.moveDir = 0;
              }
            }
            break;
            
          case 'chase': // éº’éºŸï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½ã„ã‹ã‘ã‚‹ï¼ˆã‚†ã£ãã‚Šï¼‰
            const dx = player.x - this.x;
            const dy = player.y - this.y;
            const dist = Math.hypot(dx, dy);
            if (dist > 0) {
              const speed = this.moveSpeed * dt;
              this.x += (dx / dist) * speed;
              this.y += (dy / dist) * speed;
              
              // ãƒãƒƒãƒ—ã®å¢ƒç•Œã§æ­¢ã¾ã‚‹
              this.x = Math.max(60, Math.min(260, this.x));
              this.y = Math.max(50, Math.min(130, this.y));
            }
            break;
        }
      } else {
        // ãƒ•ã‚§ãƒ¼ã‚º2: ã‚ˆã‚Šæ¿€ã—ã„å‹•ã
        switch(this.movePattern) {
          case 'circle': // æœ±é›€ï¼šã‚ˆã‚Šé€Ÿã„å††å½¢ç§»å‹•
            const radius2 = 50;
            const centerX2 = 160;
            const centerY2 = 90;
            this.x = centerX2 + Math.cos(this.moveT * 1.0) * radius2;
            this.y = centerY2 + Math.sin(this.moveT * 1.0) * radius2;
            break;
            
          case 'backforth': // ç„æ­¦ï¼šã‚¸ã‚°ã‚¶ã‚°ç§»å‹•
            if (this.moveCd <= 0) {
              this.moveDir = (this.moveDir + 1) % 4; // 0: ä¸Šã€1: å³ä¸Šã€2: ä¸‹ã€3: å·¦ä¸‹
              this.moveCd = 1.0;
            }
            const zigzagSpeed = this.moveSpeed * dt;
            if (this.moveDir === 0) {
              this.y -= zigzagSpeed;
              if (this.y < 50) {
                this.y = 50;
                this.moveDir = 2;
              }
            } else if (this.moveDir === 1) {
              this.y -= zigzagSpeed * 0.7;
              this.x += zigzagSpeed * 0.7;
              if (this.x > 240 || this.y < 50) {
                this.moveDir = 3;
              }
            } else if (this.moveDir === 2) {
              this.y += zigzagSpeed;
              if (this.y > 130) {
                this.y = 130;
                this.moveDir = 0;
              }
            } else {
              this.y += zigzagSpeed * 0.7;
              this.x -= zigzagSpeed * 0.7;
              if (this.x < 80 || this.y > 130) {
                this.moveDir = 1;
              }
            }
            break;
            
          case 'sideways': // é’é¾ï¼šå††å½¢ç§»å‹•ã«å¤‰æ›´
            const radius3 = 45;
            const centerX3 = 160;
            const centerY3 = 90;
            this.x = centerX3 + Math.cos(this.moveT * 0.8) * radius3;
            this.y = centerY3 + Math.sin(this.moveT * 0.8) * radius3;
            break;
            
          case 'chase': // éº’éºŸï¼šã‚ˆã‚Šç©æ¥µçš„ã«è¿½å°¾
            const dx2 = player.x - this.x;
            const dy2 = player.y - this.y;
            const dist2 = Math.hypot(dx2, dy2);
            if (dist2 > 0) {
              const speed2 = this.moveSpeed * dt;
              this.x += (dx2 / dist2) * speed2;
              this.y += (dy2 / dist2) * speed2;
              
              // ãƒãƒƒãƒ—ã®å¢ƒç•Œã§æ­¢ã¾ã‚‹
              this.x = Math.max(60, Math.min(260, this.x));
              this.y = Math.max(50, Math.min(130, this.y));
            }
            break;
        }
      }
      
      // ã‚¿ã‚¤ãƒ«ã¨ã®è¡çªåˆ¤å®šï¼ˆç§»å‹•ã‚’å…ƒã«æˆ»ã™ï¼‰
      if (collidesTile(this.x, this.y, this.w, this.h)) {
        this.x = oldX;
        this.y = oldY;
      }
    }
    
    attack() {
      const dx = player.x - this.x;
      const dy = player.y - this.y;
      const dist = Math.hypot(dx, dy);
      
      if (this.phase === 1) {
        // ãƒ•ã‚§ãƒ¼ã‚º1: é€šå¸¸ã®æ”»æ’ƒ
        switch(this.type) {
          case 'suzaku': // æœ±é›€ï¼šç«ã®ç‰ã‚’3ç™º
            for (let i = 0; i < 3; i++) {
              const angle = Math.atan2(dy, dx) + (i - 1) * 0.3;
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * 80,
                vy: Math.sin(angle) * 80,
                life: 3.0,
                color: '#ff4500'
              });
            }
            break;
          case 'genbu': // ç„æ­¦ï¼šæ°·ã®å¼¾ã‚’5ç™ºï¼ˆæ‰‡çŠ¶ï¼‰
            for (let i = 0; i < 5; i++) {
              const angle = Math.atan2(dy, dx) + (i - 2) * 0.4;
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * 60,
                vy: Math.sin(angle) * 60,
                life: 4.0,
                color: '#00bfff'
              });
            }
            break;
          case 'seiryu': // é’é¾ï¼šé›·ã®å¼¾ã‚’8ç™ºï¼ˆå††å½¢ï¼‰
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * 70,
                vy: Math.sin(angle) * 70,
                life: 2.5,
                color: '#ffff00'
              });
            }
            break;
          case 'kirin': // éº’éºŸï¼šè¿½å°¾å¼¾
            if (dist > 0 && !isNaN(dist)) {
              this.bullets.push({
                x: this.x, y: this.y,
                vx: (dx / dist) * 50,
                vy: (dy / dist) * 50,
                life: 5.0,
                color: '#ffd700',
                tracking: true
              });
            } else {
              // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è·é›¢ãŒè¨ˆç®—ã§ããªã„å ´åˆã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆæ–¹å‘ã«ç™ºå°„
              this.bullets.push({
                x: this.x, y: this.y,
                vx: 50,
                vy: 0,
                life: 5.0,
                color: '#ffd700',
                tracking: true
              });
            }
            break;
        }
      } else {
        // ãƒ•ã‚§ãƒ¼ã‚º2: ã‚ˆã‚Šå¼·åŠ›ãªæ”»æ’ƒ
        switch(this.type) {
          case 'suzaku': // æœ±é›€ï¼šç«ã®ç‰ã‚’5ç™ºï¼ˆã‚ˆã‚Šåºƒç¯„å›²ï¼‰
            for (let i = 0; i < 5; i++) {
              const angle = Math.atan2(dy, dx) + (i - 2) * 0.4;
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * 90,
                vy: Math.sin(angle) * 90,
                life: 3.5,
                color: '#ff0000'
              });
            }
            break;
          case 'genbu': // ç„æ­¦ï¼šæ°·ã®å¼¾ã‚’8ç™ºï¼ˆ8æ–¹å‘å…¨æ–¹å‘ï¼‰
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * 65,
                vy: Math.sin(angle) * 65,
                life: 4.5,
                color: '#00dfff'
              });
            }
            break;
          case 'seiryu': // é’é¾ï¼šå††å½¢8ç™º + è¿½å°¾å¼¾1ç™º
            // å††å½¢æ”»æ’ƒ
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              this.bullets.push({
                x: this.x, y: this.y,
                vx: Math.cos(angle) * 75,
                vy: Math.sin(angle) * 75,
                life: 3.0,
                color: '#ffff00'
              });
            }
            // è¿½å°¾å¼¾
            if (dist > 0) {
              this.bullets.push({
                x: this.x, y: this.y,
                vx: (dx / dist) * 60,
                vy: (dy / dist) * 60,
                life: 4.0,
                color: '#ffff88',
                tracking: true
              });
            }
            break;
          case 'kirin': // éº’éºŸï¼šé€£ç¶šè¿½å°¾å¼¾2ç™º
            if (dist > 0) {
              for (let i = 0; i < 2; i++) {
                const angle = Math.atan2(dy, dx) + (i - 0.5) * 0.2;
                this.bullets.push({
                  x: this.x, y: this.y,
                  vx: Math.cos(angle) * 55,
                  vy: Math.sin(angle) * 55,
                  life: 5.5,
                  color: '#ffed4e',
                  tracking: true
                });
              }
            }
            break;
        }
      }
      Sound.playSound('button');
    }
  }

  // æ‘é•·ãƒœã‚¹ã‚¯ãƒ©ã‚¹
  class VillageChiefBoss extends Entity {
    constructor(x, y) {
      super(x, y);
      this.w = 36; this.h = 36; // é€šå¸¸ã‚µã‚¤ã‚º
      this.maxHp = 100;
      this.hp = 100;
      this.dead = false;
      this.phase = 1; // 1: é€šå¸¸ã€2: å·¨å¤§åŒ–ã€3: æœ¬æ°—
      this.attackCd = 0;
      this.bullets = [];
      this.animT = 0;
      this.speed = 40;
      this.scale = 1;
      this.targetScale = 1; // ç›®æ¨™ã‚¹ã‚±ãƒ¼ãƒ«
      this.transformTime = 0; // å¤‰å½¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ™‚é–“
      this.isTransforming = false; // å¤‰å½¢ä¸­ãƒ•ãƒ©ã‚°
    }
    
    update(dt) {
      this.animT += dt;
      this.attackCd -= dt;
      
      // å¤‰å½¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
      if (this.isTransforming) {
        this.transformTime += dt;
        const transformDuration = 1.0; // 1ç§’ã‹ã‘ã¦å¤‰å½¢
        if (this.transformTime < transformDuration) {
          // ã‚¹ãƒ ãƒ¼ã‚ºã«ã‚¹ã‚±ãƒ¼ãƒ«ã‚’å¤‰åŒ–
          const progress = this.transformTime / transformDuration;
          const easeProgress = progress < 0.5 
            ? 2 * progress * progress 
            : 1 - Math.pow(-2 * progress + 2, 2) / 2; // ease-in-out
          this.scale = 1 + (this.targetScale - 1) * easeProgress;
          this.w = 36 * this.scale;
          this.h = 36 * this.scale;
        } else {
          // å¤‰å½¢å®Œäº†
          this.scale = this.targetScale;
          this.w = 36 * this.scale;
          this.h = 36 * this.scale;
          this.isTransforming = false;
        }
      }
      
      // phase 2ã¨3ã¯å·¨å¤§åŒ–
      if (this.phase === 2 || this.phase === 3) {
        if (!this.isTransforming && this.scale !== 3) {
          // å¤‰å½¢é–‹å§‹
          this.targetScale = 3;
          this.isTransforming = true;
          this.transformTime = 0;
        }
        if (!this.isTransforming) {
          this.scale = 3;
          this.w = 108; this.h = 108;
        }
        // phase 3ã¯ç´ æ—©ã•2å€
        if (this.phase === 3) {
          this.speed = 80;
        }
      }
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«å‘ã‹ã£ã¦ç§»å‹•
      const dx = player.x - this.x;
      const dy = player.y - this.y;
      const dist = Math.hypot(dx, dy);
      if (dist > 0) {
        this.vx = (dx / dist) * this.speed;
        this.vy = (dy / dist) * this.speed;
      }
      
      if (this.attackCd <= 0) {
        if (this.phase === 3) {
          // æœ¬æ°—ãƒ¢ãƒ¼ãƒ‰ï¼šå¼¾ã‚’æ‰“ã¤
          for (let i = 0; i < 5; i++) {
            const angle = Math.atan2(dy, dx) + (i - 2) * 0.2;
            this.bullets.push({
              x: this.x, y: this.y,
              vx: Math.cos(angle) * 100,
              vy: Math.sin(angle) * 100,
              life: 3.0,
              color: ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'][i % 5]
            });
          }
        }
        this.attackCd = this.phase === 3 ? 0.8 : 1.5;
        Sound.playSound('button');
      }
    }
  }

  class Arrow extends Entity {
    constructor(x,y,vx,vy) {
      super(x,y);
      this.vx=vx; this.vy=vy; this.w=6; this.h=2; this.life=2.5;
    }
  }

  class Shuriken extends Entity {
    constructor(x, y, vx, vy) {
      super(x, y);
      this.vx = vx;
      this.vy = vy;
      this.w = 8;
      this.h = 8;
      this.life = 2.0;
      this.rot = 0;
      this.dead = false;
    }
  }

  class Spear extends Entity {
    constructor(x, y, vx, vy) {
      super(x, y);
      this.vx = vx;
      this.vy = vy;
      this.w = 8;
      this.h = 20;
      this.life = 2.5;
      this.rot = 0;
      this.dead = false;
    }
  }

  class Rocket extends Entity {
    constructor(x, y, vx, vy) {
      super(x, y);
      this.vx = vx;
      this.vy = vy;
      this.w = 6;
      this.h = 12;
      this.life = 3.0;
      this.rot = 0;
      this.dead = false;
    }
  }

  class Bomb {
    constructor(x,y,mapX,mapY) {
      this.x=x; this.y=y; this.t=5.0; this.exploded=false; // 5ç§’å¾Œã«çˆ†ç™º
      this.mapX=mapX; this.mapY=mapY; // ãƒãƒƒãƒ—åº§æ¨™ã‚’ä¿å­˜
    }
  }

  class Explosion {
    constructor(x,y) {
      this.x=x; this.y=y; this.t=0.4; this.power=2;
    }
  }

  // ãƒã‚ºãƒ¼ã‚«ã®ç ´ç‰‡
  class Fragment extends Entity {
    constructor(x, y, vx, vy) {
      super(x, y);
      this.vx = vx;
      this.vy = vy;
      this.w = 3;
      this.h = 3;
      this.life = 0.5;
      this.dead = false;
    }
  }

  // ã‚²ãƒ¼ãƒ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆãƒãƒƒãƒ—ã”ã¨ã«ç®¡ç†ï¼‰
  const player = new Player(160, 96);
  const mapEntities = new Map(); // ãƒãƒƒãƒ—ã”ã¨ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’ç®¡ç†
  
  function getMapEntities() {
    const key = getMapKey(currentMapX, currentMapY);
    if (!mapEntities.has(key)) {
      const entities = {
        npcs: [],
        chests: [],
        slimes: [],
        archers: [],
        cacti: [],
        snowwolves: [],
        scorpions: [],
        krakens: [],
        firespirits: [],
        bosses: [],
        chiefBoss: null
      };
      
      // å››éš…ã«ãƒœã‚¹ã‚’é…ç½®ï¼ˆèµ¤ã„å®ã¨åŒã˜ä½ç½®ï¼‰
      if (currentMapX === -3 && currentMapY === -3) {
        // åŒ—è¥¿ï¼šç„æ­¦
        entities.bosses = [new Boss(160, 80, 'genbu')];
      } else if (currentMapX === 3 && currentMapY === -3) {
        // åŒ—æ±ï¼šé’é¾
        entities.bosses = [new Boss(160, 80, 'seiryu')];
      } else if (currentMapX === -3 && currentMapY === 3) {
        // å—è¥¿ï¼šéº’éºŸ
        entities.bosses = [new Boss(160, 80, 'kirin')];
      } else if (currentMapX === 3 && currentMapY === 3) {
        // å—æ±ï¼šæœ±é›€
        entities.bosses = [new Boss(160, 80, 'suzaku')];
      }
      
      // ãƒãƒƒãƒ—ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’é…ç½®
      if (currentMapX === 0 && currentMapY === 0) {
        // ä¸­å¤®ï¼šæ‘ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
        entities.npcs = [{
          x: 160, y: 56, r: 14, 
          texts: (() => {
            const base = [
              'ã‚ˆã†ã“ãã€å‹‡è€…ã‚ˆï¼\nç§ã¯ã“ã®æ‘ã®é•·è€ã ã€‚',
              'æœ€è¿‘ã€å±é™ºãªãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼ãŒ\nå¢—ãˆã¦å›°ã£ã¦ã„ã‚‹ã‚“ã ã€‚',
              'å›ã®åŠ›ã§æ‘ã‚’å®ˆã£ã¦\nãã‚Œã‚‹ã¨ã‚ã‚ŠãŒãŸã„ã€‚',
              'âš”ï¸ãƒœã‚¿ãƒ³ã§æ”»æ’ƒã€\nğŸ’£ãƒœã‚¿ãƒ³ã§çˆ†å¼¾ãŒä½¿ãˆã‚‹ãã€‚',
              'é ‘å¼µã£ã¦ãã‚Œï¼'
            ];
            
            // ãƒœã‚¹ã‚¢ã‚¤ãƒ†ãƒ ã‚’ç²å¾—ã—ãŸã‚‰è¤’ã‚ã‚‹
            if (state.bossItems.length > 0) {
              const items = state.bossItems;
              if (items.includes('æ‘é•·ã®æ–')) base.push('ãŠãŠã€æ‘é•·ã®æ–ã‚’ï¼\nã‚ˆãã‚„ã£ãŸï¼');
              if (items.includes('æ‘é•·ã®ãƒ¡ã‚¬ãƒ')) base.push('æ‘é•·ã®ãƒ¡ã‚¬ãƒã‚‚ï¼\nç´ æ™´ã‚‰ã—ã„ï¼');
              if (items.includes('æ‘é•·ã®è¨¼æ˜æ›¸')) base.push('æ‘é•·ã®è¨¼æ˜æ›¸ã¾ã§ï¼\nç«‹æ´¾ã ï¼');
              if (items.includes('æ‘é•·ã®ãƒãƒ³ã‚«ãƒ')) base.push('æ‘é•·ã®ãƒãƒ³ã‚«ãƒã‚‚ï¼\nå®Œç’§ã ï¼');
            }
            
            return base;
          })(),
          deathTexts: [
            'ãŠã„ãŠã„...ã¾ãŸæ­»ã‚“ã˜ã¾ã£ãŸã®ã‹ã€‚',
            'é ¼ã‚“ã ã®ã«ã€ã“ã‚“ãªã«\nå¼±ã„ã‚“ã˜ã‚ƒå›°ã‚‹ã‚“ã ã‚ˆã€‚',
            'æ‘ã®æœŸå¾…ã‚’è£åˆ‡ã‚‹æ°—ã‹ï¼Ÿ\nã‚‚ã£ã¨æ°—åˆã‚’å…¥ã‚Œã‚ï¼',
            'ã‚³ã‚¤ãƒ³ã‚‚åŠåˆ†ã«ãªã£ã¡ã¾ã£ãŸ...\næ¬¡ã¯æ°—ã‚’ã¤ã‘ã‚ã‚ˆã€‚',
            'ã¾ã‚ã€ç”Ÿãè¿”ã£ã¦ãã‚ŒãŸã ã‘\nãƒã‚·ã‹ã‚‚ã—ã‚Œã‚“ãŒãª...'
          ],
          currentTextIndex: 0,
          talked: false,
          rewardShown: false
        }];
        entities.chests = [
          {x: 208, y: 96, r: 12, opened:false},
          {x: 80, y: 140, r: 12, opened:false}
        ];
        entities.slimes = [new Slime(80,40), new Slime(260,120), new Slime(50,160)];
        entities.archers = [new Archer(56,40), new Archer(280,60)];
      } else if (currentMapX === 0 && currentMapY === -1) {
        // ä¸Šï¼šæ£®ã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
        entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,100), new Slime(260,40)];
        entities.archers = [new Archer(80,60), new Archer(240,90)];
      } else if (currentMapX === 0 && currentMapY === 1) {
        // ä¸‹ï¼šæµ·å²¸ã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 50, r: 12, opened:false}, {x: 240, y: 60, r: 12, opened:false}];
        entities.slimes = [new Slime(100,40), new Slime(220,50), new Slime(60,30)];
        entities.archers = [new Archer(120,45)];
      } else if (currentMapX === -1 && currentMapY === 0) {
        // å·¦ï¼šæ´çªŸã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 90, r: 12, opened:false}];
        entities.slimes = [new Slime(80,50), new Slime(240,70), new Slime(120,100), new Slime(200,40)];
        entities.archers = [new Archer(100,60), new Archer(220,80)];
      } else if (currentMapX === 1 && currentMapY === 0) {
        // å³ï¼šè‰åŸã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 80, y: 100, r: 12, opened:false}];
        entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,90)];
        entities.archers = [new Archer(140,60), new Archer(260,80)];
      } else if (currentMapX === -1 && currentMapY === -1) {
        // åŒ—è¥¿ï¼šå»ƒå¢Ÿã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
        entities.slimes = [new Slime(120,60), new Slime(200,80), new Slime(80,100)];
        entities.archers = [new Archer(100,70), new Archer(220,90)];
      } else if (currentMapX === 3 && currentMapY === -3) {
        // åŒ—æ±ã®å››éš…ï¼šé’é¾ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆãƒã‚ºãƒ¼ã‚«ã®å®ç®±ã¯åˆ¥ã®å ´æ‰€ï¼‰
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
      } else if (currentMapX === -3 && currentMapY === -3) {
        // åŒ—è¥¿ã®å››éš…ï¼šç„æ­¦ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆé•·æ§ã®å®ç®±ã¯åˆ¥ã®å ´æ‰€ï¼‰
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
      } else if (currentMapX === -3 && currentMapY === 3) {
        // å—è¥¿ã®å››éš…ï¼šéº’éºŸãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
      } else if (currentMapX === 3 && currentMapY === 3) {
        // å—æ±ã®å››éš…ï¼šæœ±é›€ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ï¼ˆæ‰‹è£å‰£ã®å®ç®±ã¯åˆ¥ã®å ´æ‰€ï¼‰
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
      } else if (currentMapX === 1 && currentMapY === -1) {
        // åŒ—æ±ï¼šèŠ±ç•‘ã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 240, y: 60, r: 12, opened:false}];
        entities.slimes = [new Slime(100,50), new Slime(180,70)];
        entities.archers = [new Archer(120,60)];
      } else if (currentMapX === -1 && currentMapY === 1) {
        // å—è¥¿ï¼šæµ·å²¸æ´çªŸã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 80, y: 80, r: 12, opened:false}, {x: 240, y: 100, r: 12, opened:false}];
        entities.slimes = [new Slime(60,50), new Slime(200,70), new Slime(100,120)];
        entities.archers = [new Archer(80,60), new Archer(220,80)];
      } else if (currentMapX === 1 && currentMapY === 1) {
        // å—æ±ï¼šãƒ“ãƒ¼ãƒã®ã‚¨ãƒªã‚¢
        entities.chests = [{x: 160, y: 50, r: 12, opened:false}, {x: 240, y: 70, r: 12, opened:false}];
        entities.slimes = [new Slime(100,40), new Slime(220,60), new Slime(60,50)];
        entities.archers = [new Archer(140,45)];
      } else if (currentMapX === 2 && currentMapY === -2) {
        // åŒ—æ±æ–¹å‘ï¼šã‚µãƒœãƒ†ãƒ³ã€é™½æ°—ãªä¸–ç•Œï¼ˆãƒã‚ºãƒ¼ã‚«ã®å®ç®± - 1ã¤ã®ã¿ï¼‰
        entities.chests = [
          {x: 160, y: 80, r: 12, opened:false},
          {x: 80, y: 100, r: 12, opened:false},
          {x: 240, y: 60, r: 12, opened:false, weapon: 'bazooka'} // ãƒã‚ºãƒ¼ã‚«
        ];
        entities.cacti = [new CactusMonster(100,50), new CactusMonster(220,70), new CactusMonster(60,90), new CactusMonster(260,50)];
        entities.firespirits = [new FireSpirit(140,60), new FireSpirit(180,80)];
      } else if (currentMapX === -2 && currentMapY === -2) {
        // åŒ—è¥¿æ–¹å‘ï¼šé›ªã€æ£®æ—åœ°å¸¯ã€å±±ï¼ˆé•·æ§ã®å®ç®± - 1ã¤ã®ã¿ï¼‰
        entities.chests = [
          {x: 80, y: 60, r: 12, opened:false, weapon: 'spear'} // é•·æ§
        ];
        entities.snowwolves = [new SnowWolf(100,50), new SnowWolf(220,70), new SnowWolf(60,100), new SnowWolf(240,40)];
        entities.archers = [new Archer(120,60), new Archer(200,80)];
      } else if (currentMapX === 2 && currentMapY === 2) {
        // å—æ±æ–¹å‘ï¼šæ°´ã¨å³¶ã€æµ·æ´‹ï¼ˆæ‰‹è£å‰£ã®å®ç®± - 1ã¤ã®ã¿ï¼‰
        entities.chests = [
          {x: 160, y: 50, r: 12, opened:false},
          {x: 240, y: 70, r: 12, opened:false},
          {x: 80, y: 40, r: 12, opened:false, weapon: 'shuriken'} // æ‰‹è£å‰£
        ];
        entities.krakens = [new OceanKraken(100,40), new OceanKraken(220,60), new OceanKraken(60,50), new OceanKraken(260,80)];
        entities.archers = [new Archer(140,45)];
      } else if (currentMapX >= 2 || (currentMapX > 0 && currentMapY <= -2)) {
        // ãã®ä»–ã®åŒ—æ±æ–¹å‘ï¼šã‚µãƒœãƒ†ãƒ³ã€é™½æ°—ãªä¸–ç•Œï¼ˆãƒã‚ºãƒ¼ã‚«ãªã—ï¼‰
        entities.chests = [
          {x: 160, y: 80, r: 12, opened:false},
          {x: 80, y: 100, r: 12, opened:false}
        ];
        entities.cacti = [new CactusMonster(100,50), new CactusMonster(220,70), new CactusMonster(60,90), new CactusMonster(260,50)];
        entities.firespirits = [new FireSpirit(140,60), new FireSpirit(180,80)];
      } else if (currentMapX <= -2 || (currentMapX < 0 && currentMapY <= -2)) {
        // ãã®ä»–ã®åŒ—è¥¿æ–¹å‘ï¼šé›ªã€æ£®æ—åœ°å¸¯ã€å±±ï¼ˆé•·æ§ãªã—ï¼‰
        entities.chests = [
          {x: 160, y: 80, r: 12, opened:false}
        ];
        entities.snowwolves = [new SnowWolf(100,50), new SnowWolf(220,70), new SnowWolf(60,100), new SnowWolf(240,40)];
        entities.archers = [new Archer(120,60), new Archer(200,80)];
      } else if (currentMapX <= -2 || (currentMapX < 0 && currentMapY >= 2)) {
        // å—è¥¿æ–¹å‘ï¼šç ‚æ¼ ã¨æ´çªŸ
        entities.chests = [
          {x: 160, y: 80, r: 12, opened:false},
          {x: 80, y: 100, r: 12, opened:false}
        ];
        entities.scorpions = [new DesertScorpion(100,50), new DesertScorpion(220,70), new DesertScorpion(60,90), new DesertScorpion(240,100)];
        entities.archers = [new Archer(120,60)];
      } else if (currentMapX >= 2 || (currentMapX > 0 && currentMapY >= 2)) {
        // ãã®ä»–ã®å—æ±æ–¹å‘ï¼šæ°´ã¨å³¶ã€æµ·æ´‹ï¼ˆæ‰‹è£å‰£ãªã—ï¼‰
        entities.chests = [
          {x: 160, y: 50, r: 12, opened:false},
          {x: 240, y: 70, r: 12, opened:false}
        ];
        entities.krakens = [new OceanKraken(100,40), new OceanKraken(220,60), new OceanKraken(60,50), new OceanKraken(260,80)];
        entities.archers = [new Archer(140,45)];
      } else if (currentMapY <= -2) {
        // ãã®ä»–ã®åŒ—å´ã‚¨ãƒªã‚¢
        if (currentMapX < 0) {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70)];
          entities.archers = [new Archer(140,60)];
        } else {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 240, y: 60, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,90)];
          entities.archers = [new Archer(140,60)];
        }
      } else if (currentMapY >= 2) {
        // ãã®ä»–ã®å—å´ã‚¨ãƒªã‚¢
        if (currentMapX < 0) {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,90)];
          entities.archers = [new Archer(120,60)];
        } else {
          entities.chests = [{x: 160, y: 50, r: 12, opened:false}, {x: 240, y: 70, r: 12, opened:false}];
          entities.slimes = [new Slime(100,40), new Slime(220,60), new Slime(60,50)];
          entities.archers = [new Archer(140,45)];
        }
      } else if (currentMapX <= -2) {
        // ãã®ä»–ã®è¥¿å´ã‚¨ãƒªã‚¢
        if (currentMapY < 0) {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70)];
          entities.archers = [new Archer(140,60)];
        } else {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,90)];
          entities.archers = [new Archer(120,60)];
        }
      } else if (currentMapX >= 2) {
        // ãã®ä»–ã®æ±å´ã‚¨ãƒªã‚¢
        if (currentMapY < 0) {
          entities.chests = [{x: 160, y: 80, r: 12, opened:false}, {x: 240, y: 60, r: 12, opened:false}];
          entities.slimes = [new Slime(100,50), new Slime(220,70), new Slime(60,90)];
          entities.archers = [new Archer(140,60)];
        } else {
          entities.chests = [{x: 160, y: 50, r: 12, opened:false}, {x: 240, y: 70, r: 12, opened:false}];
          entities.slimes = [new Slime(100,40), new Slime(220,60), new Slime(60,50)];
          entities.archers = [new Archer(140,45)];
        }
      }
      
      mapEntities.set(key, entities);
    }
    return mapEntities.get(key);
  }
  
  const arrows = [];
  const bombs = [];
  const blasts = [];
  const shurikens = []; // æ‰‹è£å‰£
  const spears = []; // é•·æ§ï¼ˆæŠ•æ“²ç”¨ã€ä»Šå¾Œã¯ä½¿ç”¨ã—ãªã„ï¼‰
  const rockets = []; // ãƒã‚ºãƒ¼ã‚«ã®ãƒ­ã‚±ãƒƒãƒˆ
  const fragments = []; // ãƒã‚ºãƒ¼ã‚«ã®ç ´ç‰‡

  // å®‰å…¨ãªè¡çªåˆ¤å®š
  function getTile(x, y) {
    const map = getCurrentMap();
    if (y < 0 || y >= ROWS || x < 0 || x >= COLS) return T.TREE; // å¢ƒç•Œå¤–ã¯å£
    if (!map[y] || map[y][x] === undefined) return T.TREE;
    return map[y][x];
  }

  function moveWithTile(e, dt, allowEdgePass = false) {
    let nx = e.x + e.vx * dt;
    let ny = e.y + e.vy * dt;
    
    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å ´åˆã€ç”»é¢ç«¯ã§ã®è¡çªåˆ¤å®šã‚’ã‚¹ã‚­ãƒƒãƒ—
    if (allowEdgePass) {
      // ç”»é¢ç«¯ã«è¿‘ã„å ´åˆã¯ã€ã‚¿ã‚¤ãƒ«è¡çªåˆ¤å®šã‚’ã‚¹ã‚­ãƒƒãƒ—
      const nearLeftEdge = nx < TS;
      const nearRightEdge = nx > W - TS;
      const nearTopEdge = ny < TS;
      const nearBottomEdge = ny > H - TS;
      
      if (nearLeftEdge || nearRightEdge || nearTopEdge || nearBottomEdge) {
        // ç”»é¢ç«¯ã«è¿‘ã„å ´åˆã¯ç§»å‹•ã‚’è¨±å¯ï¼ˆãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆã®ãŸã‚ï¼‰
        e.x = nx;
        e.y = ny;
      } else {
        // é€šå¸¸ã®è¡çªåˆ¤å®š
        if (!collidesTile(nx, e.y, e.w, e.h)) e.x = nx; else e.vx=0;
        if (!collidesTile(e.x, ny, e.w, e.h)) e.y = ny; else e.vy=0;
      }
    } else {
      // é€šå¸¸ã®ç§»å‹•å‡¦ç†
      if (!collidesTile(nx, e.y, e.w, e.h)) e.x = nx; else e.vx=0;
      if (!collidesTile(e.x, ny, e.w, e.h)) e.y = ny; else e.vy=0;
    }
  }

  function collidesTile(cx, cy, w, h) {
    // ç”»é¢å¤–ã®å ´åˆã¯è¡çªã—ãªã„ï¼ˆãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆã‚’è¨±å¯ï¼‰
    if (cx - w/2 < 0 || cx + w/2 > W || cy - h/2 < 0 || cy + h/2 > H) {
      return false;
    }
    
    const x0 = Math.floor((cx-w/2)/TS);
    const x1 = Math.floor((cx+w/2)/TS);
    const y0 = Math.floor((cy-h/2)/TS);
    const y1 = Math.floor((cy+h/2)/TS);
    
    for(let y=y0;y<=y1;y++) {
      for(let x=x0;x<=x1;x++){
        const tile = getTile(x, y);
        if (isBlock(tile)) return true;
      }
    }
    return false;
  }

  // æ”»æ’ƒ
  function attack() {
    if (player.attackCd>0) return;
    player.attackCd = 0.3;
    
    const dirX = Math.sign(Input.ax || player.dir) || player.dir;
    const dirY = Math.sign(Input.ay || 0);
    player.sdx = dirX; player.sdy = dirY;
    player.swordT = 0.18;

    Sound.playSound('sword');

    // é€šå¸¸ã®å‰£ã®ãƒªãƒ¼ãƒ
    const baseRange = 18;
    const range = baseRange;
    const w=16, h=12;
    const ax = player.x + dirX*range;
    const ay = player.y + dirY*range;
    const hit = (e) => Math.abs(e.x-ax)<w/2 && Math.abs(e.y-ay)<h/2;
    
    const entities = getMapEntities();
    let hitSomething = false;
    for (const s of entities.slimes) {
      if (!s.dead && hit(s)) {
        s.hp--;
        hitSomething = true;
        if (s.hp<=0) {
          s.dead=true;
          state.coins+=3;
          gainExp(2);
          showHint('ğŸŸ¢ ã‚¹ãƒ©ã‚¤ãƒ æ’ƒç ´! +3ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const a of entities.archers) {
      if (!a.dead && hit(a)) {
        a.hp--;
        a.alertT = 0.5;
        hitSomething = true;
        if (a.hp<=0) {
          a.dead=true;
          state.coins+=5;
          gainExp(3);
          showHint('ğŸ¹ ã‚¢ãƒ¼ãƒãƒ£ãƒ¼æ’ƒç ´! +5ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const c of entities.cacti) {
      if (!c.dead && hit(c)) {
        c.hp--;
        hitSomething = true;
        if (c.hp<=0) {
          c.dead=true;
          state.coins+=4;
          gainExp(2);
          showHint('ğŸŒµ ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´! +4ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const w of entities.snowwolves) {
      if (!w.dead && hit(w)) {
        w.hp--;
        hitSomething = true;
        if (w.hp<=0) {
          w.dead=true;
          state.coins+=4;
          gainExp(3);
          showHint('ğŸº é›ªã‚ªã‚ªã‚«ãƒŸæ’ƒç ´! +4ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const sc of entities.scorpions) {
      if (!sc.dead && hit(sc)) {
        sc.hp--;
        hitSomething = true;
        if (sc.hp<=0) {
          sc.dead=true;
          state.coins+=5;
          gainExp(3);
          showHint('ğŸ¦‚ ã‚µã‚½ãƒªæ’ƒç ´! +5ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const k of entities.krakens) {
      if (!k.dead && hit(k)) {
        k.hp--;
        k.alertT = 0.5;
        hitSomething = true;
        if (k.hp<=0) {
          k.dead=true;
          state.coins+=6;
          gainExp(4);
          showHint('ğŸ™ ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³æ’ƒç ´! +6ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
    for (const f of entities.firespirits) {
      if (!f.dead && hit(f)) {
        f.hp--;
        hitSomething = true;
        if (f.hp<=0) {
          f.dead=true;
          state.coins+=4;
          gainExp(2);
          showHint('ğŸ”¥ ç‚ã®ç²¾éœŠæ’ƒç ´! +4ğŸ’°');
        } else {
          Sound.playSound('hit');
        }
      }
    }
  }

  // æ­¦å™¨ä½¿ç”¨é–¢æ•°
  function useWeapon() {
    // ãƒãƒ¼ã‚ºä¸­ã‚„ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã¯æ­¦å™¨ã‚’ä½¿ç”¨ã§ããªã„
    if (state.paused || state.ending) {
      return;
    }
    
    // æ­¦å™¨ä½¿ç”¨ä¸­ã®ç¡¬ç›´æ™‚é–“ä¸­ã¯ä½¿ç”¨ã§ããªã„
    if (player.weaponCd > 0) {
      return;
    }
    
    // æ­¦å™¨é¸æŠãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒé–‹ã„ã¦ã„ã‚‹å ´åˆã¯é–‰ã˜ã‚‹
    const weaponSelect = document.getElementById('weaponSelect');
    if (weaponSelect && weaponSelect.open) {
      weaponSelect.close();
      state.paused = false;
    }
    
    const weapon = WEAPONS[state.currentWeapon.toUpperCase()];
    if (!weapon) return;

    // æ­¦å™¨ä½¿ç”¨æ™‚ã®ç¡¬ç›´æ™‚é–“ã‚’è¨­å®šï¼ˆæ­¦å™¨ã«ã‚ˆã£ã¦ç•°ãªã‚‹ï¼‰
    let cooldown = 0.2; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ
    
    switch(state.currentWeapon) {
      case 'bomb':
        // ç¾åœ¨ã®ãƒãƒƒãƒ—ã®çˆ†å¼¾ã®ã¿ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
        const currentBombs = bombs.filter(b => b.mapX === currentMapX && b.mapY === currentMapY);
        if (currentBombs.length >= 3) return;
        bombs.push(new Bomb(Math.round(player.x/TS)*TS, Math.round(player.y/TS)*TS, currentMapX, currentMapY));
        Sound.playSound('button');
        showHint('ğŸ’£ çˆ†å¼¾è¨­ç½®');
        cooldown = 0.3; // çˆ†å¼¾ã¯å°‘ã—é•·ã‚
        break;
      
      case 'shuriken':
        if (shurikens.length >= 5) return;
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é€²è¡Œæ–¹å‘ã«çœŸã£ç›´ãé£›ã¶
        const dirX = Math.sign(Input.ax) || player.dir;
        const dirY = Math.sign(Input.ay) || 0;
        // ç§»å‹•ã—ã¦ã„ãªã„å ´åˆã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ã„ã¦ã„ã‚‹æ–¹å‘ã«é£›ã¶
        const finalDirX = (dirX === 0 && dirY === 0) ? player.dir : dirX;
        const finalDirY = (dirX === 0 && dirY === 0) ? 0 : dirY;
        const speed = 150;
        shurikens.push(new Shuriken(player.x, player.y, finalDirX * speed, finalDirY * speed));
        Sound.playSound('sword');
        showHint('â­ æ‰‹è£å‰£');
        cooldown = 0.15; // æ‰‹è£å‰£ã¯ç´ æ—©ã„
        break;
      
      case 'spear':
        // æ§ã¯è¿‘æ¥æ”»æ’ƒã¨ã—ã¦ä½¿ç”¨
        if (player.attackCd > 0) return;
        player.attackCd = 0.3;
        
        const sDirX = Math.sign(Input.ax || player.dir) || player.dir;
        const sDirY = Math.sign(Input.ay || 0);
        player.sdx = sDirX; player.sdy = sDirY;
        player.swordT = 0.18;

        Sound.playSound('sword');

        // æ§ã®å ´åˆã¯ãƒªãƒ¼ãƒã‚’2å€ã«
        const baseRange = 18;
        const range = baseRange * 2; // æ§ã¯2å€ã®ãƒªãƒ¼ãƒ
        const w=16, h=12;
        const ax = player.x + sDirX*range;
        const ay = player.y + sDirY*range;
        const hit = (e) => Math.abs(e.x-ax)<w/2 && Math.abs(e.y-ay)<h/2;
        
        const entities = getMapEntities();
        let hitSomething = false;
        for (const s of entities.slimes) {
          if (!s.dead && hit(s)) {
            s.hp -= 2;
            hitSomething = true;
            if (s.hp<=0) {
              s.dead=true;
              state.coins+=3;
              gainExp(2);
              showHint('ğŸ”± é•·æ§ã§ã‚¹ãƒ©ã‚¤ãƒ æ’ƒç ´!');
            }
          }
        }
        for (const a of entities.archers) {
          if (!a.dead && hit(a)) {
            a.hp -= 2;
            hitSomething = true;
            if (a.hp<=0) {
              a.dead=true;
              state.coins+=5;
              gainExp(3);
              showHint('ğŸ”± é•·æ§ã§ã‚¢ãƒ¼ãƒãƒ£ãƒ¼æ’ƒç ´!');
            }
          }
        }
        for (const c of entities.cacti) {
          if (!c.dead && hit(c)) {
            c.hp -= 2;
            hitSomething = true;
            if (c.hp<=0) {
              c.dead=true;
              state.coins+=4;
              gainExp(2);
              showHint('ğŸ”± é•·æ§ã§ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´!');
            }
          }
        }
        for (const w of entities.snowwolves) {
          if (!w.dead && hit(w)) {
            w.hp -= 2;
            hitSomething = true;
            if (w.hp<=0) {
              w.dead=true;
              state.coins+=4;
              gainExp(3);
              showHint('ğŸ”± é•·æ§ã§é›ªã‚ªã‚ªã‚«ãƒŸæ’ƒç ´!');
            }
          }
        }
        for (const sc of entities.scorpions) {
          if (!sc.dead && hit(sc)) {
            sc.hp -= 2;
            hitSomething = true;
            if (sc.hp<=0) {
              sc.dead=true;
              state.coins+=5;
              gainExp(3);
              showHint('ğŸ”± é•·æ§ã§ã‚µã‚½ãƒªæ’ƒç ´!');
            }
          }
        }
        for (const k of entities.krakens) {
          if (!k.dead && hit(k)) {
            k.hp -= 2;
            hitSomething = true;
            if (k.hp<=0) {
              k.dead=true;
              state.coins+=6;
              gainExp(4);
              showHint('ğŸ”± é•·æ§ã§ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³æ’ƒç ´!');
            }
          }
        }
        for (const f of entities.firespirits) {
          if (!f.dead && hit(f)) {
            f.hp -= 2;
            hitSomething = true;
            if (f.hp<=0) {
              f.dead=true;
              state.coins+=4;
              gainExp(2);
              showHint('ğŸ”± é•·æ§ã§ç‚ã®ç²¾éœŠæ’ƒç ´!');
            }
          }
        }
        // ãƒœã‚¹ã«ã‚‚å½“ãŸã‚‹
        for (const boss of entities.bosses) {
          if (!boss.dead && hit(boss)) {
            boss.hp -= 2;
            hitSomething = true;
            if (boss.hp <= 0) {
              boss.dead = true;
              if (!state.defeatedBosses.includes(boss.type)) {
                state.defeatedBosses.push(boss.type);
              }
              state.coins += 50;
              gainExp(10);
              const bossNames = {
                'suzaku': 'æœ±é›€',
                'genbu': 'ç„æ­¦',
                'seiryu': 'é’é¾',
                'kirin': 'éº’éºŸ'
              };
              showHint(`ğŸ’€ ${bossNames[boss.type]}æ’ƒç ´ï¼\nå®ç®±ã‚’ç¢ºèªã—ã¦ã¿ã‚ˆã†`, 3.0);
            }
          }
        }
        
        if (hitSomething) {
          Sound.playSound('hit');
        }
        
        showHint('ğŸ”± é•·æ§');
        cooldown = 0.25; // æ§ã®ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³
        break;
      
      case 'bazooka':
        if (rockets.length >= 2) return;
        const bDirX = Math.sign(Input.ax || player.dir) || player.dir;
        const bDirY = Math.sign(Input.ay || 0) || 0;
        if (bDirX === 0 && bDirY === 0) bDirY = 1;
        const bSpeed = 100;
        rockets.push(new Rocket(player.x, player.y, bDirX * bSpeed, bDirY * bSpeed));
        Sound.playSound('bomb');
        showHint('ğŸš€ ãƒã‚ºãƒ¼ã‚«ç™ºå°„');
        cooldown = 0.4; // ãƒã‚ºãƒ¼ã‚«ã¯é‡ã„ã®ã§é•·ã‚
        break;
    }
    
    // ç¡¬ç›´æ™‚é–“ã‚’è¨­å®š
    player.weaponCd = cooldown;
  }

  function hitPlayer(dmg) {
    if (player.inv>0) return;
    player.hp = Math.max(0, player.hp - dmg);
    state.hp = player.hp;
    player.inv = 1.2;
    Sound.playSound('hit');
    showHint(`ğŸ’” -${dmg} HP`);
    if (player.hp<=0) respawn();
  }

  let justRespawned = false; // ãƒªã‚¹ãƒãƒ¼ãƒ³ç›´å¾Œã®ãƒ•ãƒ©ã‚°
  
  function respawn() {
    state.coins = Math.max(0, Math.floor(state.coins/2));
    // ä¸­å¤®ãƒãƒƒãƒ—ã«æˆ»ã‚‹
    currentMapX = 0;
    currentMapY = 0;
    player.x=160; player.y=96;
    player.hp=player.maxHp;
    state.hp=player.hp;
    arrows.length = 0; // çŸ¢ã‚’ã‚¯ãƒªã‚¢
    shurikens.length = 0; // æ‰‹è£å‰£ã‚’ã‚¯ãƒªã‚¢
    spears.length = 0; // é•·æ§ã‚’ã‚¯ãƒªã‚¢
    rockets.length = 0; // ãƒ­ã‚±ãƒƒãƒˆã‚’ã‚¯ãƒªã‚¢
    fragments.length = 0; // ç ´ç‰‡ã‚’ã‚¯ãƒªã‚¢
    bombs.length = 0; // çˆ†å¼¾ã‚’ã‚¯ãƒªã‚¢
    blasts.length = 0; // çˆ†ç™ºã‚’ã‚¯ãƒªã‚¢
    hideSpeechBubble();
    justRespawned = true; // ãƒªã‚¹ãƒãƒ¼ãƒ³ç›´å¾Œãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
    showHint('ğŸ  æ‘ã«æˆ»ã‚Šã¾ã—ãŸ');
    Sound.playSound('talk');
  }

  function hasLineOfSight(x0,y0,x1,y1) {
    const steps = 40;
    for(let i=1;i<steps;i++) {
      const t=i/steps;
      const x=x0+(x1-x0)*t, y=y0+(y1-y0)*t;
      const tx=Math.floor(x/TS), ty=Math.floor(y/TS);
      const tile = getTile(tx, ty);
      if (isBlock(tile)) return false;
    }
    return true;
  }

  // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼æç”»
  function drawCharacter(x, y, type, entity = null) {
    ctx.save();
    
    switch(type) {
      case 'player':
        if (entity && entity.inv > 0) {
          ctx.globalAlpha = 0.6 + 0.4 * Math.sin(performance.now() * 0.02);
        }
        
        // ä½“ï¼ˆé’ã„æœï¼‰
        ctx.fillStyle = '#4a90e2';
        ctx.fillRect(x-6, y-8, 12, 16);
        
        // é ­ï¼ˆè‚Œè‰²ï¼‰
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-5, y-12, 10, 8);
        
        // é«ªï¼ˆèŒ¶è‰²ï¼‰
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(x-6, y-14, 12, 4);
        
        // ç›®
        ctx.fillStyle = '#000';
        ctx.fillRect(x-3, y-10, 2, 1);
        ctx.fillRect(x+1, y-10, 2, 1);
        
        // è…•
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-8, y-6, 3, 8);
        ctx.fillRect(x+5, y-6, 3, 8);
        
        // è¶³ï¼ˆé´ï¼‰
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(x-6, y+6, 5, 4);
        ctx.fillRect(x+1, y+6, 5, 4);
        break;
        
      case 'slime':
        const bounce = entity ? Math.sin(entity.bounceT) * 1 : 0;
        ctx.fillStyle = '#6cf07a';
        ctx.beginPath();
        ctx.ellipse(x, y + bounce, 8, 6 - bounce * 0.5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
        ctx.fillStyle = '#a8ffa8';
        ctx.beginPath();
        ctx.ellipse(x - 2, y - 1 + bounce, 3, 2, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // ç›®
        ctx.fillStyle = '#000';
        ctx.fillRect(x-3, y-1, 2, 2);
        ctx.fillRect(x+1, y-1, 2, 2);
        break;
        
      case 'archer':
        const alert = entity && entity.alertT > 0;
        if (alert) {
          ctx.globalAlpha = 0.8 + 0.2 * Math.sin(performance.now() * 0.01);
        }
        
        // ä½“
        ctx.fillStyle = alert ? '#ff6b6b' : '#b7a1f0';
        ctx.fillRect(x-5, y-6, 10, 12);
        
        // é ­
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-4, y-10, 8, 6);
        
        // ãƒ•ãƒ¼ãƒ‰
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x-5, y-12, 10, 4);
        
        // å¼“
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x + 6, y, 8, -Math.PI/3, Math.PI/3);
        ctx.stroke();
        
        // ç›®
        ctx.fillStyle = alert ? '#ff0000' : '#000';
        ctx.fillRect(x-2, y-8, 1, 1);
        ctx.fillRect(x+1, y-8, 1, 1);
        break;
        
      case 'npc':
        // è€äººé¢¨NPC
        ctx.fillStyle = '#6b4423';
        ctx.fillRect(x-6, y-8, 12, 16);
        
        // é ­
        ctx.fillStyle = '#fdbcb4';
        ctx.fillRect(x-4, y-10, 8, 6);
        
        // å¸½å­ï¼ˆã¤ã°åºƒå¸½å­é¢¨ï¼‰
        ctx.fillStyle = '#4a4a4a';
        ctx.fillRect(x-6, y-14, 12, 3);
        ctx.fillRect(x-5, y-11, 10, 2);
        
        // é•·ã„ã²ã’
        ctx.fillStyle = '#ddd';
        ctx.fillRect(x-4, y-6, 8, 4);
        ctx.fillRect(x-3, y-4, 6, 2);
        
        // æ–
        ctx.strokeStyle = '#8b4513';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + 8, y + 8);
        ctx.lineTo(x + 8, y - 10);
        ctx.stroke();
        
        // æ–ã®å…ˆï¼ˆä¸¸ã„è£…é£¾ï¼‰
        ctx.fillStyle = '#8b4513';
        ctx.beginPath();
        ctx.arc(x + 8, y - 10, 2, 0, Math.PI * 2);
        ctx.fill();
        break;
        
      case 'cactus':
        const spike = entity ? Math.sin(entity.spikeT) * 0.5 : 0;
        // ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼
        ctx.fillStyle = '#4a7c59';
        ctx.fillRect(x-6, y-8, 12, 16);
        // ãƒˆã‚²
        ctx.fillStyle = '#1a3d2e';
        for(let i = 0; i < 4; i++) {
          const tx = x - 4 + i * 3;
          ctx.fillRect(tx, y - 6 + spike, 1, 2);
          ctx.fillRect(tx, y + 4 + spike, 1, 2);
        }
        // ç›®
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(x-3, y-4, 2, 2);
        ctx.fillRect(x+1, y-4, 2, 2);
        break;
        
      case 'snowwolf':
        const howl = entity ? Math.sin(entity.howlT) * 1 : 0;
        // é›ªã‚ªã‚ªã‚«ãƒŸ
        ctx.fillStyle = '#e0e0e0';
        ctx.fillRect(x-7, y-7, 14, 14);
        // è€³
        ctx.fillStyle = '#c0c0c0';
        ctx.fillRect(x-6, y-9, 4, 4);
        ctx.fillRect(x+2, y-9, 4, 4);
        // ç›®
        ctx.fillStyle = '#0000ff';
        ctx.fillRect(x-3, y-4, 2, 2);
        ctx.fillRect(x+1, y-4, 2, 2);
        // å£
        ctx.fillStyle = '#000';
        ctx.fillRect(x-2, y+2 + howl, 4, 2);
        break;
        
      case 'scorpion':
        const sting = entity ? Math.sin(entity.stingT) * 1.5 : 0;
        // ã‚µã‚½ãƒª
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(x-5, y-5, 10, 8);
        // é ­
        ctx.fillRect(x-4, y-7, 8, 4);
        // å°¾
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x+5, y+3);
        ctx.lineTo(x+8, y-2 + sting);
        ctx.stroke();
        // ç›®
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(x-2, y-6, 1, 1);
        ctx.fillRect(x+1, y-6, 1, 1);
        // è„š
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        for(let i = 0; i < 4; i++) {
          const lx = x - 4 + i * 2.5;
          ctx.beginPath();
          ctx.moveTo(lx, y+3);
          ctx.lineTo(lx - 2, y+6);
          ctx.stroke();
        }
        break;
        
      case 'kraken':
        const tentacle = entity ? Math.sin(entity.tentacleT) * 2 : 0;
        // ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³
        ctx.fillStyle = '#2c3e50';
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        ctx.fill();
        // ç›®
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(x-4, y-3, 3, 3);
        ctx.fillRect(x+1, y-3, 3, 3);
        // è§¦æ‰‹
        ctx.strokeStyle = '#1a1a2e';
        ctx.lineWidth = 2;
        for(let i = 0; i < 4; i++) {
          const ang = (i / 4) * Math.PI * 2;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(ang) * (8 + tentacle), y + Math.sin(ang) * (8 + tentacle));
          ctx.stroke();
        }
        break;
        
      case 'firespirit':
        const flame = entity ? Math.sin(entity.flameT) * 1.5 : 0;
        // ç‚ã®ç²¾éœŠ
        ctx.fillStyle = '#ff4500';
        ctx.beginPath();
        ctx.arc(x, y + flame, 7, 0, Math.PI * 2);
        ctx.fill();
        // ç‚ã®å¤–å´
        ctx.fillStyle = '#ffaa00';
        ctx.beginPath();
        ctx.arc(x - 2, y - 2 + flame, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(x + 2, y - 1 + flame, 4, 0, Math.PI * 2);
        ctx.fill();
        // ç›®
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(x-2, y-1 + flame, 1, 1);
        ctx.fillRect(x+1, y-1 + flame, 1, 1);
        break;
    }
    
    ctx.restore();
  }

  // æç”»
  function draw() {
    ctx.clearRect(0,0,W,H);

    // ã‚¿ã‚¤ãƒ«
    const map = getCurrentMap();
    for(let y=0;y<ROWS;y++) {
      for(let x=0;x<COLS;x++){
        const t = map[y][x];
        const px = x*TS, py=y*TS;
        
        switch(t){
          case T.GRASS: 
            ctx.fillStyle='#2d5016'; 
            ctx.fillRect(px,py,TS,TS);
            // è‰ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£
            ctx.fillStyle='#3a6b1f';
            for(let i=0;i<3;i++) {
              const gx = px + (i*5) + 2;
              const gy = py + 8 + (i%2)*3;
              ctx.fillRect(gx, gy, 1, 4);
            }
            break;
            
          case T.PATH: 
            ctx.fillStyle='#8b7355'; 
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#756347';
            ctx.fillRect(px+2, py+2, 5, 5);
            ctx.fillRect(px+9, py+9, 5, 5);
            break;
            
          case T.TREE: 
            ctx.fillStyle='#2d5016';
            ctx.fillRect(px,py,TS,TS);
            // å¹¹
            ctx.fillStyle='#8b4513';
            ctx.fillRect(px+6, py+8, 4, 8);
            // è‘‰
            ctx.fillStyle='#228b22';
            ctx.fillRect(px+2, py+2, 12, 10);
            ctx.fillStyle='#32cd32';
            ctx.fillRect(px+4, py+4, 8, 6);
            break;
            
          case T.WATER: 
            ctx.fillStyle='#1e3a8a'; 
            ctx.fillRect(px,py,TS,TS);
            const waveTime = performance.now() * 0.005;
            const wave = Math.sin(waveTime + x + y) * 0.3;
            ctx.fillStyle=`rgba(100,149,237,${0.3 + wave})`;
            ctx.fillRect(px,py,TS,TS*0.5);
            break;
            
          case T.FLOWER:
            ctx.fillStyle='#2d5016'; 
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#ff69b4';
            ctx.fillRect(px+6, py+6, 4, 4);
            ctx.fillStyle='#ffd700';
            ctx.fillRect(px+7, py+7, 2, 2);
            break;
            
          case T.ROCK:
            ctx.fillStyle='#2d5016';
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#555';
            ctx.fillRect(px+2, py+2, 12, 12);
            ctx.fillStyle='#666';
            ctx.fillRect(px+4, py+4, 8, 8);
            ctx.fillStyle='#444';
            ctx.fillRect(px+6, py+6, 4, 4);
            break;
            
          case T.SAND:
            ctx.fillStyle='#d4a574';
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#c9a068';
            ctx.fillRect(px+2, py+2, 5, 5);
            ctx.fillRect(px+9, py+9, 5, 5);
            break;
            
          case T.CACTUS:
            ctx.fillStyle='#2d5016';
            ctx.fillRect(px,py,TS,TS);
            // ã‚µãƒœãƒ†ãƒ³ã®æœ¬ä½“
            ctx.fillStyle='#4a7c59';
            ctx.fillRect(px+6, py+2, 4, 12);
            // ã‚µãƒœãƒ†ãƒ³ã®è…•
            ctx.fillRect(px+2, py+6, 3, 4);
            ctx.fillRect(px+11, py+8, 3, 4);
            // ãƒˆã‚²
            ctx.fillStyle='#1a3d2e';
            ctx.fillRect(px+6, py+4, 1, 1);
            ctx.fillRect(px+9, py+6, 1, 1);
            ctx.fillRect(px+7, py+9, 1, 1);
            break;
            
          case T.SNOW:
            ctx.fillStyle='#e8f4f8';
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#d0e8f0';
            ctx.fillRect(px+2, py+2, 5, 5);
            ctx.fillRect(px+9, py+9, 5, 5);
            // é›ªã®çµæ™¶
            ctx.fillStyle='#ffffff';
            ctx.fillRect(px+7, py+3, 1, 1);
            ctx.fillRect(px+6, py+7, 1, 1);
            ctx.fillRect(px+8, py+7, 1, 1);
            break;
            
          case T.DESERT:
            ctx.fillStyle='#d2b48c';
            ctx.fillRect(px,py,TS,TS);
            ctx.fillStyle='#c19a6b';
            ctx.fillRect(px+2, py+2, 5, 5);
            ctx.fillRect(px+9, py+9, 5, 5);
            // ç ‚ã®æ³¢ç´‹
            ctx.fillStyle='#b8860b';
            for(let i = 0; i < 3; i++) {
              const wx = px + (i * 5);
              ctx.fillRect(wx, py + 8, 3, 1);
            }
            break;
            
          case T.ICE:
            ctx.fillStyle='#1e3a8a';
            ctx.fillRect(px,py,TS,TS);
            const iceTime = performance.now() * 0.003;
            const iceWave = Math.sin(iceTime + x + y) * 0.2;
            ctx.fillStyle=`rgba(173,216,230,${0.4 + iceWave})`;
            ctx.fillRect(px,py,TS,TS);
            // æ°·ã®ã²ã³
            ctx.strokeStyle='rgba(255,255,255,0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(px+2, py+2);
            ctx.lineTo(px+6, py+8);
            ctx.moveTo(px+10, py+4);
            ctx.lineTo(px+14, py+12);
            ctx.stroke();
            break;
        }
      }
    }

    // ç¾åœ¨ã®ãƒãƒƒãƒ—ã®ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã‚’å–å¾—
    const entities = getMapEntities();
    
    // NPC
    for (const n of entities.npcs){
      drawCharacter(n.x, n.y, 'npc');
      if (!n.talked) {
        ctx.fillStyle = '#ffff00';
        ctx.fillRect(n.x-1, n.y-20, 2, 6);
        ctx.fillRect(n.x-1, n.y-12, 2, 2);
      }
    }
    
    // å®ç®±
    for (const c of entities.chests){ 
      // ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åˆ¤å®šï¼ˆå››éš…ã®åº§æ¨™ï¼‰
      const isBossField = (currentMapX === 3 && currentMapY === -3) || // åŒ—æ±ï¼ˆé’é¾ï¼‰
                          (currentMapX === -3 && currentMapY === -3) || // åŒ—è¥¿ï¼ˆç„æ­¦ï¼‰
                          (currentMapX === -3 && currentMapY === 3) ||  // å—è¥¿ï¼ˆéº’éºŸï¼‰
                          (currentMapX === 3 && currentMapY === 3);     // å—æ±ï¼ˆæœ±é›€ï¼‰
      // ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å®ç®±ã¯èµ¤è‰²
      const chestColor = isBossField 
        ? (c.opened ? '#8e6b3f' : '#ff0000')
        : (c.opened ? '#8e6b3f' : '#d4af37');
      ctx.fillStyle = chestColor;
      ctx.fillRect(c.x-8,c.y-6,16,12);
      
      if (!c.opened) {
        // ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å®ç®±ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚‚èµ¤ç³»ã«
        const highlightColor = isBossField ? '#ff4444' : '#ffd700';
        ctx.fillStyle = highlightColor;
        ctx.fillRect(c.x-6, c.y-4, 12, 2);
        ctx.fillRect(c.x-2, c.y-2, 4, 4);
        const sparkleTime = performance.now() * 0.01;
        const sparkle = Math.sin(sparkleTime) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255,255,255,${sparkle})`;
        ctx.fillRect(c.x-10, c.y-8, 2, 2);
        ctx.fillRect(c.x+8, c.y-8, 2, 2);
        ctx.fillRect(c.x, c.y-10, 2, 2);
        
        // æ­¦å™¨ãŒå…¥ã£ã¦ã„ã‚‹å ´åˆã¯ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤º
        if (c.weapon) {
          const weapon = WEAPONS[c.weapon.toUpperCase()];
          if (weapon) {
            ctx.fillStyle = weapon.color;
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(weapon.icon, c.x, c.y - 16);
          }
        }
      }
    }

    // çˆ†å¼¾ï¼ˆç¾åœ¨ã®ãƒãƒƒãƒ—ã®çˆ†å¼¾ã®ã¿æç”»ï¼‰
    for (const b of bombs){ 
      if (b.mapX !== currentMapX || b.mapY !== currentMapY) continue; // ç¾åœ¨ã®ãƒãƒƒãƒ—ã®çˆ†å¼¾ã®ã¿
      const pulseTime = performance.now() * 0.01;
      const bombColor = b.t < 0.3 ? '#ff0000' : '#333';
      ctx.fillStyle = bombColor;
      ctx.fillRect(b.x-4, b.y-4, 8, 8);
      
      ctx.fillStyle = '#ff4500';
      ctx.fillRect(b.x-1, b.y-8, 2, 4);
      
      if (b.t < 0.3) {
        const pulse = Math.sin(pulseTime * 10) * 0.5 + 0.5;
        ctx.fillStyle = `rgba(255,255,255,${pulse})`;
        ctx.fillRect(b.x-5, b.y-5, 10, 10);
      }
    }
    
    // çˆ†ç™º
    for (const ex of blasts){ 
      const intensity = ex.t / 0.4;
      ctx.save();
      ctx.globalAlpha = intensity;
      
      ctx.fillStyle='#ffaa00';
      ctx.fillRect(ex.x-TS*2, ex.y-4, TS*4, 8);
      ctx.fillRect(ex.x-4, ex.y-TS*2, 8, TS*4);
      
      ctx.fillStyle='#ff6600';
      ctx.fillRect(ex.x-TS, ex.y-2, TS*2, 4);
      ctx.fillRect(ex.x-2, ex.y-TS, 4, TS*2);
      
      ctx.fillStyle='#ffffff';
      ctx.fillRect(ex.x-8, ex.y-1, 16, 2);
      ctx.fillRect(ex.x-1, ex.y-8, 2, 16);
      
      ctx.restore();
    }

    // çŸ¢
    for (const ar of arrows){ 
      ctx.save();
      const angle = Math.atan2(ar.vy, ar.vx);
      ctx.translate(ar.x, ar.y);
      ctx.rotate(angle);
      
      ctx.fillStyle='#8b4513';
      ctx.fillRect(-6, -1, 8, 2);
      ctx.fillStyle='#ddd';
      ctx.fillRect(2, -2, 4, 4);
      
      ctx.restore();
    }

    // æ‰‹è£å‰£ï¼ˆãã‚‹ãã‚‹å›è»¢ã€æ‰‹è£å‰£ã®ãƒ‡ã‚¶ã‚¤ãƒ³ï¼‰
    for (const s of shurikens) {
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.rot); // é«˜é€Ÿå›è»¢
      
      // å…‰ã‚‹åŠ¹æœ
      const glowTime = performance.now() * 0.02;
      const glow = Math.sin(glowTime) * 0.3 + 0.7;
      
      // å¤–å´ã®å…‰
      ctx.shadowBlur = 8;
      ctx.shadowColor = '#ffd700';
      
      // æ‰‹è£å‰£ã®ãƒ‡ã‚¶ã‚¤ãƒ³ï¼ˆ4ã¤ã®åˆƒã‚’æŒã¤æ˜Ÿå‹ï¼‰
      ctx.fillStyle = `rgba(200, 200, 200, ${glow})`; // éŠ€è‰²
      ctx.strokeStyle = '#ffd700'; // é‡‘è‰²ã®ç¸å–ã‚Š
      ctx.lineWidth = 1.5;
      
      // æ‰‹è£å‰£ã®å½¢çŠ¶ï¼ˆ4æ–¹å‘ã®åˆƒï¼‰
      const bladeLength = 6;
      const bladeWidth = 2;
      const centerHole = 1.5;
      
      ctx.beginPath();
      // 4ã¤ã®åˆƒã‚’æç”»
      for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI) / 2;
        const x1 = Math.cos(angle) * bladeLength;
        const y1 = Math.sin(angle) * bladeLength;
        const x2 = Math.cos(angle + Math.PI / 4) * bladeWidth;
        const y2 = Math.sin(angle + Math.PI / 4) * bladeWidth;
        const x3 = Math.cos(angle - Math.PI / 4) * bladeWidth;
        const y3 = Math.sin(angle - Math.PI / 4) * bladeWidth;
        
        if (i === 0) {
          ctx.moveTo(x1, y1);
        } else {
          ctx.lineTo(x1, y1);
        }
        ctx.lineTo(x2, y2);
        ctx.lineTo(0, 0);
        ctx.lineTo(x3, y3);
        ctx.lineTo(x1, y1);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // ä¸­å¿ƒã®ç©´
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(0, 0, centerHole, 0, Math.PI * 2);
      ctx.fill();
      
      // ä¸­å¿ƒã®å…‰
      ctx.shadowBlur = 4;
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.arc(0, 0, 0.8, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }

    // é•·æ§
    for (const sp of spears) {
      ctx.save();
      const angle = Math.atan2(sp.vy, sp.vx);
      ctx.translate(sp.x, sp.y);
      ctx.rotate(angle);
      
      // å…‰ã‚‹åŠ¹æœ
      const glowTime = performance.now() * 0.015;
      const glow = Math.sin(glowTime) * 0.2 + 0.8;
      
      // æ§ã®æŸ„ï¼ˆé•·ãï¼‰
      ctx.fillStyle = '#8b4513';
      ctx.fillRect(-4, -1, 28, 2);
      
      // æ§ã®å…ˆï¼ˆå°–ã£ãŸè¡¨ç¾ã€é•·ãï¼‰
      ctx.shadowBlur = 6;
      ctx.shadowColor = '#4a90e2';
      ctx.fillStyle = `rgba(74, 144, 226, ${glow})`;
      // å…ˆç«¯ã‚’ã‚ˆã‚Šå°–ã‚‰ã›ã‚‹
      ctx.beginPath();
      ctx.moveTo(24, 0);
      ctx.lineTo(30, -3);
      ctx.lineTo(30, 3);
      ctx.closePath();
      ctx.fill();
      
      // å…ˆç«¯ã®ã•ã‚‰ã«å°–ã£ãŸéƒ¨åˆ†
      ctx.fillStyle = '#ffffff';
      ctx.beginPath();
      ctx.moveTo(28, 0);
      ctx.lineTo(30, -1.5);
      ctx.lineTo(30, 1.5);
      ctx.closePath();
      ctx.fill();
      
      // æ§ã®è£…é£¾ï¼ˆå…‰ã‚‹ï¼‰
      ctx.shadowBlur = 4;
      ctx.shadowColor = '#ffd700';
      ctx.fillStyle = `rgba(255, 215, 0, ${glow})`;
      ctx.fillRect(-4, -2, 2, 4);
      
      // è»Œè·¡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      ctx.globalAlpha = 0.3;
      ctx.fillStyle = '#4a90e2';
      ctx.fillRect(-4, -1, 20, 2);
      ctx.globalAlpha = 1.0;
      
      ctx.restore();
    }

    // ãƒã‚ºãƒ¼ã‚«ã®ãƒ­ã‚±ãƒƒãƒˆ
    for (const r of rockets) {
      ctx.save();
      const angle = Math.atan2(r.vy, r.vx);
      ctx.translate(r.x, r.y);
      ctx.rotate(angle);
      
      // ç‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆå¾Œã‚ã‹ã‚‰ï¼‰
      const flameTime = performance.now() * 0.05;
      const flameSize = Math.sin(flameTime) * 2 + 4;
      ctx.fillStyle = '#ff6600';
      ctx.beginPath();
      ctx.arc(-6, 0, flameSize, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffaa00';
      ctx.beginPath();
      ctx.arc(-6, 0, flameSize * 0.6, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#ffff00';
      ctx.beginPath();
      ctx.arc(-6, 0, flameSize * 0.3, 0, Math.PI * 2);
      ctx.fill();
      
      // ãƒ­ã‚±ãƒƒãƒˆæœ¬ä½“ï¼ˆå…‰ã‚‹ï¼‰
      const glowTime = performance.now() * 0.02;
      const glow = Math.sin(glowTime) * 0.3 + 0.7;
      ctx.shadowBlur = 8;
      ctx.shadowColor = '#ff4500';
      ctx.fillStyle = `rgba(255, 69, 0, ${glow})`;
      ctx.fillRect(-3, -4, 8, 8);
      
      // ãƒ­ã‚±ãƒƒãƒˆã®å…ˆç«¯ï¼ˆå…‰ã‚‹ï¼‰
      ctx.shadowBlur = 6;
      ctx.shadowColor = '#ff6600';
      ctx.fillStyle = `rgba(255, 102, 0, ${glow})`;
      ctx.beginPath();
      ctx.moveTo(5, 0);
      ctx.lineTo(8, -3);
      ctx.lineTo(8, 3);
      ctx.closePath();
      ctx.fill();
      
      // å°¾ç¿¼
      ctx.shadowBlur = 0;
      ctx.fillStyle = '#cc3300';
      ctx.fillRect(-3, -6, 2, 2);
      ctx.fillRect(-3, 4, 2, 2);
      
      // ç‚
      ctx.fillStyle = '#ffaa00';
      ctx.fillRect(-6, -2, 3, 4);
      ctx.fillStyle = '#ffff00';
      ctx.fillRect(-7, -1, 2, 2);
      
      ctx.restore();
    }

    // æ•µ
    for (const s of entities.slimes){ 
      if (s.dead) continue; 
      drawCharacter(s.x, s.y, 'slime', s);
    }
    for (const a of entities.archers){ 
      if (a.dead) continue; 
      drawCharacter(a.x, a.y, 'archer', a);
    }
    for (const c of entities.cacti){ 
      if (c.dead) continue; 
      drawCharacter(c.x, c.y, 'cactus', c);
    }
    for (const w of entities.snowwolves){ 
      if (w.dead) continue; 
      drawCharacter(w.x, w.y, 'snowwolf', w);
    }
    for (const sc of entities.scorpions){ 
      if (sc.dead) continue; 
      drawCharacter(sc.x, sc.y, 'scorpion', sc);
    }
    for (const k of entities.krakens){ 
      if (k.dead) continue; 
      drawCharacter(k.x, k.y, 'kraken', k);
    }
    for (const f of entities.firespirits){ 
      if (f.dead) continue; 
      drawCharacter(f.x, f.y, 'firespirit', f);
    }

    // ãƒœã‚¹
    for (const boss of entities.bosses) {
      if (boss.dead) continue;
      
      ctx.save();
      ctx.translate(boss.x, boss.y);
      
      // ãƒœã‚¹ã®æç”»ï¼ˆ4å€ã®å¤§ãã•ï¼‰
      const size = 24;
      ctx.fillStyle = boss.color;
      
      // ãƒœã‚¹ã‚¿ã‚¤ãƒ—ã”ã¨ã®æç”»
      switch(boss.type) {
        case 'suzaku': // æœ±é›€ï¼ˆé³¥ï¼‰
          ctx.fillStyle = '#ff0000';
          ctx.fillRect(-size, -size, size*2, size*2);
          // ç¿¼
          ctx.fillStyle = '#ff6600';
          ctx.fillRect(-size*1.5, -size*0.5, size, size);
          ctx.fillRect(size*0.5, -size*0.5, size, size);
          // é ­
          ctx.fillStyle = '#ffaa00';
          ctx.fillRect(-size*0.3, -size*1.2, size*0.6, size*0.6);
          break;
        case 'genbu': // ç„æ­¦ï¼ˆäº€ï¼‰
          ctx.fillStyle = '#000080';
          ctx.fillRect(-size, -size, size*2, size*2);
          // ç”²ç¾…
          ctx.fillStyle = '#004080';
          ctx.fillRect(-size*0.7, -size*0.7, size*1.4, size*1.4);
          // é ­
          ctx.fillStyle = '#000040';
          ctx.fillRect(-size*0.5, -size*1.3, size, size*0.6);
          break;
        case 'seiryu': // é’é¾ï¼ˆé¾ï¼‰
          ctx.fillStyle = '#00ffff';
          ctx.fillRect(-size, -size, size*2, size*2);
          // ä½“ã®ã†ã­ã‚Š
          ctx.fillStyle = '#0088ff';
          for (let i = 0; i < 3; i++) {
            ctx.fillRect(-size + i*size*0.7, -size*0.3, size*0.5, size*0.6);
          }
          // é ­
          ctx.fillStyle = '#00aaff';
          ctx.fillRect(-size*0.5, -size*1.2, size, size*0.8);
          break;
        case 'kirin': // éº’éºŸï¼ˆé¹¿ï¼‰
          ctx.fillStyle = '#ffd700';
          ctx.fillRect(-size, -size, size*2, size*2);
          // è§’
          ctx.fillStyle = '#ffaa00';
          ctx.fillRect(-size*0.3, -size*1.3, size*0.2, size*0.4);
          ctx.fillRect(size*0.1, -size*1.3, size*0.2, size*0.4);
          // ä½“ã®æ¨¡æ§˜
          ctx.fillStyle = '#ffaa00';
          ctx.fillRect(-size*0.3, -size*0.3, size*0.6, size*0.6);
          break;
      }
      
      ctx.restore();
      
      // ä½“åŠ›ãƒãƒ¼
      const barWidth = boss.w;
      const barHeight = 4;
      const barX = boss.x - barWidth / 2;
      const barY = boss.y + boss.h / 2 + 8;
      
      // èƒŒæ™¯
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      // ä½“åŠ›
      const hpRatio = boss.hp / boss.maxHp;
      ctx.fillStyle = hpRatio > 0.5 ? '#00ff00' : hpRatio > 0.25 ? '#ffff00' : '#ff0000';
      ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
      
      // æ 
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      
      // ãƒœã‚¹ã®å¼¾
      for (const bullet of boss.bullets) {
        ctx.fillStyle = bullet.color;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // æ‘é•·ãƒœã‚¹
    if (entities.chiefBoss && !entities.chiefBoss.dead) {
      // å¤‰å½¢ä¸­ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      if (entities.chiefBoss.isTransforming) {
        const progress = entities.chiefBoss.transformTime / 1.0;
        const glowIntensity = Math.sin(progress * Math.PI * 4) * 0.5 + 0.5;
        
        // å…‰ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
        ctx.save();
        ctx.globalAlpha = glowIntensity * 0.6;
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(entities.chiefBoss.x, entities.chiefBoss.y, entities.chiefBoss.w * 0.8, 0, Math.PI * 2);
        ctx.fill();
        
        // å¤–å´ã®å…‰
        ctx.globalAlpha = glowIntensity * 0.3;
        ctx.beginPath();
        ctx.arc(entities.chiefBoss.x, entities.chiefBoss.y, entities.chiefBoss.w * 1.2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
      
      ctx.save();
      ctx.translate(entities.chiefBoss.x, entities.chiefBoss.y);
      ctx.scale(entities.chiefBoss.scale, entities.chiefBoss.scale);
      
      // æ‘é•·ã®æç”»ï¼ˆæ´¾æ‰‹ãªè‰²ï¼‰
      if (entities.chiefBoss.phase === 3) {
        // æœ¬æ°—ãƒ¢ãƒ¼ãƒ‰ï¼šåŸè‰²ã®æ´¾æ‰‹ãªè‰²
        const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff'];
        ctx.fillStyle = colors[Math.floor(entities.chiefBoss.animT * 5) % colors.length];
      } else if (entities.chiefBoss.phase === 2) {
        // å·¨å¤§åŒ–ãƒ¢ãƒ¼ãƒ‰ï¼šå°‘ã—æ˜ã‚‹ã„è‰²
        ctx.fillStyle = '#8b5a3c';
      } else {
        ctx.fillStyle = '#6b4423';
      }
      
      const size = 12;
      ctx.fillRect(-size, -size, size*2, size*2);
      
      // é ­
      ctx.fillStyle = '#fdbcb4';
      ctx.fillRect(-size*0.8, -size*1.2, size*1.6, size*0.8);
      
      // å¸½å­
      ctx.fillStyle = '#4a4a4a';
      ctx.fillRect(-size*0.8, -size*1.4, size*1.6, size*0.3);
      
      // ã²ã’
      ctx.fillStyle = '#ddd';
      ctx.fillRect(-size*0.6, -size*0.4, size*1.2, size*0.4);
      
      ctx.restore();
      
      // ä½“åŠ›ãƒãƒ¼
      const barWidth = entities.chiefBoss.w;
      const barHeight = 4;
      const barX = entities.chiefBoss.x - barWidth / 2;
      const barY = entities.chiefBoss.y + entities.chiefBoss.h / 2 + 8;
      
      ctx.fillStyle = '#333';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      const hpRatio = entities.chiefBoss.hp / entities.chiefBoss.maxHp;
      ctx.fillStyle = hpRatio > 0.5 ? '#00ff00' : hpRatio > 0.25 ? '#ffff00' : '#ff0000';
      ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
      
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 1;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      
      // æ‘é•·ã®å¼¾
      for (const bullet of entities.chiefBoss.bullets) {
        ctx.fillStyle = bullet.color;
        ctx.beginPath();
        ctx.arc(bullet.x, bullet.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
    drawCharacter(player.x, player.y, 'player', player);
    
    // æ­¦å™¨ä½¿ç”¨ä¸­ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆç¡¬ç›´ä¸­ã®è¦–è¦šåŠ¹æœï¼‰
    if (player.weaponCd > 0) {
      ctx.save();
      ctx.globalAlpha = 0.5;
      
      // æ­¦å™¨ä½¿ç”¨ä¸­ã®å…‰ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      const effectTime = performance.now() * 0.01;
      const pulse = Math.sin(effectTime * 10) * 0.3 + 0.7;
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘¨ã‚Šã«å…‰ã‚‹å††
      ctx.strokeStyle = `rgba(255, 255, 0, ${pulse})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(player.x, player.y, 12, 0, Math.PI * 2);
      ctx.stroke();
      
      // å†…å´ã®å…‰
      ctx.strokeStyle = `rgba(255, 200, 0, ${pulse * 0.5})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(player.x, player.y, 10, 0, Math.PI * 2);
      ctx.stroke();
      
      // æ­¦å™¨ã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤º
      const weapon = WEAPONS[state.currentWeapon.toUpperCase()];
      if (weapon) {
        ctx.fillStyle = weapon.color;
        ctx.font = '16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(weapon.icon, player.x, player.y - 20);
      }
      
      ctx.restore();
    }

    // å‰£/æ§
    if (player.swordT > 0){
      const alpha = clamp(player.swordT / 0.18, 0, 1);
      ctx.save();
      ctx.globalAlpha = alpha;
      
      const dx = player.sdx, dy = player.sdy;
      const isSpear = state.currentWeapon === 'spear';
      const baseLength = 16;
      const weaponLength = isSpear ? baseLength * 2 : baseLength; // æ§ã¯2å€ã®é•·ã•
      const weaponWidth = isSpear ? 3 : 4;
      
      ctx.translate(player.x, player.y);
      ctx.rotate(Math.atan2(dy, dx));
      
      if (isSpear) {
        // æ§ã®æç”»
        // æ§ã®æŸ„
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(4, -1, weaponLength * 0.7, 2);
        
        // æ§ã®å…ˆï¼ˆå°–ã£ãŸè¡¨ç¾ã€é•·ãï¼‰
        const glowTime = performance.now() * 0.015;
        const glow = Math.sin(glowTime) * 0.2 + 0.8;
        ctx.shadowBlur = 6;
        ctx.shadowColor = '#4a90e2';
        ctx.fillStyle = `rgba(74, 144, 226, ${glow})`;
        ctx.beginPath();
        ctx.moveTo(4 + weaponLength * 0.7, 0);
        ctx.lineTo(4 + weaponLength, -3);
        ctx.lineTo(4 + weaponLength, 3);
        ctx.closePath();
        ctx.fill();
        
        // å…ˆç«¯ã®ã•ã‚‰ã«å°–ã£ãŸéƒ¨åˆ†
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.moveTo(4 + weaponLength * 0.85, 0);
        ctx.lineTo(4 + weaponLength, -1.5);
        ctx.lineTo(4 + weaponLength, 1.5);
        ctx.closePath();
        ctx.fill();
      } else {
        // å‰£ã®æç”»
        // å‰£èº«
        ctx.fillStyle = '#e8e8e8';
        ctx.fillRect(8, -weaponWidth/2, weaponLength, weaponWidth);
        
        // å‰£å…ˆ
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(8 + weaponLength - 2, -1, 2, 2);
        
        // æŸ„
        ctx.fillStyle = '#8b4513';
        ctx.fillRect(4, -2, 6, 4);
        
        // ãƒ„ãƒ
        ctx.fillStyle = '#666';
        ctx.fillRect(8, -3, 2, 6);
      }
      
      ctx.restore();
    }
    
    // ãƒã‚ºãƒ¼ã‚«ã®ç ´ç‰‡
    if (typeof fragments !== 'undefined') {
      for (const frag of fragments) {
        ctx.save();
        ctx.fillStyle = '#ff6600';
        ctx.beginPath();
        ctx.arc(frag.x, frag.y, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }
    
    // ãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’æç”»
    drawMinimap();
  }

  // æ›´æ–°
  function update(dt) {
    // æ­¦å™¨ä½¿ç”¨ä¸­ã®ç¡¬ç›´æ™‚é–“ã‚’æ›´æ–°
    if (player.weaponCd > 0) {
      player.weaponCd -= dt;
    }
    
    // å…¥åŠ›ï¼ˆæ­¦å™¨ä½¿ç”¨ä¸­ã¯ç§»å‹•ã§ããªã„ï¼‰
    // æ¨ªç”»é¢æ™‚ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è€ƒæ…®ã—ã¦ç§»å‹•é€Ÿåº¦ã‚’èª¿æ•´
    const isLandscape = window.matchMedia('(orientation: landscape)').matches;
    let landscapeScale = 1;
    if (isLandscape) {
      const scaleValue = getComputedStyle(document.documentElement).getPropertyValue('--landscape-scale').trim();
      landscapeScale = scaleValue ? parseFloat(scaleValue) : 1;
      // ã‚¹ã‚±ãƒ¼ãƒ«ãŒæœªè¨­å®šï¼ˆé«˜ã•600pxè¶…ï¼‰ã®å ´åˆã¯1.0
      if (isNaN(landscapeScale) || landscapeScale === 0) landscapeScale = 1;
    }
    let speed = player.speed / landscapeScale; // ã‚¹ã‚±ãƒ¼ãƒ«ãŒå°ã•ã„ã»ã©é€Ÿåº¦ã‚’ä¸Šã’ã‚‹
    // æºå¸¯ãƒ‡ãƒã‚¤ã‚¹ã®å ´åˆã¯ç§»å‹•é€Ÿåº¦ã‚’1.3å€ã«ã™ã‚‹
    if (isMobile) {
      speed *= 1.3;
    }
    if (player.weaponCd <= 0) {
      player.vx = Input.ax * speed; 
      player.vy = Input.ay * speed;
    } else {
      // ç¡¬ç›´ä¸­ã¯ç§»å‹•ã‚’åœæ­¢
      player.vx = 0;
      player.vy = 0;
    }
    if (Math.abs(Input.ax) > 0.1) player.dir = Math.sign(Input.ax);

    // æ”»æ’ƒ
    if (Input.aDown) attack();

    if (player.attackCd>0) player.attackCd-=dt;
    if (player.inv>0) player.inv-=dt;
    if (player.swordT>0) player.swordT-=dt;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç§»å‹•ï¼ˆç”»é¢ç«¯é€šéã‚’è¨±å¯ï¼‰
    moveWithTile(player, dt, true);

    // ãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆãƒã‚§ãƒƒã‚¯
    if (player.x < 0) {
      // å·¦ç«¯ï¼šå¢ƒç•Œãƒã‚§ãƒƒã‚¯
      if (currentMapX > MIN_MAP_X) {
        markMapVisited(currentMapX, currentMapY); // ç¾åœ¨ã®ãƒãƒƒãƒ—ã‚’è¨ªå•æ¸ˆã¿ã«
        currentMapX--;
        player.x = W - 10;
        arrows.length = 0; // çŸ¢ã‚’ã‚¯ãƒªã‚¢
        shurikens.length = 0; // æ‰‹è£å‰£ã‚’ã‚¯ãƒªã‚¢
        spears.length = 0; // é•·æ§ã‚’ã‚¯ãƒªã‚¢
        rockets.length = 0; // ãƒ­ã‚±ãƒƒãƒˆã‚’ã‚¯ãƒªã‚¢
        fragments.length = 0; // ç ´ç‰‡ã‚’ã‚¯ãƒªã‚¢
        // çˆ†å¼¾ã¯ãƒãƒƒãƒ—ã”ã¨ã«ç®¡ç†ã•ã‚Œã¦ã„ã‚‹ã®ã§ã€ãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆæ™‚ã¯ã‚¯ãƒªã‚¢ã—ãªã„
        blasts.length = 0; // çˆ†ç™ºã‚’ã‚¯ãƒªã‚¢
        hideSpeechBubble();
        markMapVisited(currentMapX, currentMapY); // æ–°ã—ã„ãƒãƒƒãƒ—ã‚’è¨ªå•æ¸ˆã¿ã«
        Sound.playSound('button'); // ãƒãƒƒãƒ—åˆ‡ã‚Šæ›¿ãˆéŸ³
      } else {
        // å¢ƒç•Œã‚’è¶Šãˆã‚‰ã‚Œãªã„
        player.x = 0;
        showHint('é€šã‚Œã¾ã›ã‚“ã€‚', 2.0);
        Sound.playSound('button');
      }
    } else if (player.x > W) {
      // å³ç«¯ï¼šå¢ƒç•Œãƒã‚§ãƒƒã‚¯
      if (currentMapX < MAX_MAP_X) {
        markMapVisited(currentMapX, currentMapY);
        currentMapX++;
        player.x = 10;
        arrows.length = 0;
        hideSpeechBubble();
        markMapVisited(currentMapX, currentMapY);
        Sound.playSound('button');
      } else {
        // å¢ƒç•Œã‚’è¶Šãˆã‚‰ã‚Œãªã„
        player.x = W;
        showHint('é€šã‚Œã¾ã›ã‚“ã€‚', 2.0);
        Sound.playSound('button');
      }
    }
    if (player.y < 0) {
      // ä¸Šç«¯ï¼šå¢ƒç•Œãƒã‚§ãƒƒã‚¯
      if (currentMapY > MIN_MAP_Y) {
        markMapVisited(currentMapX, currentMapY);
        currentMapY--;
        player.y = H - 10;
        arrows.length = 0;
        hideSpeechBubble();
        markMapVisited(currentMapX, currentMapY);
        Sound.playSound('button');
      } else {
        // å¢ƒç•Œã‚’è¶Šãˆã‚‰ã‚Œãªã„ï¼ˆç¢ºå®Ÿã«0ã«æˆ»ã™ï¼‰
        player.y = Math.max(0, player.y);
        if (player.y < 0) {
          player.y = 0;
        }
        showHint('é€šã‚Œã¾ã›ã‚“ã€‚', 2.0);
        Sound.playSound('button');
      }
    } else if (player.y > H) {
      // ä¸‹ç«¯ï¼šå¢ƒç•Œãƒã‚§ãƒƒã‚¯
      if (currentMapY < MAX_MAP_Y) {
        markMapVisited(currentMapX, currentMapY);
        currentMapY++;
        player.y = 10;
        arrows.length = 0;
        hideSpeechBubble();
        markMapVisited(currentMapX, currentMapY);
        Sound.playSound('button');
      } else {
        // å¢ƒç•Œã‚’è¶Šãˆã‚‰ã‚Œãªã„
        player.y = H;
        showHint('é€šã‚Œã¾ã›ã‚“ã€‚', 2.0);
        Sound.playSound('button');
      }
    }
    
    // ä¸Šç«¯ã®å¢ƒç•Œã‚’ç¢ºå®Ÿã«ãƒã‚§ãƒƒã‚¯ï¼ˆå¿µã®ãŸã‚è¿½åŠ ãƒã‚§ãƒƒã‚¯ï¼‰
    if (currentMapY === MIN_MAP_Y && player.y < 0) {
      player.y = 0;
    }
    
    // ç¾åœ¨ã®ãƒãƒƒãƒ—ã‚’è¨ªå•æ¸ˆã¿ã«ãƒãƒ¼ã‚¯
    markMapVisited(currentMapX, currentMapY);

    // ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
    const entities = getMapEntities();
    let canTalk = false, canOpen = false;
    const near = (o,r) => dist2(player.x,player.y,o.x,o.y) < (r*r);
    
    for (const n of entities.npcs){ 
      if (near(n, 20)) canTalk = true; 
    }
    for (const c of entities.chests){ 
      if (!c.opened && near(c, 20)) canOpen = true; 
    }
    
    // ãƒªã‚¹ãƒãƒ¼ãƒ³ç›´å¾Œã«è€äººãŒè‡ªå‹•çš„ã«æ„šç—´ã‚’è¨€ã†
    if (justRespawned && currentMapX === 0 && currentMapY === 0) {
      const npc = entities.npcs.find(n => near(n, 50)); // å°‘ã—åºƒã‚ã®ç¯„å›²
      if (npc && npc.deathTexts) {
        justRespawned = false;
        Sound.playSound('talk');
        // ãƒ©ãƒ³ãƒ€ãƒ ã«æ„šç—´ã‚’é¸ã¶
        const randomDeathText = npc.deathTexts[Math.floor(Math.random() * npc.deathTexts.length)];
        showSpeechBubble(npc, randomDeathText);
        // é€šå¸¸ã®ä¼šè©±ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¯ãƒªã‚»ãƒƒãƒˆã—ãªã„ï¼ˆåˆ¥ç®¡ç†ï¼‰
      } else {
        justRespawned = false;
      }
    }
    
    if (canTalk) showHint('ğŸ’¬ Zã§è©±ã™'); 
    else if (canOpen) showHint('ğŸ“¦ Zã§é–‹ã‘ã‚‹');
    
    // Zãƒœã‚¿ãƒ³ï¼ˆBï¼‰ã®å‡¦ç†ï¼šå®ç®±ã‚’é–‹ãå‡¦ç†ã‚’å„ªå…ˆã€ãªã‘ã‚Œã°ä¼šè©±
    if (Input.bDown) {
      // ãƒãƒ¼ã‚ºä¸­ã§ãªã„ã“ã¨ã‚’ç¢ºèª
      if (!state.paused && !state.ending) {
        if (canOpen) {
          // å®ç®±ã‚’é–‹ãå‡¦ç†ï¼ˆå„ªå…ˆï¼‰
          const chest = entities.chests.find(c=>!c.opened && near(c,20)); 
          if (chest){ 
            chest.opened = true; 
            
            // ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®åˆ¤å®š
            const isBossField = (currentMapX === 3 && currentMapY === -3) || // åŒ—æ±ï¼ˆé’é¾ï¼‰
                              (currentMapX === -3 && currentMapY === -3) || // åŒ—è¥¿ï¼ˆç„æ­¦ï¼‰
                              (currentMapX === -3 && currentMapY === 3) ||  // å—è¥¿ï¼ˆéº’éºŸï¼‰
                              (currentMapX === 3 && currentMapY === 3);     // å—æ±ï¼ˆæœ±é›€ï¼‰
            
            // æ­¦å™¨ãŒå…¥ã£ã¦ã„ã‚‹å ´åˆ
            if (chest.weapon && !state.weapons.includes(chest.weapon)) {
              state.weapons.push(chest.weapon);
              const weapon = WEAPONS[chest.weapon.toUpperCase()];
              Sound.playSound('level');
              showHint(`ğŸ“¦ ${weapon.icon} ${weapon.name}ã‚’å…¥æ‰‹ï¼`, 3.0);
            } else if (isBossField) {
              // ãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®å®ç®±ï¼šæ‘é•·ã®ç§ç‰©ã‚¢ã‚¤ãƒ†ãƒ ã‚’å…¥æ‰‹
              const bossItems = {
                'suzaku': 'æ‘é•·ã®æ–',      // å—æ±ï¼ˆæœ±é›€ï¼‰
                'genbu': 'æ‘é•·ã®ãƒ¡ã‚¬ãƒ',   // åŒ—è¥¿ï¼ˆç„æ­¦ï¼‰
                'seiryu': 'æ‘é•·ã®è¨¼æ˜æ›¸',  // åŒ—æ±ï¼ˆé’é¾ï¼‰
                'kirin': 'æ‘é•·ã®ãƒãƒ³ã‚«ãƒ'  // å—è¥¿ï¼ˆéº’éºŸï¼‰
              };
              
              // ãƒãƒƒãƒ—åº§æ¨™ã‹ã‚‰ãƒœã‚¹ã‚¿ã‚¤ãƒ—ã‚’åˆ¤å®š
              let bossType = null;
              if (currentMapX === 3 && currentMapY === -3) bossType = 'seiryu';      // åŒ—æ±ï¼ˆé’é¾ï¼‰
              else if (currentMapX === -3 && currentMapY === -3) bossType = 'genbu'; // åŒ—è¥¿ï¼ˆç„æ­¦ï¼‰
              else if (currentMapX === -3 && currentMapY === 3) bossType = 'kirin';  // å—è¥¿ï¼ˆéº’éºŸï¼‰
              else if (currentMapX === 3 && currentMapY === 3) bossType = 'suzaku'; // å—æ±ï¼ˆæœ±é›€ï¼‰
              
            const itemName = bossType ? bossItems[bossType] : null;
            
            // ãƒœã‚¹ã‚’å€’ã—ãŸã‹ãƒã‚§ãƒƒã‚¯
            const bossDefeated = bossType && state.defeatedBosses.includes(bossType);
            
            if (itemName && bossDefeated && !state.bossItems.includes(itemName)) {
              // ãƒœã‚¹ã‚’å€’ã—ãŸå¾Œã«å®ç®±ã‹ã‚‰æ‘é•·ã®ç§ç‰©ã‚¢ã‚¤ãƒ†ãƒ ã‚’å…¥æ‰‹
              state.bossItems.push(itemName);
              Sound.playSound('level');
              showHint(`ğŸ“¦ ã‚¢ã‚¤ãƒ†ãƒ ã‚’æ‰‹ã«å…¥ã‚ŒãŸï¼š${itemName}`, 3.0);
              
              // 4ã¤æƒã£ãŸã‹ãƒã‚§ãƒƒã‚¯
              if (state.bossItems.length === 4) {
                setTimeout(() => {
                  showHint('ğŸ“¢ æ‘é•·ã‹ã‚‰è©±ãŒã‚ã‚‹ã‚ˆã†ã \nè‡³æ€¥æ‘é•·ã®ã¨ã“ã‚ã«æˆ»ã‚‹ã‚ˆã†ã«ï¼', 5.0);
                  Sound.playSound('level');
                }, 1000);
              }
            } else if (itemName && state.bossItems.includes(itemName)) {
              // æ—¢ã«å…¥æ‰‹æ¸ˆã¿
              Sound.playSound('chest'); 
              showHint(`ğŸ“¦ æ‘é•·ã®ç§ç‰©ãŒå…¥ã£ã¦ã„ãŸ...ï¼ˆæ—¢ã«å…¥æ‰‹æ¸ˆã¿ï¼‰`, 3.0);
            } else if (itemName && !bossDefeated) {
              // ãƒœã‚¹ã‚’å€’ã—ã¦ã„ãªã„å ´åˆ
              Sound.playSound('chest'); 
              showHint(`ğŸ“¦ éµãŒã‹ã‹ã£ã¦ã„ã¦é–‹ã‹ãªã„...\nãƒœã‚¹ã‚’å€’ã™å¿…è¦ãŒã‚ã‚Šãã†ã `, 3.0);
            } else {
              // é€šå¸¸ã®å ±é…¬ï¼ˆãƒœã‚¹ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ä»¥å¤–ã®å®ç®±ï¼‰
              const reward = 10 + state.level * 2;
              state.coins += reward; 
              gainExp(3);
              Sound.playSound('chest'); 
              showHint(`ğŸ“¦ å®ç®±ã‹ã‚‰+${reward}ğŸ’°`);
            }
            } else {
              // é€šå¸¸ã®å ±é…¬
              const reward = 10 + state.level * 2;
              state.coins += reward; 
              gainExp(3);
              Sound.playSound('chest'); 
              showHint(`ğŸ“¦ å®ç®±ã‹ã‚‰+${reward}ğŸ’°`);
            }
          }
        } else if (canTalk) {
          // ä¼šè©±å‡¦ç†
          const npc = entities.npcs.find(n => near(n, 20));
          if (npc) {
            Sound.playSound('talk');
            
            // 4ã¤ã®ã‚¢ã‚¤ãƒ†ãƒ ãŒæƒã£ã¦ã„ã‚‹å ´åˆã¯æ‘é•·ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¡¨ç¤ºï¼ˆæ‘ã«ã„ã‚‹æ™‚ã®ã¿ï¼‰
            if (state.bossItems.length === 4 && currentMapX === 0 && currentMapY === 0) {
              showChiefEvent();
              return;
            }
            
            // å¹ãå‡ºã—ã§ä¼šè©±ã‚’è¡¨ç¤º
            if (npc.currentTextIndex < npc.texts.length) {
              showSpeechBubble(npc, npc.texts[npc.currentTextIndex]);
              npc.currentTextIndex++;
              
              // åˆå›ä¼šè©±æ™‚ã®ã¿å ±é…¬
              if (!npc.talked && npc.currentTextIndex >= npc.texts.length) {
                npc.talked = true;
                state.coins += 5;
                gainExp(1);
                showHint('ğŸ‘´ é•·è€ã‹ã‚‰+5ğŸ’°');
              }
            } else {
              // å…¨ã¦ã®ä¼šè©±ãŒçµ‚ã‚ã£ãŸã‚‰æœ€åˆã«æˆ»ã™
              npc.currentTextIndex = 0;
              showSpeechBubble(npc, npc.texts[0]);
            }
          }
        }
      }
    }
    
    // Xãƒœã‚¿ãƒ³ã®å‡¦ç†ï¼šæ­¦å™¨ä½¿ç”¨ã®ã¿
    if (Input.xDown) {
      // ãƒãƒ¼ã‚ºä¸­ã§ãªã„ã“ã¨ã‚’ç¢ºèª
      if (!state.paused && !state.ending) {
        useWeapon();
      }
    }

    // ã‚¹ãƒ©ã‚¤ãƒ 
    for (const s of entities.slimes){ 
      if (s.dead) continue; 
      s.update(dt); 
      moveWithTile(s, dt); 
      if (dist2(s.x,s.y,player.x,player.y) < 15*15) hitPlayer(1); 
    }

    // ã‚¢ãƒ¼ãƒãƒ£ãƒ¼
    for (const a of entities.archers){ 
      if (a.dead) continue; 
      a.update(dt);
      if ((a.cd-=dt)<=0){
        const playerDist = Math.hypot(a.x - player.x, a.y - player.y);
        if (playerDist < a.range) {
          if (Math.abs(a.y-player.y)<12 && hasLineOfSight(a.x,a.y,player.x,player.y)) { 
            const vx = Math.sign(player.x-a.x)*120; 
            arrows.push(new Arrow(a.x, a.y, vx, 0)); 
            a.cd=1.5; 
            a.alertT = 0.5;
            Sound.playSound('button');
          } 
          else if (Math.abs(a.x-player.x)<12 && hasLineOfSight(a.x,a.y,player.x,player.y)) { 
            const vy = Math.sign(player.y-a.y)*120; 
            arrows.push(new Arrow(a.x, a.y, 0, vy)); 
            a.cd=1.5; 
            a.alertT = 0.5;
            Sound.playSound('button');
          } 
          else a.cd=0.4;
        } else {
          a.cd = 0.3;
        }
      } 
    }

    // ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼
    for (const c of entities.cacti){ 
      if (c.dead) continue; 
      c.update(dt); 
      moveWithTile(c, dt); 
      if (dist2(c.x,c.y,player.x,player.y) < 15*15) hitPlayer(1); 
    }

    // é›ªã‚ªã‚ªã‚«ãƒŸ
    for (const w of entities.snowwolves){ 
      if (w.dead) continue; 
      w.update(dt); 
      moveWithTile(w, dt); 
      if (dist2(w.x,w.y,player.x,player.y) < 15*15) hitPlayer(1); 
    }

    // ã‚µã‚½ãƒª
    for (const sc of entities.scorpions){ 
      if (sc.dead) continue; 
      sc.update(dt); 
      moveWithTile(sc, dt); 
      if (dist2(sc.x,sc.y,player.x,player.y) < 15*15) hitPlayer(2); 
    }

    // ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³
    for (const k of entities.krakens){ 
      if (k.dead) continue; 
      k.update(dt);
      if ((k.cd-=dt)<=0){
        const playerDist = Math.hypot(k.x - player.x, k.y - player.y);
        if (playerDist < k.range) {
          if (Math.abs(k.y-player.y)<12 && hasLineOfSight(k.x,k.y,player.x,player.y)) { 
            const vx = Math.sign(player.x-k.x)*100; 
            arrows.push(new Arrow(k.x, k.y, vx, 0)); 
            k.cd=2.0; 
            k.alertT = 0.5;
            Sound.playSound('button');
          } 
          else if (Math.abs(k.x-player.x)<12 && hasLineOfSight(k.x,k.y,player.x,player.y)) { 
            const vy = Math.sign(player.y-k.y)*100; 
            arrows.push(new Arrow(k.x, k.y, 0, vy)); 
            k.cd=2.0; 
            k.alertT = 0.5;
            Sound.playSound('button');
          } 
          else k.cd=0.5;
        } else {
          k.cd = 0.4;
        }
      } 
    }

    // ç‚ã®ç²¾éœŠ
    for (const f of entities.firespirits){ 
      if (f.dead) continue; 
      f.update(dt); 
      moveWithTile(f, dt); 
      if (dist2(f.x,f.y,player.x,player.y) < 15*15) hitPlayer(1); 
    }

    // ãƒœã‚¹
    for (const boss of entities.bosses) {
      if (boss.dead) continue;
      boss.update(dt);
      
      // ãƒœã‚¹ã®å¼¾ã®æ›´æ–°
      for (const bullet of boss.bullets) {
        bullet.x += bullet.vx * dt;
        bullet.y += bullet.vy * dt;
        bullet.life -= dt;
        
        // è¿½å°¾å¼¾ã®å‡¦ç†
        if (bullet.tracking) {
          const dx = player.x - bullet.x;
          const dy = player.y - bullet.y;
          const dist = Math.hypot(dx, dy);
          if (dist > 0) {
            bullet.vx = (dx / dist) * 50;
            bullet.vy = (dy / dist) * 50;
          }
        }
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çª
        if (dist2(bullet.x, bullet.y, player.x, player.y) < 10*10) {
          hitPlayer(2);
          bullet.life = 0;
        }
        
        if (bullet.life <= 0 || collidesTile(bullet.x, bullet.y, 4, 4)) {
          bullet.dead = true;
        }
      }
      
      // ãƒœã‚¹ã®å¼¾ã®å¾Œç‰‡ä»˜ã‘
      for (let i = boss.bullets.length - 1; i >= 0; i--) {
        if (boss.bullets[i].dead || boss.bullets[i].life <= 0) {
          boss.bullets.splice(i, 1);
        }
      }
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ”»æ’ƒåˆ¤å®š
      if (player.swordT > 0) {
        const range = 30;
        const w = 20, h = 20;
        const dirX = player.sdx || player.dir;
        const dirY = player.sdy || 0;
        const ax = player.x + dirX * range;
        const ay = player.y + dirY * range;
        
        if (Math.abs(boss.x - ax) < w && Math.abs(boss.y - ay) < h) {
          boss.hp -= 2;
          Sound.playSound('hit');
          if (boss.hp <= 0) {
            boss.dead = true;
            // ãƒœã‚¹ã‚’å€’ã—ãŸã‚‰ã‚³ã‚¤ãƒ³ã¨çµŒé¨“å€¤ã‚’ç²å¾—ï¼ˆã‚¢ã‚¤ãƒ†ãƒ ã¯å®ç®±ã‹ã‚‰å–å¾—ï¼‰
            if (!state.defeatedBosses.includes(boss.type)) {
              state.defeatedBosses.push(boss.type);
            }
            state.coins += 50;
            gainExp(10);
            showHint(`ğŸ’€ ${boss.type === 'suzaku' ? 'æœ±é›€' : boss.type === 'genbu' ? 'ç„æ­¦' : boss.type === 'seiryu' ? 'é’é¾' : 'éº’éºŸ'}æ’ƒç ´ï¼\nå®ç®±ã‚’ç¢ºèªã—ã¦ã¿ã‚ˆã†`, 3.0);
          }
        }
      }
      
      // ãƒœã‚¹ã¨ã®æ¥è§¦ãƒ€ãƒ¡ãƒ¼ã‚¸
      if (dist2(boss.x, boss.y, player.x, player.y) < 30*30) {
        hitPlayer(2);
      }
    }
    
    // æ‘é•·ãƒœã‚¹
    if (entities.chiefBoss && !entities.chiefBoss.dead) {
      entities.chiefBoss.update(dt);
      moveWithTile(entities.chiefBoss, dt);
      
      // æ‘é•·ã®å¼¾ã®æ›´æ–°
      for (const bullet of entities.chiefBoss.bullets) {
        bullet.x += bullet.vx * dt;
        bullet.y += bullet.vy * dt;
        bullet.life -= dt;
        
        if (dist2(bullet.x, bullet.y, player.x, player.y) < 10*10) {
          hitPlayer(3);
          bullet.life = 0;
        }
        
        if (bullet.life <= 0 || collidesTile(bullet.x, bullet.y, 5, 5)) {
          bullet.dead = true;
        }
      }
      
      for (let i = entities.chiefBoss.bullets.length - 1; i >= 0; i--) {
        if (entities.chiefBoss.bullets[i].dead || entities.chiefBoss.bullets[i].life <= 0) {
          entities.chiefBoss.bullets.splice(i, 1);
        }
      }
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ”»æ’ƒåˆ¤å®š
      if (player.swordT > 0) {
        const range = 30;
        const w = 20, h = 20;
        const dirX = player.sdx || player.dir;
        const dirY = player.sdy || 0;
        const ax = player.x + dirX * range;
        const ay = player.y + dirY * range;
        
        if (Math.abs(entities.chiefBoss.x - ax) < w && Math.abs(entities.chiefBoss.y - ay) < h) {
          entities.chiefBoss.hp -= 3;
          Sound.playSound('hit');
          
          // ãƒ•ã‚§ãƒ¼ã‚ºé·ç§»
          if (entities.chiefBoss.phase === 1 && entities.chiefBoss.hp <= 50) {
            entities.chiefBoss.phase = 2;
            // å¤‰å½¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
            entities.chiefBoss.targetScale = 3;
            entities.chiefBoss.isTransforming = true;
            entities.chiefBoss.transformTime = 0;
            // NPCãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿å¹ãå‡ºã—ã‚’è¡¨ç¤º
            if (entities.npcs.length > 0) {
              showSpeechBubble(entities.npcs[0], 'ãªã‚‰ã°åŠ›ã¥ãã˜ã‚ƒãªï¼');
            }
            Sound.playSound('level');
          } else if (entities.chiefBoss.phase === 2 && entities.chiefBoss.hp <= 25) {
            entities.chiefBoss.phase = 3;
            // å¤‰å½¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹ï¼ˆæ—¢ã«å·¨å¤§åŒ–ã—ã¦ã„ã‚‹å ´åˆã¯å†å¤‰å½¢ã—ãªã„ï¼‰
            if (entities.chiefBoss.scale < 3) {
              entities.chiefBoss.targetScale = 3;
              entities.chiefBoss.isTransforming = true;
              entities.chiefBoss.transformTime = 0;
            }
            // NPCãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿å¹ãå‡ºã—ã‚’è¡¨ç¤º
            if (entities.npcs.length > 0) {
              showSpeechBubble(entities.npcs[0], 'ãã†ã‹ã€æœ¬æ°—ã‚’ã ã™ã‹ã®ã†ï¼');
            }
            Sound.playSound('level');
          }
          
          if (entities.chiefBoss.hp <= 0) {
            entities.chiefBoss.dead = true;
            state.ending = true;
            showEnding();
          }
        }
      }
      
      // æ‘é•·ã¨ã®æ¥è§¦ãƒ€ãƒ¡ãƒ¼ã‚¸
      if (dist2(entities.chiefBoss.x, entities.chiefBoss.y, player.x, player.y) < 25*25) {
        hitPlayer(entities.chiefBoss.phase === 3 ? 4 : 2);
      }
    }

    // çŸ¢
    for (const ar of arrows){ 
      ar.x += ar.vx*dt; 
      ar.y += ar.vy*dt; 
      ar.life-=dt; 
      if (collidesTile(ar.x,ar.y,6,2)) ar.life=0; 
      if (ar.life<=0) ar.dead=true; 
      if (dist2(ar.x,ar.y,player.x,player.y)<12*12){ 
        ar.dead=true; 
        hitPlayer(1);
      } 
    }

    // æ‰‹è£å‰£
    for (const s of shurikens) {
      s.x += s.vx * dt;
      s.y += s.vy * dt;
      s.rot += dt * 20; // å›è»¢é€Ÿåº¦ã‚’ä¸Šã’ã‚‹
      s.life -= dt;
      
      if (collidesTile(s.x, s.y, 4, 4)) s.life = 0;
      if (s.life <= 0) s.dead = true;
      
      const entities = getMapEntities();
      const hit = (e) => Math.abs(e.x - s.x) < 8 && Math.abs(e.y - s.y) < 8;
      
      // å…¨ã¦ã®æ•µã‚¿ã‚¤ãƒ—ã«å½“ãŸã‚Šåˆ¤å®š
      const hitEnemy = (enemy, reward, exp, name) => {
        if (!enemy.dead && hit(enemy)) {
          enemy.hp--;
          // æ•µã‚’å¹ã£é£›ã°ã™
          const knockbackSpeed = 200;
          const knockbackDirX = Math.sign(enemy.x - s.x) || 1;
          const knockbackDirY = Math.sign(enemy.y - s.y) || 0;
          enemy.vx = knockbackDirX * knockbackSpeed;
          enemy.vy = knockbackDirY * knockbackSpeed;
          enemy.knockbackT = 0.3; // ãƒãƒƒã‚¯ãƒãƒƒã‚¯æ™‚é–“
          s.life = 0;
          if (enemy.hp <= 0) {
            enemy.dead = true;
            state.coins += reward;
            gainExp(exp);
            showHint(`â­ æ‰‹è£å‰£ã§${name}æ’ƒç ´!`);
          } else {
            Sound.playSound('hit');
          }
        }
      };
      
      for (const sl of entities.slimes) hitEnemy(sl, 3, 2, 'ã‚¹ãƒ©ã‚¤ãƒ ');
      for (const a of entities.archers) hitEnemy(a, 5, 3, 'ã‚¢ãƒ¼ãƒãƒ£ãƒ¼');
      for (const c of entities.cacti) hitEnemy(c, 4, 2, 'ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼');
      for (const w of entities.snowwolves) hitEnemy(w, 4, 3, 'é›ªã‚ªã‚ªã‚«ãƒŸ');
      for (const sc of entities.scorpions) hitEnemy(sc, 5, 3, 'ã‚µã‚½ãƒª');
      for (const k of entities.krakens) hitEnemy(k, 6, 4, 'ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³');
      for (const f of entities.firespirits) hitEnemy(f, 4, 2, 'ç‚ã®ç²¾éœŠ');
      // ãƒœã‚¹ã«ã‚‚å½“ãŸã‚‹
      for (const boss of entities.bosses) {
        if (!boss.dead && hit(boss)) {
          boss.hp--;
          s.life = 0;
          if (boss.hp <= 0) {
            boss.dead = true;
            if (!state.defeatedBosses.includes(boss.type)) {
              state.defeatedBosses.push(boss.type);
            }
            state.coins += 50;
            gainExp(10);
            const bossNames = {
              'suzaku': 'æœ±é›€',
              'genbu': 'ç„æ­¦',
              'seiryu': 'é’é¾',
              'kirin': 'éº’éºŸ'
            };
            showHint(`ğŸ’€ ${bossNames[boss.type]}æ’ƒç ´ï¼\nå®ç®±ã‚’ç¢ºèªã—ã¦ã¿ã‚ˆã†`, 3.0);
          }
        }
      }
    }

    // é•·æ§
    for (const sp of spears) {
      sp.x += sp.vx * dt;
      sp.y += sp.vy * dt;
      sp.rot += dt * 5;
      sp.life -= dt;
      
      if (collidesTile(sp.x, sp.y, 8, 20)) sp.life = 0;
      if (sp.life <= 0) sp.dead = true;
      
      const entities = getMapEntities();
      const hit = (e) => Math.abs(e.x - sp.x) < 12 && Math.abs(e.y - sp.y) < 12;
      
      // å…¨ã¦ã®æ•µã‚¿ã‚¤ãƒ—ã«å½“ãŸã‚Šåˆ¤å®š
      const hitEnemy = (enemy, reward, exp, name) => {
        if (!enemy.dead && hit(enemy)) {
          enemy.hp -= 2;
          sp.life = 0;
          if (enemy.hp <= 0) {
            enemy.dead = true;
            state.coins += reward;
            gainExp(exp);
            showHint(`ğŸ”± é•·æ§ã§${name}æ’ƒç ´!`);
          }
        }
      };
      
      for (const sl of entities.slimes) hitEnemy(sl, 3, 2, 'ã‚¹ãƒ©ã‚¤ãƒ ');
      for (const a of entities.archers) hitEnemy(a, 5, 3, 'ã‚¢ãƒ¼ãƒãƒ£ãƒ¼');
      for (const c of entities.cacti) hitEnemy(c, 4, 2, 'ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼');
      for (const w of entities.snowwolves) hitEnemy(w, 4, 3, 'é›ªã‚ªã‚ªã‚«ãƒŸ');
      for (const sc of entities.scorpions) hitEnemy(sc, 5, 3, 'ã‚µã‚½ãƒª');
      for (const k of entities.krakens) hitEnemy(k, 6, 4, 'ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³');
      for (const f of entities.firespirits) hitEnemy(f, 4, 2, 'ç‚ã®ç²¾éœŠ');
      // ãƒœã‚¹ã«ã‚‚å½“ãŸã‚‹
      for (const boss of entities.bosses) {
        if (!boss.dead && hit(boss)) {
          boss.hp -= 2;
          sp.life = 0;
          if (boss.hp <= 0) {
            boss.dead = true;
            if (!state.defeatedBosses.includes(boss.type)) {
              state.defeatedBosses.push(boss.type);
            }
            state.coins += 50;
            gainExp(10);
            const bossNames = {
              'suzaku': 'æœ±é›€',
              'genbu': 'ç„æ­¦',
              'seiryu': 'é’é¾',
              'kirin': 'éº’éºŸ'
            };
            showHint(`ğŸ’€ ${bossNames[boss.type]}æ’ƒç ´ï¼\nå®ç®±ã‚’ç¢ºèªã—ã¦ã¿ã‚ˆã†`, 3.0);
          }
        }
      }
    }

    // ãƒã‚ºãƒ¼ã‚«ã®ãƒ­ã‚±ãƒƒãƒˆ
    for (const r of rockets) {
      r.x += r.vx * dt;
      r.y += r.vy * dt;
      r.rot += dt * 3;
      r.life -= dt;
      
      // æ•µã¨ã®è¡çªãƒã‚§ãƒƒã‚¯ï¼ˆå¤§çˆ†ç™ºï¼‰
      const entities = getMapEntities();
      let hitEnemy = false;
      const hitRect = (e) => Math.abs(e.x - r.x) < 15 && Math.abs(e.y - r.y) < 15;
      
      // å…¨ã¦ã®æ•µã‚¿ã‚¤ãƒ—ã«å½“ãŸã‚Šåˆ¤å®š
      for (const sl of entities.slimes) {
        if (!sl.dead && hitRect(sl)) {
          sl.dead = true;
          hitEnemy = true;
        }
      }
      for (const a of entities.archers) {
        if (!a.dead && hitRect(a)) {
          a.dead = true;
          hitEnemy = true;
        }
      }
      for (const c of entities.cacti) {
        if (!c.dead && hitRect(c)) {
          c.dead = true;
          hitEnemy = true;
        }
      }
      for (const w of entities.snowwolves) {
        if (!w.dead && hitRect(w)) {
          w.dead = true;
          hitEnemy = true;
        }
      }
      for (const sc of entities.scorpions) {
        if (!sc.dead && hitRect(sc)) {
          sc.dead = true;
          hitEnemy = true;
        }
      }
      for (const k of entities.krakens) {
        if (!k.dead && hitRect(k)) {
          k.dead = true;
          hitEnemy = true;
        }
      }
      for (const f of entities.firespirits) {
        if (!f.dead && hitRect(f)) {
          f.dead = true;
          hitEnemy = true;
        }
      }
      // ãƒœã‚¹ã«ã‚‚å½“ãŸã‚‹
      for (const boss of entities.bosses) {
        if (!boss.dead && hitRect(boss)) {
          boss.hp -= 10;
          hitEnemy = true;
          if (boss.hp <= 0) boss.dead = true;
        }
      }
      
      if (hitEnemy || collidesTile(r.x, r.y, 6, 12) || r.life <= 0) {
        // å¤§çˆ†ç™ºï¼ˆä¸­å¿ƒã®çˆ†ç™ºï¼‰
        blasts.push(new Explosion(r.x, r.y));
        Sound.playSound('bomb');
        r.dead = true;
        
        // 4æ–¹å‘ã«ç ´ç‰‡ã‚’æ•£ã‚‰ã™
        const fragmentSpeed = 120;
        fragments.push(new Fragment(r.x, r.y, fragmentSpeed, 0)); // å³
        fragments.push(new Fragment(r.x, r.y, -fragmentSpeed, 0)); // å·¦
        fragments.push(new Fragment(r.x, r.y, 0, fragmentSpeed)); // ä¸‹
        fragments.push(new Fragment(r.x, r.y, 0, -fragmentSpeed)); // ä¸Š
        
        const entities = getMapEntities();
        const hitRect = (e) => Math.abs(e.x - r.x) < TS * 1.5 && Math.abs(e.y - r.y) < TS * 1.5;
        
        // å…¨ã¦ã®æ•µã‚¿ã‚¤ãƒ—ã«å½“ãŸã‚Šåˆ¤å®šï¼ˆ3ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼‰
        const hitEnemy = (enemy, reward, exp, name) => {
          if (!enemy.dead && hitRect(enemy)) {
            enemy.hp -= 3; // 3ãƒ€ãƒ¡ãƒ¼ã‚¸
            if (enemy.hp <= 0) {
              enemy.dead = true;
              state.coins += reward;
              gainExp(exp);
              showHint(`ğŸš€ ãƒã‚ºãƒ¼ã‚«ã§${name}æ’ƒç ´!`);
            } else {
              Sound.playSound('hit');
            }
          }
        };
        
        for (const sl of entities.slimes) hitEnemy(sl, 3, 2, 'ã‚¹ãƒ©ã‚¤ãƒ ');
        for (const a of entities.archers) hitEnemy(a, 5, 3, 'ã‚¢ãƒ¼ãƒãƒ£ãƒ¼');
        for (const c of entities.cacti) hitEnemy(c, 4, 2, 'ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼');
        for (const w of entities.snowwolves) hitEnemy(w, 4, 3, 'é›ªã‚ªã‚ªã‚«ãƒŸ');
        for (const sc of entities.scorpions) hitEnemy(sc, 5, 3, 'ã‚µã‚½ãƒª');
        for (const k of entities.krakens) hitEnemy(k, 6, 4, 'ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³');
        for (const f of entities.firespirits) hitEnemy(f, 4, 2, 'ç‚ã®ç²¾éœŠ');
        // ãƒœã‚¹ã«ã‚‚å½“ãŸã‚‹
        for (const boss of entities.bosses) {
          if (!boss.dead && hitRect(boss)) {
            boss.hp -= 3; // 3ãƒ€ãƒ¡ãƒ¼ã‚¸
            if (boss.hp <= 0) {
              boss.dead = true;
              const items = {
                'suzaku': 'æ‘é•·ã®æ–',
                'genbu': 'æ‘é•·ã®ãƒ¡ã‚¬ãƒ',
                'seiryu': 'æ‘é•·ã®è¨¼æ˜æ›¸',
                'kirin': 'æ‘é•·ã®ãƒãƒ³ã‚«ãƒ'
              };
              const itemName = items[boss.type];
              if (itemName && !state.bossItems.includes(itemName)) {
                state.bossItems.push(itemName);
                showHint(`ğŸ ${itemName}ã‚’ç²å¾—ï¼`, 3.0);
                Sound.playSound('level');
                if (state.bossItems.length === 4) {
                  setTimeout(() => showChiefEvent(), 1000);
                }
              }
              state.coins += 50;
              gainExp(10);
              const bossNames = {
                'suzaku': 'æœ±é›€',
                'genbu': 'ç„æ­¦',
                'seiryu': 'é’é¾',
                'kirin': 'éº’éºŸ'
              };
              showHint(`ğŸ’€ ${bossNames[boss.type]}æ’ƒç ´ï¼`, 3.0);
            }
          }
        }
        if (hitRect(player)) hitPlayer(2);
      }
    }

    // çˆ†å¼¾ï¼ˆç¾åœ¨ã®ãƒãƒƒãƒ—ã®çˆ†å¼¾ã®ã¿æ›´æ–°ï¼‰
    for (const b of bombs){ 
      if (b.mapX !== currentMapX || b.mapY !== currentMapY) continue; // ç¾åœ¨ã®ãƒãƒƒãƒ—ã®çˆ†å¼¾ã®ã¿
      b.t-=dt; 
      if (!b.exploded && b.t<=0){ 
        b.exploded = true; 
        blasts.push(new Explosion(b.x,b.y)); 
        Sound.playSound('bomb');
        
        const hitRect = (e) => Math.abs(e.x-b.x)<TS*1.5 && Math.abs(e.y-b.y)<8 || Math.abs(e.y-b.y)<TS*1.5 && Math.abs(e.x-b.x)<8;
        const bombEntities = getMapEntities();
        for (const s of bombEntities.slimes){ 
          if (!s.dead && hitRect(s)){ 
            s.dead=true; 
            state.coins+=3; 
            gainExp(2);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚¹ãƒ©ã‚¤ãƒ æ’ƒç ´!'); 
          } 
        }
        for (const a of bombEntities.archers){ 
          if (!a.dead && hitRect(a)){ 
            a.dead=true; 
            state.coins+=5; 
            gainExp(3);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚¢ãƒ¼ãƒãƒ£ãƒ¼æ’ƒç ´!'); 
          } 
        }
        for (const c of bombEntities.cacti){ 
          if (!c.dead && hitRect(c)){ 
            c.dead=true; 
            state.coins+=4; 
            gainExp(2);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼æ’ƒç ´!'); 
          } 
        }
        for (const w of bombEntities.snowwolves){ 
          if (!w.dead && hitRect(w)){ 
            w.dead=true; 
            state.coins+=4; 
            gainExp(3);
            showHint('ğŸ’¥ çˆ†å¼¾ã§é›ªã‚ªã‚ªã‚«ãƒŸæ’ƒç ´!'); 
          } 
        }
        for (const sc of bombEntities.scorpions){ 
          if (!sc.dead && hitRect(sc)){ 
            sc.dead=true; 
            state.coins+=5; 
            gainExp(3);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚µã‚½ãƒªæ’ƒç ´!'); 
          } 
        }
        for (const k of bombEntities.krakens){ 
          if (!k.dead && hitRect(k)){ 
            k.dead=true; 
            state.coins+=6; 
            gainExp(4);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³æ’ƒç ´!'); 
          } 
        }
        for (const f of bombEntities.firespirits){ 
          if (!f.dead && hitRect(f)){ 
            f.dead=true; 
            state.coins+=4; 
            gainExp(2);
            showHint('ğŸ’¥ çˆ†å¼¾ã§ç‚ã®ç²¾éœŠæ’ƒç ´!'); 
          } 
        }
        // ãƒœã‚¹ã«ã‚‚å½“ãŸã‚‹
        for (const boss of bombEntities.bosses) {
          if (!boss.dead && hitRect(boss)) {
            boss.hp -= 10;
            if (boss.hp <= 0) {
              boss.dead = true;
              const items = {
                'suzaku': 'æ‘é•·ã®æ–',
                'genbu': 'æ‘é•·ã®ãƒ¡ã‚¬ãƒ',
                'seiryu': 'æ‘é•·ã®è¨¼æ˜æ›¸',
                'kirin': 'æ‘é•·ã®ãƒãƒ³ã‚«ãƒ'
              };
              const itemName = items[boss.type];
              if (itemName && !state.bossItems.includes(itemName)) {
                state.bossItems.push(itemName);
                showHint(`ğŸ ${itemName}ã‚’ç²å¾—ï¼`, 3.0);
                Sound.playSound('level');
                if (state.bossItems.length === 4) {
                  setTimeout(() => showChiefEvent(), 1000);
                }
              }
              state.coins += 50;
              gainExp(10);
              const bossNames = {
                'suzaku': 'æœ±é›€',
                'genbu': 'ç„æ­¦',
                'seiryu': 'é’é¾',
                'kirin': 'éº’éºŸ'
              };
              showHint(`ğŸ’€ ${bossNames[boss.type]}æ’ƒç ´ï¼`, 3.0);
            }
          }
        }
        if (hitRect(player)) hitPlayer(2);
      } 
    }
    
    // å¾Œç‰‡ä»˜ã‘ï¼ˆç¾åœ¨ã®ãƒãƒƒãƒ—ã®çˆ†å¼¾ã®ã¿ï¼‰
    for (let i=bombs.length-1;i>=0;i--){ 
      if (bombs[i].mapX === currentMapX && bombs[i].mapY === currentMapY && bombs[i].exploded && bombs[i].t<=-0.3) {
        bombs.splice(i,1); 
      }
    }
    for (const ex of blasts){ ex.t-=dt; }
    for (let i=arrows.length-1;i>=0;i--) if (arrows[i].dead) arrows.splice(i,1);
    for (let i=shurikens.length-1;i>=0;i--) if (shurikens[i].dead || shurikens[i].life<=0) shurikens.splice(i,1);
    for (let i=spears.length-1;i>=0;i--) if (spears[i].dead || spears[i].life<=0) spears.splice(i,1);
    for (let i=rockets.length-1;i>=0;i--) if (rockets[i].dead || rockets[i].life<=0) rockets.splice(i,1);
    for (let i=fragments.length-1;i>=0;i--) if (fragments[i].dead || fragments[i].life<=0) fragments.splice(i,1);
    for (let i=blasts.length-1;i>=0;i--) if (blasts[i].t<=0) blasts.splice(i,1);

    // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«
    tutorialTick(dt, { 
      moved: (Math.abs(Input.ax)+Math.abs(Input.ay))>0.5, 
      attacked: Input.aDown, 
      opened: (Input.bDown && canOpen), 
      talked: (Input.bDown && canTalk)
    });

    // UIæ›´æ–°
    renderHUD(); 
    if (state.hintTimer > 0) {
      state.hintTimer -= dt;
      if (state.hintTimer <= 0) hintEl.classList.remove('show');
    }
    
    // å¹ãå‡ºã—ã®ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
    if (speechBubbleTimer > 0) {
      speechBubbleTimer -= dt;
      if (speechBubbleTimer <= 0) {
        hideSpeechBubble();
      }
    }
  }

  // ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—
  let acc = 0; 
  const FIXED = 1/60; 
  let last = performance.now();
  
  // ç”»é¢å›è»¢æ¡ˆå†…ã®è¡¨ç¤ºåˆ¶å¾¡
  const rotateHint = document.getElementById('rotateHint');
  const btnFullscreen = document.getElementById('btnFullscreen');
  
  // å…¨ç”»é¢å±•é–‹ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
  function isFullscreenSupported() {
    return !!(document.fullscreenEnabled || 
              document.webkitFullscreenEnabled || 
              document.mozFullScreenEnabled || 
              document.msFullscreenEnabled);
  }
  
  // å…¨ç”»é¢å±•é–‹ã®é–¢æ•°ï¼ˆã‚¯ãƒ­ã‚¹ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œï¼‰
  function requestFullscreen() {
    const element = document.documentElement;
    if (element.requestFullscreen) {
      return element.requestFullscreen();
    } else if (element.webkitRequestFullscreen) {
      return element.webkitRequestFullscreen();
    } else if (element.webkitRequestFullScreen) {
      return element.webkitRequestFullScreen();
    } else if (element.mozRequestFullScreen) {
      return element.mozRequestFullScreen();
    } else if (element.msRequestFullscreen) {
      return element.msRequestFullscreen();
    }
    return Promise.reject(new Error('Fullscreen API not supported'));
  }
  
  // æ¨ªç”»é¢ã‹ã©ã†ã‹ã‚’åˆ¤å®šï¼ˆè¤‡æ•°ã®æ–¹æ³•ã§ç¢ºèªï¼‰
  function isLandscapeMode() {
    // æ–¹æ³•1: CSS media query
    const mediaQuery = window.matchMedia('(orientation: landscape)');
    if (mediaQuery.matches) return true;
    
    // æ–¹æ³•2: ç”»é¢ã‚µã‚¤ã‚ºã®æ¯”è¼ƒï¼ˆã‚ˆã‚Šç¢ºå®Ÿï¼‰
    const width = window.innerWidth || document.documentElement.clientWidth;
    const height = window.innerHeight || document.documentElement.clientHeight;
    if (width > height) return true;
    
    // æ–¹æ³•3: screen.orientation APIï¼ˆå¯¾å¿œã—ã¦ã„ã‚‹å ´åˆï¼‰
    if (screen.orientation) {
      const angle = screen.orientation.angle;
      if (angle === 90 || angle === -90 || angle === 270) return true;
    }
    
    return false;
  }
  
  function checkOrientation() {
    if (!isMobile) {
      state.canPlay = true;
      if (rotateHint) rotateHint.classList.remove('show');
      return;
    }
    
    const isLandscape = isLandscapeMode();
    if (isLandscape) {
      state.canPlay = true;
      if (rotateHint) rotateHint.classList.remove('show');
      
      // å…¨ç”»é¢å±•é–‹ãƒœã‚¿ãƒ³ã‚’éè¡¨ç¤º
      if (btnFullscreen) btnFullscreen.style.display = 'none';
      
      // æ¨ªç”»é¢ã«ãªã£ãŸã‚‰è‡ªå‹•çš„ã«å…¨ç”»é¢å±•é–‹ã‚’è©¦ã¿ã‚‹
      // ãŸã ã—ã€æ—¢ã«å…¨ç”»é¢ã®å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
      if (!document.fullscreenElement && 
          !document.webkitFullscreenElement && 
          !document.mozFullScreenElement && 
          !document.msFullscreenElement) {
        requestFullscreen().catch(err => {
          // å…¨ç”»é¢å±•é–‹ãŒå¤±æ•—ã—ã¦ã‚‚ã‚²ãƒ¼ãƒ ã¯é–‹å§‹ã™ã‚‹
          console.log('å…¨ç”»é¢å±•é–‹ã«å¤±æ•—ã—ã¾ã—ãŸ:', err);
        });
      }
    } else {
      state.canPlay = false;
      if (rotateHint) rotateHint.classList.add('show');
      
      // å…¨ç”»é¢å±•é–‹ãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã‚‹å ´åˆã€ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
      if (btnFullscreen && isFullscreenSupported()) {
        btnFullscreen.style.display = 'block';
      } else if (btnFullscreen) {
        btnFullscreen.style.display = 'none';
      }
    }
  }
  
  // å…¨ç”»é¢å±•é–‹ãƒœã‚¿ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼
  if (btnFullscreen) {
    btnFullscreen.addEventListener('click', () => {
      requestFullscreen().then(() => {
        // å…¨ç”»é¢å±•é–‹æˆåŠŸå¾Œã€ç”»é¢ã®å‘ãã‚’å†ãƒã‚§ãƒƒã‚¯
        setTimeout(checkOrientation, 200);
      }).catch(err => {
        console.log('å…¨ç”»é¢å±•é–‹ã«å¤±æ•—ã—ã¾ã—ãŸ:', err);
        alert('å…¨ç”»é¢å±•é–‹ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ç”»é¢ã‚’æ¨ªã«ã—ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
      });
    });
  }
  
  // åˆæœŸãƒã‚§ãƒƒã‚¯
  checkOrientation();
  
  // ç”»é¢å‘ãå¤‰æ›´ã‚’ç›£è¦–
  window.addEventListener('orientationchange', () => {
    setTimeout(checkOrientation, 200); // å‘ãå¤‰æ›´ã®åæ˜ ã‚’å¾…ã¤ï¼ˆå°‘ã—é•·ã‚ã«ï¼‰
  });
  
  // ãƒªã‚µã‚¤ã‚ºæ™‚ã‚‚ãƒã‚§ãƒƒã‚¯ï¼ˆå¿µã®ãŸã‚ï¼‰
  window.addEventListener('resize', () => {
    setTimeout(checkOrientation, 100);
  });
  
  // å…¨ç”»é¢çŠ¶æ…‹ã®å¤‰æ›´ã‚’ç›£è¦–ï¼ˆå…¨ç”»é¢ãŒè§£é™¤ã•ã‚ŒãŸå ´åˆã®å‡¦ç†ï¼‰
  document.addEventListener('fullscreenchange', checkOrientation);
  document.addEventListener('webkitfullscreenchange', checkOrientation);
  document.addEventListener('mozfullscreenchange', checkOrientation);
  document.addEventListener('MSFullscreenChange', checkOrientation);

  function loop(){
    const t = performance.now(); 
    let dt = (t - last)/1000; 
    last = t; 
    dt = Math.min(dt, 0.05);

    // æºå¸¯ã®å ´åˆã¯æ¨ªç”»é¢ã«ãªã‚‹ã¾ã§ã‚²ãƒ¼ãƒ ã‚’åœæ­¢
    if (isMobile && !state.canPlay) {
      draw(); // æç”»ã®ã¿ï¼ˆç”»é¢å›è»¢æ¡ˆå†…ã‚’è¡¨ç¤ºï¼‰
      requestAnimationFrame(loop);
      return;
    }

    if (!state.paused && !state.ending){
      acc += dt; 
      while (acc >= FIXED){ 
        Input.updateEdges(); 
        update(FIXED); 
        acc -= FIXED; 
        Input.aDown=Input.bDown=Input.xDown=false; 
      }
      draw();
    } else if (state.ending) {
      // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã¯æç”»ã®ã¿
      draw();
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«
  const tut = document.getElementById('tutorial');
  const tutContent = document.getElementById('tutContent');
  const tutNext = document.getElementById('tutNext');
  const tutSkip = document.getElementById('tutSkip');
  
  const steps = [
    { text: 'ğŸ® å·¦ã®ã‚¹ãƒ†ã‚£ãƒƒã‚¯ã‹çŸ¢å°ã‚­ãƒ¼ã§æ­©ã„ã¦ã¿ã¾ã—ã‚‡ã†ï¼', check: s=> s.moved },
    { text: 'âš”ï¸ âš”ï¸ãƒœã‚¿ãƒ³ã§æ”»æ’ƒï¼ã‚¹ãƒ©ã‚¤ãƒ ã‚’å€’ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚', check: s=> s.attacked },
    { text: 'ğŸ’¬ ğŸ’¬ãƒœã‚¿ãƒ³ã§å®ç®±ã‚’é–‹ã‘ãŸã‚Šã€é­”æ³•ä½¿ã„ã¨è©±ã—ãŸã‚Šã§ãã¾ã™ã€‚', check: s=> s.opened || s.talked },
    { text: 'ğŸ’£ ğŸ’£ãƒœã‚¿ãƒ³ã§çˆ†å¼¾ã‚’è¨­ç½®ï¼æ•µã‚’ã¾ã¨ã‚ã¦å€’ã›ã¾ã™ã€‚ã•ã‚å†’é™ºã—ã‚ˆã†ï¼', check: s=> true },
  ];
  
  function tutorialOpen(){ 
    state.tutorialStep = 0; 
    tut.showModal(); 
    renderStep(); 
  }
  
  function renderStep(){ 
    tutContent.innerHTML = `<p>${steps[state.tutorialStep].text}</p>`; 
  }
  
  function tutorialTick(dt, flags){
    const st = steps[state.tutorialStep]; 
    if (!st) return; 
    if (st.check(flags)) nextStep();
  }
  
  function nextStep(){ 
    state.tutorialStep++; 
    if (state.tutorialStep >= steps.length){ 
      tut.close(); 
      showHint('ğŸŒŸ å†’é™ºã‚’æ¥½ã—ã‚“ã§ã­ï¼', 4.0); 
      Sound.playSound('level');
    } else { 
      renderStep(); 
    } 
  }
  
  tutNext.addEventListener('click', ()=> { nextStep(); Sound.playSound('button'); });
  tutSkip.addEventListener('click', ()=> { tut.close(); Sound.playSound('button'); });
  
  // æºå¸¯ã®å ´åˆã¯æ¨ªç”»é¢ã«ãªã‚‹ã¾ã§ãƒãƒ¥ãƒ¼ãƒˆãƒªã‚¢ãƒ«ã‚’é–‹å§‹ã—ãªã„
  if (isMobile && !state.canPlay) {
    // æ¨ªç”»é¢ã«ãªã‚‹ã¾ã§å¾…æ©Ÿ
    const checkAndStartTutorial = () => {
      if (state.canPlay) {
        setTimeout(tutorialOpen, 800);
      } else {
        setTimeout(checkAndStartTutorial, 500);
      }
    };
    checkAndStartTutorial();
  } else {
    setTimeout(tutorialOpen, 800);
  }

  // æ­¦å™¨åˆ‡ã‚Šæ›¿ãˆ
  const weaponSelect = document.getElementById('weaponSelect');
  const weaponList = document.getElementById('weaponList');
  const btnPause = document.getElementById('btnPause');
  const btnCloseWeapon = document.getElementById('btnCloseWeapon');

  function renderWeaponList() {
    weaponList.innerHTML = '';
    state.weapons.forEach(weaponId => {
      const weapon = Object.values(WEAPONS).find(w => w.id === weaponId);
      if (!weapon) return;
      
      const isEquipped = state.currentWeapon === weaponId;
      const item = document.createElement('div');
      item.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: space-between;
        padding: 12px;
        margin: 8px 0;
        background: ${isEquipped ? 'rgba(139,211,255,0.2)' : 'var(--panel)'};
        border: 2px solid ${isEquipped ? 'var(--accent)' : 'var(--outline)'};
        border-radius: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
      `;
      
      item.innerHTML = `
        <div style="display: flex; align-items: center; gap: 12px;">
          <span style="font-size: 24px;">${weapon.icon}</span>
          <span style="font-weight: 700;">${weapon.name}</span>
        </div>
        ${isEquipped ? '<span style="color: var(--accent); font-weight: 800;">è£…å‚™ä¸­</span>' : ''}
      `;
      
      // è£…å‚™æ¸ˆã¿ã§ã‚‚ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ï¼ˆãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‰ã˜ã‚‹ãŸã‚ï¼‰
      item.addEventListener('click', () => {
        if (!isEquipped) {
          state.currentWeapon = weaponId;
          renderWeaponList();
          updateWeaponButton();
        }
        Sound.playSound('button');
        // æ­¦å™¨é¸æŠå¾Œã€å³åº§ã«ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ã‚’é–‰ã˜ã¦ãƒãƒ¼ã‚ºã‚’è§£é™¤
        weaponSelect.close();
        // ç¢ºå®Ÿã«ãƒãƒ¼ã‚ºã‚’è§£é™¤ï¼ˆå³åº§ã«å®Ÿè¡Œï¼‰
        state.paused = false;
      });
      
      weaponList.appendChild(item);
    });
  }

  function updateWeaponButton() {
    const weapon = Object.values(WEAPONS).find(w => w.id === state.currentWeapon);
    if (weapon) {
      const weaponIcon = document.getElementById('weaponIcon');
      if (weaponIcon) {
        weaponIcon.textContent = weapon.icon;
      }
      btnX.title = weapon.name;
    }
  }

  function toggleWeaponSelect(){
    if (state.ending) return; // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ä¸­ã¯ç„¡åŠ¹
    
    state.paused = !state.paused;
    if (state.paused){ 
      renderWeaponList();
      weaponSelect.showModal(); 
    } else { 
      weaponSelect.close(); 
      state.paused = false; // ç¢ºå®Ÿã«ãƒãƒ¼ã‚ºã‚’è§£é™¤
    }
  }
  
  // ãƒ€ã‚¤ã‚¢ãƒ­ã‚°ãŒé–‰ã˜ã‚‰ã‚ŒãŸæ™‚ã«ãƒãƒ¼ã‚ºã‚’è§£é™¤
  weaponSelect.addEventListener('close', () => {
    state.paused = false;
  });

  btnPause.addEventListener('click', ()=> { toggleWeaponSelect(); Sound.playSound('button'); });
  if (btnPauseLandscape) {
    btnPauseLandscape.addEventListener('click', ()=> { toggleWeaponSelect(); Sound.playSound('button'); });
  }
  btnCloseWeapon.addEventListener('click', ()=> { toggleWeaponSelect(); Sound.playSound('button'); });

  // æ‘é•·ã‚¤ãƒ™ãƒ³ãƒˆ
  const chiefEvent = document.getElementById('chiefEvent');
  const chiefEventContent = document.getElementById('chiefEventContent');
  const btnChiefYes = document.getElementById('btnChiefYes');
  const btnChiefNo = document.getElementById('btnChiefNo');

  function showChiefEvent() {
    // æ—¢ã«è¡¨ç¤ºæ¸ˆã¿ã®å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (state.chiefEventShown) {
      return;
    }
    
    state.paused = true;
    state.chiefEventShown = true;
    chiefEventContent.innerHTML = `
      <p style="margin: 0 0 16px 0;">4ã¤ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’é›†ã‚ãŸå‹‡è€…ã‚ˆã€</p>
      <p style="margin: 0 0 16px 0;">ã‚ã—ã‚‚å¹´ã‚’å–ã£ã¦ã€ã‚‚ã†æ‘é•·ã‚’ç¶šã‘ã‚‹ã®ãŒé›£ã—ããªã£ã¦ããŸã€‚</p>
      <p style="margin: 0 0 16px 0;">å›ã«æ‘é•·ã‚’ç¶™ã„ã§ã‚‚ã‚‰ã„ãŸã„ã‚“ã ãŒã€</p>
      <p style="margin: 0;">ã“ã®æ‘ã‚’å®ˆã£ã¦ãã‚Œã‚‹ã‹ï¼Ÿ</p>
    `;
    chiefEvent.showModal();
  }

  btnChiefYes.addEventListener('click', () => {
    chiefEvent.close();
    showEnding('å‹‡è€…ã¯æ‘é•·ã¨ã—ã¦åƒãã“ã¨ã«ãªã£ãŸã€‚\n\næ‘ã¯å¹³å’Œã«ãªã‚Šã€\näººã€…ã¯å¹¸ã›ã«æš®ã‚‰ã—ãŸã€‚');
    Sound.playSound('level');
  });

  btnChiefNo.addEventListener('click', () => {
    chiefEvent.close();
    state.paused = false;
    // æ‘é•·ãƒœã‚¹ã‚’å‡ºç¾
    const entities = getMapEntities();
    if (entities.npcs.length > 0) {
      const npc = entities.npcs[0];
      entities.chiefBoss = new VillageChiefBoss(npc.x, npc.y);
      showSpeechBubble(npc, 'ãªã‚‰ã°åŠ›ã¥ãã˜ã‚ƒãªï¼');
      Sound.playSound('bomb');
    }
  });

  // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
  const endingDialog = document.getElementById('ending');
  const endingContent = document.getElementById('endingContent');
  const btnEndingClose = document.getElementById('btnEndingClose');

  function showEnding(text = '') {
    state.paused = true;
    state.ending = true;
    
    if (!text) {
      text = 'æ‘é•·ã‚’å€’ã—ãŸå‹‡è€…ã¯ã€\n\nçœŸã®åŠ›ã‚’æ‰‹ã«å…¥ã‚ŒãŸã€‚\n\næ‘ã¯æ–°ãŸãªæ™‚ä»£ã‚’è¿ãˆãŸ...';
    }
    
    // ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ç¨®é¡ã‚’åˆ¤å®šï¼ˆYESã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‹ã©ã†ã‹ï¼‰
    const isYesEnding = text.includes('æ‘é•·ã¨ã—ã¦åƒã');
    
    if (isYesEnding) {
      // YESã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ï¼šè¿«åŠ›ã®ã‚ã‚‹æ¼”å‡ºã¨ç™»å ´äººç‰©
      endingContent.innerHTML = `
        <div style="animation: fadeIn 1s ease-in;">
          <p style="white-space: pre-line; text-align: center; font-size: 24px; line-height: 2; font-weight: bold; color: #ffd700; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin-bottom: 20px;">
            âœ¨ çœŸã®å‹‡è€…ã®ç‰©èª âœ¨
          </p>
          <p style="white-space: pre-line; text-align: center; font-size: 20px; line-height: 2; color: #fff; margin-bottom: 20px;">
            ${text}
          </p>
          
          <div style="text-align: center; margin: 30px 0; padding: 20px; background: rgba(0,0,0,0.3); border-radius: 10px;">
            <p style="font-size: 18px; color: #ffd700; margin-bottom: 15px; font-weight: bold;">ç™»å ´äººç‰©</p>
            <div style="display: flex; flex-wrap: wrap; justify-content: center; gap: 15px; font-size: 14px; color: #fff;">
              <div>ğŸ‘´ æ‘é•·ï¼ˆé•·è€ï¼‰</div>
              <div>ğŸ¦¸ å‹‡è€…</div>
              <div>ğŸŸ¢ ã‚¹ãƒ©ã‚¤ãƒ </div>
              <div>ğŸ¹ ã‚¢ãƒ¼ãƒãƒ£ãƒ¼</div>
              <div>ğŸŒµ ã‚µãƒœãƒ†ãƒ³ãƒ¢ãƒ³ã‚¹ã‚¿ãƒ¼</div>
              <div>ğŸº é›ªã‚ªã‚ªã‚«ãƒŸ</div>
              <div>ğŸ¦‚ ã‚µã‚½ãƒª</div>
              <div>ğŸ™ ã‚¯ãƒ©ãƒ¼ã‚±ãƒ³</div>
              <div>ğŸ”¥ ç«ã®ç²¾éœŠ</div>
              <div>ğŸ‰ æœ±é›€</div>
              <div>ğŸ¢ ç„æ­¦</div>
              <div>ğŸ² é’é¾</div>
              <div>ğŸ¦Œ éº’éºŸ</div>
            </div>
          </div>
          
          <div style="text-align: center; margin-top: 30px;">
            <div style="display: inline-block; animation: pulse 2s infinite;">
              <p style="font-size: 32px; margin: 0;">ğŸ†</p>
            </div>
          </div>
          <p style="white-space: pre-line; text-align: center; font-size: 16px; line-height: 2; color: #ccc; margin-top: 30px;">
            å‹‡è€…ã®é¸æŠã«ã‚ˆã‚Šã€<br>
            æ‘ã¯æ°¸é ã®å¹³å’Œã‚’æ‰‹ã«å…¥ã‚ŒãŸã€‚<br>
            <br>
            äººã€…ã¯å‹‡è€…ã‚’ç§°ãˆã€<br>
            ãã®åã¯æ°¸é ã«èªã‚Šç¶™ãŒã‚Œã‚‹...
          </p>
        </div>
        <style>
          @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
          }
          @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); }
          }
        </style>
      `;
    } else {
      // é€šå¸¸ã‚¨ãƒ³ãƒ‡ã‚£ãƒ³ã‚°
      endingContent.innerHTML = `<p style="white-space: pre-line; text-align: center; font-size: 18px; line-height: 1.8;">${text}</p>`;
    }
    
    endingDialog.showModal();
  }

  btnEndingClose.addEventListener('click', () => {
    endingDialog.close();
    Sound.playSound('button');
    // ã‚¿ã‚¤ãƒˆãƒ«ã«æˆ»ã‚‹ï¼ˆãƒšãƒ¼ã‚¸ã‚’ãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦BGMã‚’æœ€åˆã‹ã‚‰å†ç”Ÿï¼‰
    stopBGM();
    setTimeout(() => {
      location.reload();
    }, 300);
  });
  
  // åˆæœŸåŒ–
  updateWeaponButton();

  // åˆæœŸåŒ–
  markMapVisited(currentMapX, currentMapY); // åˆæœŸãƒãƒƒãƒ—ã‚’è¨ªå•æ¸ˆã¿ã«
  renderHUD();
  drawMinimap(); // åˆæœŸãƒŸãƒ‹ãƒãƒƒãƒ—ã‚’æç”»
  showHint('ğŸ® ç§»å‹•ã—ã¦ã¿ã‚ˆã†', 3);

})();
</script>
</body>
</html>
